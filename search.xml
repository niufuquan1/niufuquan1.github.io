<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【每日算法】LeetCode 58 —— 最后一个单词长度（一百五十）</title>
      <link href="2021/05/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-58-%E2%80%94%E2%80%94-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%EF%BC%88%E4%B8%80%E7%99%BE%E4%BA%94%E5%8D%81%EF%BC%89/"/>
      <url>2021/05/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-58-%E2%80%94%E2%80%94-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%EF%BC%88%E4%B8%80%E7%99%BE%E4%BA%94%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。</p><p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：s = “Hello World”<br>输出：5</p><p>示例 2：</p><p>输入：s = “ “<br>输出：0</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、1 &lt;= s.length &lt;= 10^4<br>2、s 仅有英文字母和空格 ‘ ‘ 组成</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题可以使用语言提供的API来求解，也可以使用双指针的思想求解，这里给出双指针的思路。</p><p>首先，定义i和j两个指针用于搜索满足条件的字符</p><p>然后，让两个指针从字符串的末尾开始往前遍历。先把末尾的空格处理掉，让i搜索到最后一个单词的开头，然后让j继续往前走，走到其遇到可空格</p><p>最后，返回i-j就是最后一个单词的长度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// //使用stringStream求解。</span></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     int lengthOfLastWord(string s) &#123;</span></span><br><span class="line"><span class="comment">//         stringstream ssin(s);</span></span><br><span class="line"><span class="comment">//         int res = 0;</span></span><br><span class="line"><span class="comment">//         string word;</span></span><br><span class="line"><span class="comment">//         while(ssin &gt;&gt; word) res = word.size();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         return res;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针算法,从后往前遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[j] != <span class="string">&#x27; &#x27;</span>) j--;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 57 —— 插入区间（一百四十九）</title>
      <link href="2021/05/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-57-%E2%80%94%E2%80%94-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
      <url>2021/05/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-57-%E2%80%94%E2%80%94-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你一个 无重叠的 ，按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：intervals = [[1,3],[6,9]], newInterval = [2,5]<br>输出：[[1,5],[6,9]]<br>示例 2：</p><p>输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]<br>输出：[[1,2],[3,10],[12,16]]<br>解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。<br>示例 3：</p><p>输入：intervals = [], newInterval = [5,7]<br>输出：[[5,7]]<br>示例 4：</p><p>输入：intervals = [[1,5]], newInterval = [2,3]<br>输出：[[1,5]]<br>示例 5：</p><p>输入：intervals = [[1,5]], newInterval = [2,7]<br>输出：[[1,7]]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、0 &lt;= intervals.length &lt;= 10^4<br>2、intervals[i].length == 2<br>3、0 &lt;= intervals<code>[i][0]</code> &lt;= intervals<code>[i][1]</code> &lt;= 10^5<br>4、intervals 根据intervals<code>[i][0]</code>按 升序 排列<br>5、newInterval.length == 2<br>6、0 &lt;= newInterval[0] &lt;= newInterval[1] &lt;= 10^5</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是对合并区间的扩展应用。要求解本题，需要考虑三个情况，即：</p><p>1、可能存在的靠左区间完全与新区间没有交集的部分</p><p>2、可能存在的中间区间与新区间有交集的部分</p><p>3、可能存在的右边区间与新区间没有交集的部分</p><p>画图如下所示：</p><p><img src="/2021/05/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-57-%E2%80%94%E2%80%94-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%B9%9D%EF%BC%89/1.png" alt></p><p>因此，仅仅需要将三个部分找出来，然后进行处理即可。</p><p>第一部分满足，遍历区间的右端点大于需要合并的区间的左端点</p><p>第三部分，满足需要合并的区间的右端点小于遍历区间的左端点</p><p>第二部分，需要确定交集的情况，求出遍历和合并区间的左端点的全局最小值，求出遍历和合并区间的右端点的全局最大值，然后生成新的区间，并将原有的区间内部的区间替换为当前求出的区间即可。</p><p>具体实现，请参考代码注释。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">insert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分成三部分考虑，第一部分是左边与新区间完全没有交集的部分，第二部分是中间与新区间有交集的部分，第三部分是右边完全与新区间完全没有交集的部分。</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; a.size() &amp;&amp; a[k][<span class="number">1</span>] &lt; b[<span class="number">0</span>])res.push_back(a[k++]);<span class="comment">//左边完全完全没有交集的部分</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt; a.size())&#123;</span><br><span class="line">            <span class="comment">//根据大小关系判断并确定b的左右端点</span></span><br><span class="line">            b[<span class="number">0</span>] = min(b[<span class="number">0</span>],a[k][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">while</span>(k &lt; a.size() &amp;&amp; a[k][<span class="number">0</span>] &lt;= b[<span class="number">1</span>]) b[<span class="number">1</span>] = max(b[<span class="number">1</span>],a[k++][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(b);<span class="comment">//将b添加到答案中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k &lt; a.size())res.push_back(a[k++]);<span class="comment">//右边完全没有交集的部分</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 56 —— 合并区间（一百四十八）</title>
      <link href="2021/05/22/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-56-%E2%80%94%E2%80%94-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%85%AB%EF%BC%89/"/>
      <url>2021/05/22/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-56-%E2%80%94%E2%80%94-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2：</p><p>输入：intervals = [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1 &lt;= intervals.length &lt;= 10^4<br>intervals[i].length == 2<br>0 &lt;= start[i] &lt;= end[i] &lt;= 10^4</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是将重复区间进行合并，最终得出有效的合并后区间。</p><p>首先，看下图:</p><p><img src="/2021/05/22/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-56-%E2%80%94%E2%80%94-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%85%AB%EF%BC%89/1.png" alt></p><p>根据上图，我们把1到5的区间最终分为了两段红色区间。</p><p>在解题思路上，我们需要将给出的区间按照左端点进行排序，如果左端点相同则按照右端点排序。</p><p>如果下一个区间的左端点小于等于上一个区间的右端点，说明有交集，需要合并以及更新右端点;否则不需要，保存当前的区间即可。</p><p>在实现上，我们可以设置一个临时的左右区间判断标识l和r，用于判断合并。</p><p>具体，请看代码和注释。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//按左端点排序，如果下一个区间的左端点小于等于上一个区间的右端点，说明有交集，则需要合并，更新右端点;否则不需要,保存当前区间即可。</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(intervals.empty()) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        sort(intervals.begin(),intervals.end());<span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = intervals[<span class="number">0</span>][<span class="number">0</span>], r = intervals[<span class="number">0</span>][<span class="number">1</span>];<span class="comment">//设置一个临时的l和r，用于更新和合并。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//i可以用1开始，因为第一个区间的左右端点都有了，不需要再次进行遍历</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt; r)&#123;</span><br><span class="line">                <span class="comment">//当第二个区间左端点大于第一个区间的右端点，则说明，第一个区间直接可以保存即可</span></span><br><span class="line">                res.push_back(&#123;l, r&#125;);</span><br><span class="line">                l = intervals[i][<span class="number">0</span>], r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = max(r,intervals[i][<span class="number">1</span>]);<span class="comment">//右端点更新为最大值即可 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(&#123;l, r&#125;);<span class="comment">//最后一个区间在更新完l和r之后就没有保存了，需要在for循环外面将其加上。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 55 —— 跳跃游戏（一百四十七）</title>
      <link href="2021/05/21/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-55-%E2%80%94%E2%80%94-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>2021/05/21/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-55-%E2%80%94%E2%80%94-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p><p>示例 2：</p><p>输入：nums = [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、1 &lt;= nums.length &lt;= 3 * 10^4<br>2、0 &lt;= nums[i] &lt;= 10^5</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是lc45题的类型题，本题总体比lc45题简单，仅需要判断是否能够到达最后一个下标。与lc45题的思路类似，每个下标能够到达，说明到达的路径一定是连续的，不可能存在后一个地方可到达，前一个地方到达不了的情况。</p><p>在本题中，我们需要使用贪心的思想，即每次求出每一步可到达的最右距离，如果大于了最后的下标，说明能够到达，如果小于最后下标，则说明无法到达。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//求i+nums[i]的最大值是否能够满足大于等于nums.size()即可。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//j表示能调到的最右边的距离</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            j = max(j, nums[i]+ i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 54 —— 螺旋矩阵（一百四十六）</title>
      <link href="2021/05/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-54-%E2%80%94%E2%80%94-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>2021/05/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-54-%E2%80%94%E2%80%94-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p><img src="/2021/05/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-54-%E2%80%94%E2%80%94-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%85%AD%EF%BC%89/1.png" alt></p><p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p><p>示例 2：</p><p><img src="/2021/05/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-54-%E2%80%94%E2%80%94-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%85%AD%EF%BC%89/2.png" alt></p><p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、m == matrix.length<br>2、n == matrix[i].length<br>3、1 &lt;= m, n &lt;= 10<br>4、-100 &lt;= matrix<code>[i][j]</code> &lt;= 100</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是一道比较经典的题目，重点考察对矩阵的遍历以及边界值的判断。</p><p>首先，要解此题，需要定义四个方向，然后每次炒朝一个方向走，走到头通过判定然后推到另一个方向，最终走到不能走为止。因为是顺时针的螺旋顺序，因此方向依次为→↓←↑。</p><p>我们来定义一下四个方向，如下图：</p><p><img src="/2021/05/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-54-%E2%80%94%E2%80%94-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%85%AD%EF%BC%89/3.png" alt></p><p>具体，请看代码注释。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义四个方向，然后根据越界和是否走过两个指标判断是否应该走下一个方向，最终遍历完毕整个矩阵</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;<span class="comment">//首先，定义答案</span></span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();<span class="comment">//获得矩阵的尺寸</span></span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].size();<span class="comment">//获得矩阵的尺寸</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;; <span class="comment">//定义一个方向数组</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">st</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m))</span></span>;<span class="comment">//定义一个判重数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">0</span>; i &lt; n * m; i++)&#123;</span><br><span class="line">            <span class="comment">//左上角，x = 0，y = 0。d代表方向。</span></span><br><span class="line">            res.push_back(matrix[x][y]);</span><br><span class="line">            st[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> a = x + dx[d], b = y + dy[d];</span><br><span class="line">          <span class="comment">//判断a是否越界或者b是否越界或者matrix[a][b]是否被走过</span></span><br><span class="line">            <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m || st[a][b])&#123;</span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>;<span class="comment">//d一定在0，1，2，3内部循环。</span></span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 53 —— 最大子序和（一百四十五）</title>
      <link href="2021/05/19/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-53-%E2%80%94%E2%80%94-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>2021/05/19/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-53-%E2%80%94%E2%80%94-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p><p>示例 2：</p><p>输入：nums = [1]<br>输出：1</p><p>示例 3：</p><p>输入：nums = [0]<br>输出：0</p><p>示例 4：</p><p>输入：nums = [-1]<br>输出：-1</p><p>示例 5：</p><p>输入：nums = [-100000]<br>输出：-100000</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、1 &lt;= nums.length &lt;= 3 * 10^4<br>2、-10^5 &lt;= nums[i] &lt;= 10^5</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题考查动态规划思想。</p><p>1、定义状态表示函数f[i]：表示所有以nums[i]为结尾的区间的最大和</p><p>2、定义递归表达式：f[i] = max( f[i-1] + nums[i] , nums[i]) = nums[i] + max(f[i - 1] , 0)</p><p>这里解释一下递推表达式是这样的。</p><p>以nums[i]为结尾的区间可以分为两类，一类是仅存在nums[i]，另一类则是max(从nums[i-1]到nums[i],从nums[i-2]到nums[i],…,从0到nums[i])，而这里将nums[i]提取出来，则剩下的就是f[i-1]。</p><p>所以，可得出递推表达式。</p><p>我们再求出f[i]中的全局最大值即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//f[i]表示所有以nums[i]结尾的区间的最大和</span></span><br><span class="line">        <span class="comment">//f[i] = max&#123;f[i - 1] + nums[i], nums[i]&#125; = nums[i] + max&#123;f[i - 1], 0&#125;</span></span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN;<span class="comment">//首先，初始化最终结果为int最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, last = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            last = nums[i] + max(last, <span class="number">0</span>);<span class="comment">//last记录f[i-1]</span></span><br><span class="line">            res = max(res, last);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 52 —— N 皇后II （一百四十四）</title>
      <link href="2021/05/19/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-52-%E2%80%94%E2%80%94-N-%E7%9A%87%E5%90%8EII-%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>2021/05/19/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-52-%E2%80%94%E2%80%94-N-%E7%9A%87%E5%90%8EII-%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p><img src="/2021/05/19/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-52-%E2%80%94%E2%80%94-N-%E7%9A%87%E5%90%8EII-%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%9B%9B%EF%BC%89/1.png" alt></p><p>输入：n = 4<br>输出：2<br>解释：如上图所示，4 皇后问题存在两个不同的解法。</p><p>示例 2：</p><p>输入：n = 1<br>输出：1</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、1 &lt;= n &lt;= 9<br>2、皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题与上题不同点在于本题求方案数，因此可以在搜索函数中直接累计求出。</p><p>在思路上，与上题完全一致，就是根据n皇后的规则进行判断，首先，用布尔数组表示出两条对角线的和以及行和列的放置情况。由于某列存在元素时，对应下标的行也一定有元素，因此我们仅需要定义一个行标志数组或者列标志数组就好了。</p><p>在对角线的表示问题上，可以通过表示截距来判断是否在同一对角线。如下图所示：</p><p><img src="/2021/05/19/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-52-%E2%80%94%E2%80%94-N-%E7%9A%87%E5%90%8EII-%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%9B%9B%EF%BC%89/2.png" alt></p><p>由于每个点都会代表两条对角线，因此我们需要思考一下如何映射对角线，在相同对角线上的点能够映射出来同一条对角线上即可。这里使用直线表达式的截距来进行表示。类似L1的对角线有9条，类似L2的对角线也有9条，即2n-1，我们初始化的时候直接初始化为2n即可。类似L1的表达式为 y = -x+k，类似L2的表达式为y = x+k。然后，为了保证我们创建的对角线截距数组的下标一致，又因为L2的截距是从-4到4，因此需要对其加上n，即y = x+k+n在本图中n为5，这样就保持其截距范围映射到了1到9，与L1的下标映射保持一致。</p><p>具体，请看代码。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; col, dg, udg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">        n = _n;</span><br><span class="line">        col = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n);</span><br><span class="line">        dg = udg = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="number">2</span> * n);</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>);<span class="comment">//由于仅仅需要考虑方案数，因此不需要记录结果答案。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == n) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//当遍历到了最后一行，则说明遍历完毕，就存在一种情况，所以返回1.</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[u - i + n] &amp;&amp; !udg[u + i]) &#123;</span><br><span class="line">              <span class="comment">//这里进行判断对角线方案。</span></span><br><span class="line">                col[i] = dg[u - i + n] = udg[u + i] = <span class="literal">true</span>;</span><br><span class="line">                res += dfs(u + <span class="number">1</span>);</span><br><span class="line">                col[i] = dg[u - i + n] = udg[u + i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 51 —— N 皇后 （一百四十三）</title>
      <link href="2021/05/18/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-51-%E2%80%94%E2%80%94-N-%E7%9A%87%E5%90%8E-%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>2021/05/18/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-51-%E2%80%94%E2%80%94-N-%E7%9A%87%E5%90%8E-%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p><img src="/2021/05/18/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-51-%E2%80%94%E2%80%94-N-%E7%9A%87%E5%90%8E-%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%B8%89%EF%BC%89/1.png" alt></p><p>输入：n = 4<br>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]<br>解释：如上图所示，4 皇后问题存在两个不同的解法。</p><p>示例 2：</p><p>输入：n = 1<br>输出：[[“Q”]]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、1 &lt;= n &lt;= 9<br>2、皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是n皇后问题，主要思路还是深度优先搜索。</p><p>这里，我们定义一些布尔数组来存放当前格子是否存在皇后，用于n皇后的规则判断，定义 vector<bool>row, col, dg,udg用来记录每一行、每一列、每条对角线和反对角线上是否有皇后存在。</bool></p><p>使用dfs搜索时需要使用4个参数来记录状态，分别是：当前遍历格子横坐标、当前格子纵坐标、整体已摆放的皇后个数、棋盘大小。<br>对于每步搜索，有两种选择：</p><p>1、当前格子不放皇后，则转移到 dfs(x, y + 1, s, n);<br>2、如果 (x,y) 所在的行、列、对角线不存在皇后，则当前格子可以摆放皇后，更新row, col, dg,udg后转移到 dfs(x, y + 1, s + 1, n)，回溯时不要忘记恢复row, col, dg, udg等状态。</p><p>时间复杂度分析：由于 n 个皇后不能在同行同列，所以每行恰有一个皇后，在不考虑对角线的情况下，方案数的上限：第一行有 n 个位置可选，第二行有 n−1 个位置可选，依次类推，可得方案数最多是 n!。所以时间复杂度是 O(n!)。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; col,dg,udg;<span class="comment">//用于存储列、对角线、反向对角线</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;<span class="comment">//用于存储答案</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;<span class="comment">//表示当前搜索的路径</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            整体思想就是n皇后的思想，即行、列、对角线不得有重复皇后。</span></span><br><span class="line"><span class="comment">            可以定义数组，对列的状态进行存储。对弈对角线，可以通过建立坐标轴映射的方式，把每个点映射到两条对角线上。可以用截距k来表示下标。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        n = _n;<span class="comment">//使用伪全局变量</span></span><br><span class="line">        col = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n);<span class="comment">//当前全部初始化为false</span></span><br><span class="line">        dg = udg = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n * <span class="number">2</span>);<span class="comment">//当前全部初始化为false</span></span><br><span class="line">        path = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(n,<span class="built_in">string</span>(n,<span class="string">&#x27;.&#x27;</span>));<span class="comment">//初始化当前最开始的棋盘</span></span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == n)&#123;</span><br><span class="line">            <span class="comment">//当搜完了之后，记录答案并返回</span></span><br><span class="line">            ans.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//枚举第u行的位置</span></span><br><span class="line">            <span class="keyword">if</span>(!col[i] &amp;&amp; !dg[u - i + n] &amp;&amp; !udg[u + i])&#123;</span><br><span class="line">                <span class="comment">//如果当前第i行没有被搜索过，且两条映射的对角线均没有皇后存在</span></span><br><span class="line">                col[i] = dg[u - i + n] = udg[u + i] = <span class="literal">true</span>;</span><br><span class="line">                path[u][i] = <span class="string">&#x27;Q&#x27;</span>;<span class="comment">//记录一下方案，即第u行第i个位置</span></span><br><span class="line">                dfs(u + <span class="number">1</span>);</span><br><span class="line">                path[u][i] = <span class="string">&#x27;.&#x27;</span>;<span class="comment">//恢复现场</span></span><br><span class="line">                col[i] = dg[u - i + n] = udg[u + i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 50 —— Pow(x, n)（一百四十二）</title>
      <link href="2021/05/17/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-50-%E2%80%94%E2%80%94-Pow-x-n-%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>2021/05/17/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-50-%E2%80%94%E2%80%94-Pow-x-n-%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，x^n）。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：x = 2.00000, n = 10<br>输出：1024.00000<br>示例 2：</p><p>输入：x = 2.10000, n = 3<br>输出：9.26100<br>示例 3：</p><p>输入：x = 2.00000, n = -2<br>输出：0.25000<br>解释：2-2 = 1/22 = 1/4 = 0.25</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、-100.0 &lt; x &lt; 100.0<br>2、-2^31 &lt;= n &lt;= 2^31-1<br>3、-10^4 &lt;= x^n &lt;= 10^4</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题考查快速幂算法或者叫反复平方法。基本思想如下：</p><p>求出x^n的n的二进制表示，用2的幂乘来表示n，最后求出。这样做，我们可以将本来要让x乘n次的情况，降低在30次左右(因为可以预处理<code>x^(2^0)</code>、···、<code>x^(2^30)</code>)。这里，给出一个例子，方便大家理解。</p><p>假设要求x^7，7的二进制表示为0111，则就是求<code>x^(2^0+2^1+2^2)</code>，然后把式子拆开的话就知道应该乘预处理的哪些项了。</p><p>这里，我们在实现的时候，需要注意一下，可以根据幂的二进制表示的1或0的情况，在预处理的时候，把结果同步处理。</p><p>若幂为负数，则res = 1/res。</p><p>具体，请看代码。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//快速幂，反复平方法</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">        <span class="keyword">bool</span> is_minus = n &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(LL k = <span class="built_in">abs</span>(LL(n)); k; k &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res *= x;<span class="comment">//枚举2进制的位，判断是1还是0，如果是1则乘起来，不是1则跳过。</span></span><br><span class="line">            x *= x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(is_minus) res = <span class="number">1</span>/res;<span class="comment">//判断是否是负数</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 49 —— 字母异位词分组 （一百四十一）</title>
      <link href="2021/05/15/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-49-%E2%80%94%E2%80%94-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84-%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>2021/05/15/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-49-%E2%80%94%E2%80%94-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84-%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、所有输入均为小写字母。<br>2、不考虑答案输出的顺序。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>由于题目中给出的单词都是小写字母，因此可以通过将其中的元素全部调整为按照某种规律排布的方式统一化就可以求出字母异位词了。</p><p>这里，我们将出现的单词均作出从小到大的排布处理。将排好序的字符串作为key，然后将原字符串插入key对应的vector<string>中。</string></p><p>这里我们可以采用hash表来进行映射存储。</p><p>时间复杂度分析：</p><p>假设N为字符串个数，L是每个单词的平均长度，hash表和vector插入操作的复杂度都是O(1)，排序复杂度是O(LlogL)，因此总的时间复杂度为：O(NLlogL)。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; dict;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;str : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> key = str;</span><br><span class="line">            sort(key.begin(), key.end());</span><br><span class="line">            dict[key].push_back(move(str));<span class="comment">//string存储字符串时内部有一个char*数组，那么在push_back时如果不使用move，那么会在vector的下一个位置新建一个char*数组，然后把原字符串复制过去；如果使用了move，那么vector的下一个位置里的char*就直接把原字符串的指针拿过来了，不需要复制整个字符串。这里就是为了减少依次拷贝操作。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = dict.begin(); i != dict.end(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(move(i -&gt; second));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 48 —— 旋转图像 （一百四十）</title>
      <link href="2021/05/15/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-48-%E2%80%94%E2%80%94-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%EF%BC%89/"/>
      <url>2021/05/15/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-48-%E2%80%94%E2%80%94-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p><img src="/2021/05/15/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-48-%E2%80%94%E2%80%94-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%EF%BC%89/1.png" alt></p><p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[7,4,1],[8,5,2],[9,6,3]]</p><p>示例 2：</p><p><img src="/2021/05/15/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-48-%E2%80%94%E2%80%94-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-%EF%BC%88%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%EF%BC%89/2.png" alt></p><p>输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br>输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p><p>示例 3：</p><p>输入：matrix = [[1]]<br>输出：[[1]]</p><p>示例 4：</p><p>输入：matrix = [[1,2],[3,4]]<br>输出：[[3,1],[4,2]]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>matrix.length == n<br>matrix[i].length == n<br>1 &lt;= n &lt;= 20<br>-1000 &lt;= matrix<code>[i][j]</code> &lt;= 1000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是一道经典的旋转矩阵的题，直接思考旋转90°会比较困难。我们可以将此拆分成两个步骤进行求解，即</p><p>1、按照左上-右下对角线进行翻转</p><p>2、再按照中轴竖线进行对称翻转</p><p>矩阵经过上述变形后与旋转90°的结果一致。</p><p>由于每一类旋转均按照行或者列，n次，因此一共的事件复杂度是O(n^2)，由于仅存在交换操作，因此每一次的交换操作需要存储一个临时变量，因此空间复杂度为O(1)。</p><p>具体，请看代码。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                swap(matrix[i][j],matrix[j][i]);<span class="comment">//对角线翻转</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>,k = n - <span class="number">1</span>; j &lt; k; j++,k-- )</span><br><span class="line">                swap(matrix[i][j],matrix[i][k]);<span class="comment">//中轴线翻转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 47 —— 全排列II （一百三十九）</title>
      <link href="2021/05/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-47-%E2%80%94%E2%80%94-%E5%85%A8%E6%8E%92%E5%88%97II-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
      <url>2021/05/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-47-%E2%80%94%E2%80%94-%E5%85%A8%E6%8E%92%E5%88%97II-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：nums = [1,1,2]<br>输出：<br>[[1,1,2],<br> [1,2,1],<br> [2,1,1]]</p><p>示例 2：</p><p>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、1 &lt;= nums.length &lt;= 8<br>2、-10 &lt;= nums[i] &lt;= 10</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题有两种考虑的方式，一种是考虑枚举每个位置可以填哪些数字，然后进行枚举；另一种是枚举每个数填到哪些位置上。这里说个题外话，若题目中给出字典序输出的要求时，尽量选择第一种考虑方式求解，这样可以尽量保证开头位置从小往大枚举。</p><p>回到本题，与上题的不同之处在于，其中内含相同元素，这样就存在枚举的全排列中可能会出现重复情况，因为上题的代码将所有的待选元素考虑为不同的元素，这里相同的元素也会考虑为不同的元素，因此需要思考如何避免这种情况就可以把这道题写出来了。</p><p>这里给出一个解决方案，即在每一次的排列中，保证相同的元素的相对位置保持不变即可。</p><p>比如：有3个相同的1，姑且认为是1’,1’’,1’’’,nums=[1,1,1,2],那么全排列如下：</p><p>ans = [[1’,1’’,1’’’,2],[1’,1’’,2,1’’’],[1’,2,1’’,1’’’],[2,1’,1’’,1’’’]]</p><p>我们仍然延续上一题的深度优先算法的思想，具体实现，请看代码解释。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; st;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//保证相同元素的相对顺序不变就可以。每次枚举第一个没有用过的相同的数字。</span></span><br><span class="line"></span><br><span class="line">        sort(nums.begin(),nums.end());<span class="comment">//为了将相同的元素放到一起</span></span><br><span class="line">        path = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.size());</span><br><span class="line">        st = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(nums.size());</span><br><span class="line"></span><br><span class="line">        dfs(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == nums.size())&#123;</span><br><span class="line">            ans.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//当该数没有被用过，且前一个数和本数相同，且保证前一个数已经用过，那么就可以使用这个数</span></span><br><span class="line">          <span class="keyword">if</span>(st[i] == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; st[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                path[u] = nums[i];</span><br><span class="line">                dfs(nums,u + <span class="number">1</span>);</span><br><span class="line">                st[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 46 —— 全排列 （一百三十八）</title>
      <link href="2021/05/12/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-46-%E2%80%94%E2%80%94-%E5%85%A8%E6%8E%92%E5%88%97-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E5%85%AB%EF%BC%89/"/>
      <url>2021/05/12/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-46-%E2%80%94%E2%80%94-%E5%85%A8%E6%8E%92%E5%88%97-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p><p>示例 2：</p><p>输入：nums = [0,1]<br>输出：[[0,1],[1,0]]</p><p>示例 3：</p><p>输入：nums = [1]<br>输出：[[1]]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、1 &lt;= nums.length &lt;= 6<br>2、-10 &lt;= nums[i] &lt;= 10<br>3、nums 中的所有整数 互不相同</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题可以使用深度优先搜索算法求解。</p><p>首先，从前往后，一位一位枚举，每次选择一个没有被使用过的数。<br>然后，将该数的状态改成“已被使用”，同时将该数记录在相应位置上，然后递归。</p><p>注意：递归返回时，需要将该数的状态改成“未被使用”，并将该数从相应位置上删除。因为在某一条路径（dfs）走到底往回走的时候，要把走过的印记擦除掉，如果不擦除的话，那么整个dfs就只会返回一条路径，从一个点往不同分支走的时候要保证不同分支相互之间没有影响才行，所以从每个分支退回来的时候需要把修改过的状态还原。</p><p>具体，请看代码实现。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;<span class="comment">//全局结果</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;<span class="comment">//路径</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; st;<span class="comment">//标志位，用于记录数字是否被使用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        path = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.size());<span class="comment">//初始化path</span></span><br><span class="line">        st = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(nums.size());<span class="comment">//初始化st</span></span><br><span class="line"></span><br><span class="line">        dfs(nums,<span class="number">0</span>);<span class="comment">//传递当前第几位</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//实现搜索算法，u代表当前枚举第几位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == nums.size())&#123;</span><br><span class="line">          <span class="comment">//如果u枚举到了最后一位，则说明搜索完毕，将答案记录到全局结果中，然后返回</span></span><br><span class="line">            ans.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//递归遍历求解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="literal">false</span>)&#123;</span><br><span class="line">              <span class="comment">//当某个数没有被使用时，当前位置采用该数，并将该数的标志修改为true，表示已经使用过，然后递归下一位。</span></span><br><span class="line">                path[u] = nums[i];</span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(nums,u + <span class="number">1</span>);</span><br><span class="line">                st[i] = <span class="literal">false</span>;<span class="comment">//要注意恢复现场，具体解释见题解中的注意事项</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 45 —— 跳跃游戏 II （一百三十七）</title>
      <link href="2021/05/11/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-45-%E2%80%94%E2%80%94-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>2021/05/11/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-45-%E2%80%94%E2%80%94-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>假设你总是可以到达数组的最后一个位置。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1:</p><p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p><p>示例 2:</p><p>输入: [2,3,0,1,4]<br>输出: 2</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1 &lt;= nums.length &lt;= 1000<br>0 &lt;= nums[i] &lt;= 10^5</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题使用动态规划+贪心算法求解。</p><p>首先，令f[i]为起点跳到i的最小步数，那么我们会发现f[i]是具有单调性的，也就是f[i + 1] &gt;= f[i]。用反证法：假设f[i + 1] &lt; f[i]，不妨设从k,(k &lt;= i)点跳到i + 1，即：k + nums[k] &gt;= i + 1，那么k + nums[k]也必然大于i，此时：f[i + 1] = f[i]。如果nums数组每一项都为1，则：f[i + 1] &gt; f[i]，综上：f[i + 1] &gt;= f[i]，与假设矛盾，因此f[i]具有单调递增性。</p><p>因此f[i]中的数值就会就变成类似：0 1…1 2…2 3…3 ……的情况，在动态规划时瓶颈就在于更新每个点的最小值时需要遍历所有能跳到i的点，而有了单调性以后就可以用第一个能跳到i的点更新了，因为无论是取哪一个点跳到i，其最终的结果是一样的，但是取第一个点和取最后一个点所需要的步数可能不相同，所以尽量选择靠前的点，这样步数就可能会减少，这就利用了贪心的思想。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j + nums[j] &lt; i)j++;</span><br><span class="line">            f[i] = f[j] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 44 —— 通配符匹配 （一百三十六）</title>
      <link href="2021/05/11/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-44-%E2%80%94%E2%80%94-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>2021/05/11/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-44-%E2%80%94%E2%80%94-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p><p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p><p>说明:</p><p>1、s 可能为空，且只包含从 a-z 的小写字母。<br>2、p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1:</p><p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p><p>示例 2:</p><p>输入:<br>s = “aa”<br>p = “<em>“<br>输出: true<br>解释: ‘</em>‘ 可以匹配任意字符串。</p><p>示例 3:</p><p>输入:<br>s = “cb”<br>p = “?a”<br>输出: false<br>解释: ‘?’ 可以匹配 ‘c’, 但第二个 ‘a’ 无法匹配 ‘b’。</p><p>示例 4:</p><p>输入:<br>s = “adceb”<br>p = “<em>a</em>b”<br>输出: true<br>解释: 第一个 ‘<em>‘ 可以匹配空字符串, 第二个 ‘</em>‘ 可以匹配字符串 “dce”.</p><p>示例 5:</p><p>输入:<br>s = “acdcb”<br>p = “a*c?b”<br>输出: false</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题和lc的第10题类似，仅在’*’号上变为了可以匹配任意多的字符串（包含空串）。本题在求解思路上，使用动态规划求解。</p><p>设置f[i,j]表示s[1到i]与p[1到j]是否匹配。有如下两种情况出现：</p><p>1、当p[j] 是’*’时，</p><p>考虑匹配多少个字符，这里参考一下第十题。<br>            匹配0个字符，f[i, j - 1]<br>            匹配1个字符，f[i - 1, j - 1]<br>            匹配2个字符，f[i - 2, j - 1]<br>            …<br>            匹配n个字符，f[i - n, j - 1]</p><p>由于本题与完全背包问题很类似，因此可以进行优化为：f[i,j] = f[i - 1,j] || f[i,j - 1]</p><p>2、当p[j] 不是’*’时，若匹配一定存在：s[i] == p[j] &amp;&amp; f[i - 1, j - 1]</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), m = p.size();</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s, p = <span class="string">&#x27; &#x27;</span> + p;<span class="comment">//DP问题为何减少特判问题，一般会将字符串下标从1开始。</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m + <span class="number">1</span>))</span></span>;<span class="comment">//定义状态数组</span></span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="comment">//第二个字符串一定从1开始，因为下标为0是一个空串，一定无法匹配</span></span><br><span class="line">                <span class="keyword">if</span>(p[j] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">1</span>] || (i &amp;&amp; f[i - <span class="number">1</span>][j]);<span class="comment">//特判i是否为0</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    f[i][j] = (p[j] == s[i] || p[j] == <span class="string">&#x27;?&#x27;</span>) &amp;&amp; (i &amp;&amp; f[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 43 —— 字符串相乘 （一百三十五）</title>
      <link href="2021/05/10/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-43-%E2%80%94%E2%80%94-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>2021/05/10/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-43-%E2%80%94%E2%80%94-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1:</p><p>输入: num1 = “2”, num2 = “3”<br>输出: “6”</p><p>示例 2:</p><p>输入: num1 = “123”, num2 = “456”<br>输出: “56088”</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、num1 和 num2 的长度小于110。<br>2、num1 和 num2 只包含数字 0-9。<br>3、num1 和 num2 均不以零开头，除非是数字 0 本身。<br>4、不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是高精度乘法的类型题中的一种。在求解本题时，可以回顾一种列竖式的方式求解，见下图：</p><p><img src="/2021/05/10/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-43-%E2%80%94%E2%80%94-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89/1.png" alt></p><p>每个位置的进位放置到最后处理，这样可以便于最后的计算求解。</p><p>这里，如果设A[i]和B[j]分别是num1和num2，C[k]为对应位置的乘积和，则A[i]与B[j]的乘积和应该加到C[i+j]中。</p><p>具体，请看代码注释</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//高精度乘法</span></span><br><span class="line">        <span class="keyword">int</span> n = num1.size(),m = num2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.push_back(num1[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//将其映射为逆序的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) B.push_back(num2[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">C</span><span class="params">(n + m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                C[i + j] += A[i] * B[j]; <span class="comment">//处理乘积，暂时忽略进位</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; C.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//t表示进位，这里将C[i]处理成最终的答案的逆序</span></span><br><span class="line">            t += C[i];</span><br><span class="line">            C[i] = t % <span class="number">10</span>; <span class="comment">//把个位数找出来,并赋值给C的对应位置</span></span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = C.size() - <span class="number">1</span>; <span class="comment">//k代表数字位数</span></span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; !C[k]) k--;<span class="comment">//将开头存在0的情况删除</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span>(k &gt;= <span class="number">0</span>) res += C[k--] + <span class="string">&#x27;0&#x27;</span>; <span class="comment">//将最后的结果再映射为字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 42 —— 接雨水 （一百三十四）</title>
      <link href="2021/05/08/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-42-%E2%80%94%E2%80%94-%E6%8E%A5%E9%9B%A8%E6%B0%B4-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>2021/05/08/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-42-%E2%80%94%E2%80%94-%E6%8E%A5%E9%9B%A8%E6%B0%B4-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p><img src="/2021/05/08/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-42-%E2%80%94%E2%80%94-%E6%8E%A5%E9%9B%A8%E6%B0%B4-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E5%9B%9B%EF%BC%89/1.png" alt></p><p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p><p>示例 2：</p><p>输入：height = [4,2,0,3,2,5]<br>输出：9</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、n == height.length<br>2、0 &lt;= n &lt;= 3 * 10^4<br>3、0 &lt;= height[i] &lt;= 10^5</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题的核心解题思想是单调栈的运用。</p><p>单调栈，即每次入栈的元素呈现单调的特点，要么是单调升，要么是单调减。</p><p>在本题中，我们可以考虑每个位置左边和右边的第一个比自身高的矩形条，以及三个矩形条构成的 U 型，这里就相当于对水的面积按行进行拆解。这里可以考虑维护一个严格单调递减的单调栈，具体操作如下：</p><p>当进栈的矩形高度小于等于栈顶举行高度时，将当前矩形压入栈中。当进栈的矩形高度大于当前栈顶矩形高度时，分别计算形成的U型中横向切割的每个小方形的长和宽，计算横向区域的方形凹槽面积，每次计算完就弹出当前栈顶元素，直到栈中的某个矩形的高度大于当前矩形高度，然后将该矩形压入栈中，继续刚才的判断，直到全部面积计算完毕。</p><p><img src="/2021/05/08/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-42-%E2%80%94%E2%80%94-%E6%8E%A5%E9%9B%A8%E6%B0%B4-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E5%9B%9B%EF%BC%89/2.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); i ++ ) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = <span class="number">0</span>;<span class="comment">//记录上一个柱子的高度</span></span><br><span class="line">            <span class="keyword">while</span> (stk.size() &amp;&amp; height[stk.top()] &lt;= height[i]) &#123;</span><br><span class="line">              <span class="comment">//当栈非空，且栈顶元素小于等于当前矩形高度时形成了U型的区域，就要计算对应可接雨水的面积。</span></span><br><span class="line">                res += (height[stk.top()] - last) * (i - stk.top() - <span class="number">1</span>);<span class="comment">//这里计算类似1、2、3、4区域的面积</span></span><br><span class="line">                last = height[stk.top()];</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stk.size()) res += (i - stk.top() - <span class="number">1</span>) * (height[i] - last);<span class="comment">//计算类似5区域的面积</span></span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 41 —— 缺失的第一个正数 （一百三十三）</title>
      <link href="2021/05/07/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-41-%E2%80%94%E2%80%94-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>2021/05/07/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-41-%E2%80%94%E2%80%94-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</p><p> 进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案吗？</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：nums = [1,2,0]<br>输出：3</p><p>示例 2：</p><p>输入：nums = [3,4,-1,1]<br>输出：2</p><p>示例 3：</p><p>输入：nums = [7,8,9,11,12]<br>输出：1</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、0 &lt;= nums.length &lt;= 300<br>2、-2^31 &lt;= nums[i] &lt;= 2^31 - 1</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题首先要理解题意，答案的范围一定在1到n-1(n = nums.size())之间。（这里请大家认真看示例以及认真思考一下，只有这里想明白了后面才知道咋做）</p><p>具体操作采用以下思路：</p><p>1、保证1出现在nums[0]的位置上，2出现在nums[1]的位置上，…，n出现在nums[n-1]的位置上，其他的非正整数以及大于n-1的数字不管。例如[3,4,-1,1]将被排序为[1,-1,3,4]<br>2、遍历nums，找到第一个不在应在位置上的1到n的数。例如，排序后的[1,-1,3,4]中第一个 nums[i] != i + 1 的是数字2（注意此时i=1）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;</span></span><br><span class="line"><span class="comment">//         //首先，映射hash表</span></span><br><span class="line"><span class="comment">//         //然后，再进行枚举</span></span><br><span class="line"><span class="comment">//         unordered_set&lt;int&gt; hash;//首先定义一个hash表</span></span><br><span class="line"><span class="comment">//         for(auto x: nums) hash.insert(x);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         int res = 1;</span></span><br><span class="line"><span class="comment">//         while(hash.count(res)) res++; //如果存在，res++</span></span><br><span class="line"><span class="comment">//         return res;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将nums中的数映射为下标，然后去看nums[i]是否等于i，如果不等于则返回i+1即可。</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x: nums )&#123;</span><br><span class="line">            <span class="keyword">if</span>(x != INT_MIN) x--; <span class="comment">//将数字映射为下标</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt;= <span class="number">0</span> &amp;&amp; nums[i] &lt; n &amp;&amp; nums[i] != i &amp;&amp; nums[i] != nums[nums[i]])</span><br><span class="line">                swap(nums[i], nums[nums[i]]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 40 —— 组合总和 II （一百三十二）</title>
      <link href="2021/05/06/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-40-%E2%80%94%E2%80%94-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>2021/05/06/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-40-%E2%80%94%E2%80%94-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。 </p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1:</p><p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]</p><p>示例 2:</p><p>输入: candidates = [2,5,2,1,2], target = 5,<br>所求解集为:<br>[<br>  [1,2,2],<br>  [5]<br>]</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题与上一题唯一的不同点在于，本题的每个元素的个数均有限制，不能无限次枚举给定数组中的元素。</p><p>首先，要求出每个元素一共可用多少次，由于给出的candidates不是有序的，我们可以进行排序，将其变为有序，这样，我们能够得出相同元素的个数，在上题求解的思路基础上加上个数的限制就可以得出本题的代码。</p><p>具体请看代码注释。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cs, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(cs.begin(),cs.end());<span class="comment">//排了序之后，相同元素排列在一起，这样就能够知道每个数能选几次。</span></span><br><span class="line">        dfs(cs,<span class="number">0</span>,target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cs, <span class="keyword">int</span> u, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">//说明找到了方案，把答案加入到答案数组中，返回</span></span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//没找到，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(u == cs.size()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = u + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; cs.size() &amp;&amp; cs[k] == cs[u]) k++;</span><br><span class="line">        <span class="keyword">int</span> cnt = k - u;<span class="comment">//求出当前枚举元素一共能用几个</span></span><br><span class="line"><span class="comment">//在循环的时候，添加可适用的元素个数限制即可。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; cs[u] * i &lt;= target &amp;&amp; i &lt;= cnt; i++)&#123;</span><br><span class="line">            dfs(cs, k, target - cs[u] * i);</span><br><span class="line">            path.push_back(cs[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; cs[u] * i &lt;= target &amp;&amp; i &lt;= cnt; i++)&#123;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 39 —— 组合总和 （一百三十一）</title>
      <link href="2021/05/05/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-39-%E2%80%94%E2%80%94-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>2021/05/05/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-39-%E2%80%94%E2%80%94-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><p>1、所有数字（包括 target）都是正整数。<br>2、解集不能包含重复的组合。 </p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：candidates = [2,3,6,7], target = 7,<br>所求解集为：<br>[<br>  [7],<br>  [2,2,3]<br>]</p><p>示例 2：</p><p>输入：candidates = [2,3,5], target = 8,<br>所求解集为：<br>[<br>  [2,2,2,2],<br>  [2,3,3],<br>  [3,5]<br>]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、1 &lt;= candidates.length &lt;= 30<br>2、1 &lt;= candidates[i] &lt;= 200<br>3、candidate 中的每个元素都是独一无二的。<br>4、1 &lt;= target &lt;= 500</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是一道求方案数量的题目，因此需要采用搜索算法。</p><p>这里采用深度优先算法，采用递归的实现方式求解。</p><p>在具体思路上，就类似于在空位中枚举数字，可见下图辅助思考。</p><p><img src="/2021/05/05/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-39-%E2%80%94%E2%80%94-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E4%B8%80%EF%BC%89/1.png" alt></p><p>具体请看代码注释。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;<span class="comment">//设置全局结果变量</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;<span class="comment">//设置全局搜索路径</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cs, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        dfs(cs, <span class="number">0</span>, target);<span class="comment">//建立深度优先搜索函数</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//cs为给出的数组，u代表当前到了数组的哪个数，target为给定的target</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cs, <span class="keyword">int</span> u,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(path); <span class="comment">//如果target被减到了0 说明目前找到了一组解，直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == cs.size()) <span class="keyword">return</span>;<span class="comment">//如果当前已经将整个cs遍历完，仍未得出解，直接返回。</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//枚举可能的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; cs[u] * i &lt;= target; i++)&#123;</span><br><span class="line">            dfs(cs, u + <span class="number">1</span>, target - cs[u] * i);</span><br><span class="line">            path.push_back(cs[u]);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//恢复现场</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; cs[u] * i &lt;= target; i++)&#123;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 38 —— 外观数列 （一百三十）</title>
      <link href="2021/05/04/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-38-%E2%80%94%E2%80%94-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%EF%BC%89/"/>
      <url>2021/05/04/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-38-%E2%80%94%E2%80%94-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个正整数 n ，输出外观数列的第 n 项。</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><p>你可以将其视作是由递归公式定义的数字字符串序列：</p><p>countAndSay(1) = “1”<br>countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。<br>前五项如下：</p><p>1</p><p>11</p><p>21</p><p>1211</p><p>111221</p><p>第一项是数字 1<br>描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 “11”<br>描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 “21”<br>描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 “1211”<br>描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 “111221”</p><p>要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</p><p>例如，数字字符串 “3322251” 的描述如下图：</p><p><img src="/2021/05/04/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-38-%E2%80%94%E2%80%94-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%EF%BC%89/1.png" alt></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：n = 1<br>输出：”1”<br>解释：这是一个基本样例。<br>示例 2：</p><p>输入：n = 4<br>输出：”1211”<br>解释：<br>countAndSay(1) = “1”<br>countAndSay(2) = 读 “1” = 一 个 1 = “11”<br>countAndSay(3) = 读 “11” = 二 个 1 = “21”<br>countAndSay(4) = 读 “21” = 一 个 2 + 一 个 1 = “12” + “11” = “1211”</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1 &lt;= n &lt;= 30</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题需要解释一下题目的意思，方便大家理解。这是一种脑筋急转弯的题目，对后面类型题基本没有什么太大的帮助，可以当做特例去做一做。</p><p>数字按顺序进行读取，然后首先描述数字的个数，然后再加上数字本身。下一次，再将之前组成的数字变成新的数字组合继续描述。就是找到规律即可。具体可以将每次的数字分成段去读。比如11223334，先读11，然后有21，也就是两个1；再读22，也就是2个2；依次类推。</p><p>具体实现看代码注释就好啦。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;1&quot;</span>;<span class="comment">//初始化字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">          <span class="comment">//求第n项也就是变换n-1次</span></span><br><span class="line">            <span class="built_in">string</span> t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.size();)&#123;</span><br><span class="line">                <span class="keyword">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//首先枚举前一项每一段相同的数</span></span><br><span class="line">                <span class="keyword">while</span>(k &lt; s.size() &amp;&amp; s[k] == s[j]) k++;</span><br><span class="line">                t += to_string(k - j) + s[j];</span><br><span class="line">                j = k;</span><br><span class="line">            &#125;</span><br><span class="line">            s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 37 —— 解数独 （一百一二十九）</title>
      <link href="2021/05/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-37-%E2%80%94%E2%80%94-%E8%A7%A3%E6%95%B0%E7%8B%AC-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
      <url>2021/05/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-37-%E2%80%94%E2%80%94-%E8%A7%A3%E6%95%B0%E7%8B%AC-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 遵循如下规则：</p><p>1、数字 1-9 在每一行只能出现一次。<br>2、数字 1-9 在每一列只能出现一次。<br>3、数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>4、数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例：</p><p><img src="/2021/05/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-37-%E2%80%94%E2%80%94-%E8%A7%A3%E6%95%B0%E7%8B%AC-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89/1.png" alt></p><p>输入：board = [[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]<br>输出：[[“5”,”3”,”4”,”6”,”7”,”8”,”9”,”1”,”2”],[“6”,”7”,”2”,”1”,”9”,”5”,”3”,”4”,”8”],[“1”,”9”,”8”,”3”,”4”,”2”,”5”,”6”,”7”],[“8”,”5”,”9”,”7”,”6”,”1”,”4”,”2”,”3”],[“4”,”2”,”6”,”8”,”5”,”3”,”7”,”9”,”1”],[“7”,”1”,”3”,”9”,”2”,”4”,”8”,”5”,”6”],[“9”,”6”,”1”,”5”,”3”,”7”,”2”,”8”,”4”],[“2”,”8”,”7”,”4”,”1”,”9”,”6”,”3”,”5”],[“3”,”4”,”5”,”2”,”8”,”6”,”1”,”7”,”9”]]<br>解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</p><p><img src="/2021/05/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-37-%E2%80%94%E2%80%94-%E8%A7%A3%E6%95%B0%E7%8B%AC-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89/2.png" alt></p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、board.length == 9<br>2、board[i].length == 9<br>3、board<code>[i][j]</code> 是一位数字或者 ‘.’<br>4、题目数据 保证 输入数独仅有一个解</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是采用深度优先算法，需要根据数独的规则，以递归的方式进行枚举并搜索答案。</p><p>需要注意的是如何能够迅速判断方格内在规则下还能够枚举哪些数字，这里进行一个说明：</p><p>因为数独中每行、每列、每个小方格都不允许重复，因此我们需要开布尔数组去记录每行、每列、每个小方格的变化情况。具体请看代码注释。</p><p>另外，在枚举每个小方格的坐标元素时，需要首先判断当前元素属于哪个小方格中。这里给出判断的公式：</p><p>在<code>[i/3][j/3]</code>的小方格中，看下图：</p><p><img src="/2021/05/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-37-%E2%80%94%E2%80%94-%E8%A7%A3%E6%95%B0%E7%8B%AC-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89/3.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> row[<span class="number">9</span>][<span class="number">9</span>], col[<span class="number">9</span>][<span class="number">9</span>], cell[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];<span class="comment">//行、列、小方格的布尔标志位</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">      <span class="comment">////每个布尔数组全部初始化为false</span></span><br><span class="line">        <span class="built_in">memset</span>(row, <span class="number">0</span>, <span class="keyword">sizeof</span> row); </span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="number">0</span>, <span class="keyword">sizeof</span> col);</span><br><span class="line">        <span class="built_in">memset</span>(cell, <span class="number">0</span>, <span class="keyword">sizeof</span> cell);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先，将目前存在的数字转化为下标，将下标对应的行、列、小方格中的布尔值更新为true。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    row[i][t] = col[j][t] = cell[i / <span class="number">3</span>][j / <span class="number">3</span>][t] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        dfs(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">9</span>) x ++, y = <span class="number">0</span>;<span class="comment">//越界后，需要从下一行开头开始。</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//遍历完成，返回true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (board[x][y] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> dfs(board, x, y + <span class="number">1</span>); <span class="comment">//说明有数，遍历下一个位置。</span></span><br><span class="line">        <span class="comment">//否则当前位置没有数字，就枚举当前的位置有哪些数。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++ )</span><br><span class="line">            <span class="comment">//数独的判断规则</span></span><br><span class="line">            <span class="keyword">if</span> (!row[x][i] &amp;&amp; !col[y][i] &amp;&amp; !cell[x / <span class="number">3</span>][y / <span class="number">3</span>][i]) &#123;</span><br><span class="line">                board[x][y] = <span class="string">&#x27;1&#x27;</span> + i;</span><br><span class="line">                row[x][i] = col[y][i] = cell[x / <span class="number">3</span>][y / <span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, x, y + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//if的判断中返回true，说明找到答案，返回true。</span></span><br><span class="line">                <span class="comment">//然后恢复现场</span></span><br><span class="line">                board[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                row[x][i] = col[y][i] = cell[x / <span class="number">3</span>][y / <span class="number">3</span>][i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 36 —— 有效的数独 （一百一二十八）</title>
      <link href="2021/05/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-36-%E2%80%94%E2%80%94-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89/"/>
      <url>2021/05/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-36-%E2%80%94%E2%80%94-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p><p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><p>注意：</p><p>1、一个有效的数独（部分已被填充）不一定是可解的。<br>2、只需要根据以上规则，验证已经填入的数字是否有效即可。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p><img src="/2021/05/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-36-%E2%80%94%E2%80%94-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89/1.png" alt></p><p>输入：board =<br>[[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”]<br>,[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”]<br>,[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”]<br>,[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”]<br>,[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”]<br>,[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”]<br>,[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”]<br>,[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”]<br>,[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]<br>输出：true</p><p>示例 2：</p><p>输入：board =<br>[[“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”]<br>,[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”]<br>,[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”]<br>,[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”]<br>,[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”]<br>,[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”]<br>,[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”]<br>,[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”]<br>,[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]<br>输出：false<br>解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、board.length == 9<br>2、board[i].length == 9<br>3、board<code>[i][j]</code> 是一位数字或者 ‘.’</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是根据规则，利用布尔数组进行判断，具体通过代码注释进行解释。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> st[<span class="number">9</span>];</span><br><span class="line">        <span class="comment">//判断行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);<span class="comment">//将每行的布尔数组初始化为false</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">              <span class="comment">//看每行是否存在重复</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                  <span class="comment">//如果当前位置不为空，用t表示当前位置的数，</span></span><br><span class="line">                    <span class="keyword">int</span> t = board[i][j] - <span class="string">&#x27;1&#x27;</span>; <span class="comment">//把字符的1-9改为下标的0-8，这样能够和布尔数组的下标保持一致。</span></span><br><span class="line">                    <span class="keyword">if</span>(st[t]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//当st[t]为true，则说明这个数之前已经出现过，那么直接返回false</span></span><br><span class="line">                    st[t] = <span class="literal">true</span>;<span class="comment">//将false修改为true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断列，与行的思路一致</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);<span class="comment">//将每行的布尔数组清空</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[j][i] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> t = board[j][i] - <span class="string">&#x27;1&#x27;</span>; <span class="comment">//把字符的1-9改为下标的0-8</span></span><br><span class="line">                    <span class="keyword">if</span>(st[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    st[t] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断小方格，因为每个小方格3x3，所以外层判断中步长为3.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i += <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j += <span class="number">3</span>)&#123;</span><br><span class="line">              <span class="comment">//每一次的小方格去遍历前，都会将st数组变为false</span></span><br><span class="line">                <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">              <span class="comment">//遍历每一个的小方格</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">3</span>; y++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[i + x][j + y] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                            <span class="keyword">int</span> t = board[i + x][j + y] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                            <span class="keyword">if</span>(st[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                            st[t] = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 35 —— 搜索插入位置 （一百一二十七）</title>
      <link href="2021/05/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-35-%E2%80%94%E2%80%94-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>2021/05/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-35-%E2%80%94%E2%80%94-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1:</p><p>输入: [1,3,5,6], 5<br>输出: 2</p><p>示例 2:</p><p>输入: [1,3,5,6], 2<br>输出: 1</p><p>示例 3:</p><p>输入: [1,3,5,6], 7<br>输出: 4</p><p>示例 4:</p><p>输入: [1,3,5,6], 0<br>输出: 0</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题在求解上思路很简单直接，就是使用二分算法，针对target，将区间分为两部分，求出下标。</p><p>这里需要强调一下边界情况，由于存在数组中的数全部小于target的情况，target的位置需要放置在数组末尾，因此右边界的下标范围需要设置为nums.size()。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 34 —— 在排序数组中查找元素的第一个和最后一个位置 （一百一二十六）</title>
      <link href="2021/04/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-34-%E2%80%94%E2%80%94-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>2021/04/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-34-%E2%80%94%E2%80%94-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：nums = [5,7,7,8,8,10], target = 8<br>输出：[3,4]</p><p>示例 2：</p><p>输入：nums = [5,7,7,8,8,10], target = 6<br>输出：[-1,-1]</p><p>示例 3：</p><p>输入：nums = [], target = 0<br>输出：[-1,-1]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、0 &lt;= nums.length &lt;= 10^5<br>2、-10^9 &lt;= nums[i] &lt;= 10^9<br>3、nums 是一个非递减数组<br>4、-10^9 &lt;= target &lt;= 10^9</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题也是一道二分求解的问题。</p><p>首先，因为数组是一个生序序列的数组，因此序列中如果存在target，一定都排列在一起。</p><p>同时，我们可以通过x是否大于等于target，利用二分将区间分为两段，将要求的区间的左端点找出来。</p><p>然后，我们可以通过x是否小于等于target，利用二分将区间分为两段，将要求的区间的右端点找出来。</p><p>当然，再求出左端点之后，要判断求得左端点的值与target是否一致，如果不一致，说明不存在target，直接返回{-1,-1}。存在再继续判断右端点的位置。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据x &gt;= target 可以得出二段性。本题需要求出左端点和右端点两个点的值，因此需要两次二分求出。</span></span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;  r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[r] != target) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> L = r;</span><br><span class="line">        l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> &#123;L,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 33 —— 搜索旋转排序数组 （一百一二十五）</title>
      <link href="2021/04/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-33-%E2%80%94%E2%80%94-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>2021/04/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-33-%E2%80%94%E2%80%94-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4</p><p>示例 2：</p><p>输入：nums = [4,5,6,7,0,1,2], target = 3<br>输出：-1</p><p>示例 3：</p><p>输入：nums = [1], target = 0<br>输出：-1</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、1 &lt;= nums.length &lt;= 5000<br>2、-10^4 &lt;= nums[i] &lt;= 10^4<br>3、nums 中的每个值都 独一无二<br>4、题目数据保证 nums 在预先未知的某个下标上进行了旋转<br>5、-10^4 &lt;= target &lt;= 10^4</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题在求解上也是采用二分的思想来做。可以先画个简图方便我们理解。</p><p><img src="/2021/04/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-33-%E2%80%94%E2%80%94-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/1.png" alt></p><p>然后，我们根据图，开始思考本题的思路</p><p>1、二分的基本思想就是某个分界点将区间分为两段，一个区间内满足某种性质，一个区间不满足，找出满足区间的那一段并更新为下一次求解的区间，在该区间内继续寻找分界点，重复上述操作，直到区间被更新为一个点或者左边界大于右边界时停止。</p><p>2、在本题中，我们需要找到target的下标。因此，针对本题来说，首先要找到两个区间的分界点，也就是k的下标，将两个旋转的区间分开，也是同样采用二分的方式，去判断区间的值与nums[0]的大小关系，一段区间均大于等于，一段均小于。这个查找完了之后，二分的左右端点相等，等于k。</p><p>3、然后我们要判断target在哪一段区间内。直接判断target与nums[k]的关系，确定target属于的区间范围，然后更新二分算法的左右端点。</p><p>3、判断出target在哪个区间之后，由于之后的区间不需要考虑旋转的问题，所以继续使用普通的二分做就可以了。本题主要是第一次的二分，需要特殊判断一下即可。</p><p>接下来，请看代码以及注释。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据遍历的x是否大于等于nums[0]来讲旋转的点找出来。</span></span><br><span class="line">        <span class="comment">//同样采用二分来做</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;<span class="comment">//初始化二分的左右边界</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">          <span class="comment">//求k</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//取区间中点。右移运算符移动一位，相当于/2</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//更新二分区间端点</span></span><br><span class="line">        <span class="keyword">if</span>(target &gt;= nums[<span class="number">0</span>]) l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> l = r + <span class="number">1</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//二分查找target</span></span><br><span class="line">        <span class="keyword">while</span>(l  &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(nums[r] == target) <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 32 —— 最长有效括号 （一百一二十四）</title>
      <link href="2021/04/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-32-%E2%80%94%E2%80%94-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>2021/04/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-32-%E2%80%94%E2%80%94-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7-%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：s = “(()”<br>输出：2<br>解释：最长有效括号子串是 “()”</p><p>示例 2：</p><p>输入：s = “)()())”<br>输出：4<br>解释：最长有效括号子串是 “()()”</p><p>示例 3：</p><p>输入：s = “”<br>输出：0</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、0 &lt;= s.length &lt;= 3 * 10^4<br>2、s[i] 为 ‘(‘ 或 ‘)’</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是lc第22题的类型题，考察括号匹配的问题。首先，把推论继续复习一下：</p><p>1、在任意有效的前缀中，左括号数量一定大于等于右括号数量</p><p>2、在整个有效的括号匹配区间中，左括号数量等于右括号数量</p><p>接下来，有如下思考。</p><p>1、首先，我们要理解一下所求的有效子串一定不会跨越两个区间。也就是说，当找到不符合有效规则的子串末尾字符位置的时候，前面的子串不可能与后面可能的有效子串拼接在一起。</p><p>2、基于1，我们可以知道，可以通过分段的思想考虑，即通过推论的两点规则，去判断当前的子串区间是否符合规则，如果符合规则，继续判断，直到不符合规则为止，记录当前子串的长度；如果不符合规则，那么从下一个位置重新开始寻找符合要求的子串，重复上述步骤。</p><p>3、每次找到子串就和已经找到的子串的最大子串长度进行比较，始终维护有效子串的全局最大值。最后返回最大值即可。</p><p>具体，请看代码。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分段的思想，要求的子串不可能存在跨越两个区间。</span></span><br><span class="line">        <span class="comment">//另外，为了能够有效匹配，一定有左右括号数量相等，任意前缀中，左括号数量大于等于右括号数量。</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, start = <span class="number">-1</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//用start描述当前字符的前一个位置</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) stk.push(i);<span class="comment">//如果当前字符是左括号，则压栈。</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stk.size())&#123; <span class="comment">//首先判断栈是否为空，不为空执行以下操作。</span></span><br><span class="line">                    stk.pop(); <span class="comment">//将栈头元素弹出</span></span><br><span class="line">                    <span class="keyword">if</span>(stk.size())&#123;</span><br><span class="line">                        res = max(res, i - stk.top()); <span class="comment">//根据推论，当前段的最大长度就是i到栈头元素的长度。然后求出全局最大。</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        res = max(res, i - start);<span class="comment">//因为栈空掉了  因此可以从头开始取</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    start = i;<span class="comment">//如果是右括号，则更新start。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 31 —— 下一个排列 （一百二十三）</title>
      <link href="2021/04/26/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-31-%E2%80%94%E2%80%94-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97-%EF%BC%88%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>2021/04/26/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-31-%E2%80%94%E2%80%94-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97-%EF%BC%88%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：nums = [1,2,3]<br>输出：[1,3,2]</p><p>示例 2：</p><p>输入：nums = [3,2,1]<br>输出：[1,2,3]</p><p>示例 3：</p><p>输入：nums = [1,1,5]<br>输出：[1,5,1]</p><p>示例 4：</p><p>输入：nums = [1]<br>输出：[1]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 100</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是一道求按照升序字典序排列的下一个排列的问题。我们有如下思考：</p><p>1、要尽量保持高位不变，尽量移动低位数字求解</p><p>2、如果nums从第k位开始到结尾是一个非升序的序列，那么可得出要移动的位置不在第k位开始到末尾的区间内，因为第k位的数字是这个区间内的最大值，在这个区间内用任意数字交换第k位的数都会变小。</p><p>3、具体思路是：从右开始找到nums的第一个非降序的位置，假设为第i位，然后从该位置往右找到一个比该数大的最小数，假设在第j位，然后交换nums[i]和nums[j]。然后，将第i位置后面的数重新进行升序排列即可。</p><p>4、注意如果第k位到了0，也就意味着nums整个是一个降序的序列，也就意味着nums的排列是字典序的最大。题目要求，如果给出的是字典序的最大排列，则返回字典序的最小排列，因此直接将nums倒序后返回即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从末尾往前遍历，找到第一个非降序的位置，然后从该位置往后找到一个比该数大的最小数，然后交换位置后，将后续的点从新排列为升序即可。</span></span><br><span class="line">        <span class="keyword">int</span> k = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; nums[k - <span class="number">1</span>] &gt;= nums[k]) k--;<span class="comment">//找到第一个非降序的位置</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            reverse(nums.begin(),nums.end());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> t = k;</span><br><span class="line">            <span class="keyword">while</span>(t &lt; nums.size() &amp;&amp; nums[t] &gt; nums[k - <span class="number">1</span>]) t++;</span><br><span class="line">            swap(nums[t - <span class="number">1</span>],nums[k - <span class="number">1</span>]);</span><br><span class="line">            reverse(nums.begin() + k, nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 30 —— 串联所有单词的子串（一百二十二）</title>
      <link href="2021/04/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-30-%E2%80%94%E2%80%94-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>2021/04/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-30-%E2%80%94%E2%80%94-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：<br>  s = “barfoothefoobarman”,<br>  words = [“foo”,”bar”]<br>输出：[0,9]<br>解释：<br>从索引 0 和 9 开始的子串分别是 “barfoo” 和 “foobar” 。<br>输出的顺序不重要, [9,0] 也是有效答案。</p><p>示例 2：</p><p>输入：<br>  s = “wordgoodgoodgoodbestword”,<br>  words = [“word”,”good”,”best”,”word”]<br>输出：[]</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是一个采用滑动窗口算法求解的题目。针对本题，有如下的思考过程：</p><p>1、单词的长度相同，因此方便我们能够简化对字符串遍历的方式。具体如下图：</p><p><img src="/2021/04/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-30-%E2%80%94%E2%80%94-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/1.png" alt></p><p>由于单词的长度全部一致，遍历时的起始位置直接按照w来划分。这样做的好处就是，如果存在符合题目要求的匹配，那么每个单词一定会恰好卡在我们划分的某一种情况中。</p><p>2、在上述分隔的情况下，问题可以转化为在给定的分隔情况下，找到其中符合题目的要求的连续的段的开始下标，然后重复上述操作，直到全部遍历完成即可。</p><p>3、在具体的算法操作中，为方便后续的操作，可以将给定的m(words.size())个单词存入hash表中，假设为tot。然后维护一个长度为m的滑动窗口，将滑动窗口中的元素也维护到hash表中，假设为wd。每次窗口向前移动时，删除最左边的旧元素，最右边增加一个新元素。</p><p>4、这里，我们用一个变量cnt维护wd中有多少个单词在给定的tot集合中出现过。具体来说两层含义：wd中如果出现tot中没有的单词，则cnt不会统计此单词数目；wd中出现tot中存在的单词，但其数量超过tot中出现的数量，则cnt不会计算超过的部分的单词数量。</p><p>5、在维护好cnt之后，可以直接使用cnt == tot.size()进行判断，如果一致，则认为发现了符合题目条件的连续部分，答案中记录对应起始位置；不一致则窗口继续滑动，直到结束。</p><p>具体，请看代码注释。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (words.empty()) <span class="keyword">return</span> res;<span class="comment">//判空</span></span><br><span class="line">        <span class="keyword">int</span> n = s.size(), m = words.size(), w = words[<span class="number">0</span>].size();<span class="comment">//n为字符串长度，m为单词的数量，w为单词的长度</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; tot;<span class="comment">//定义给定的单词的hash表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; word : words) tot[word] ++ ;<span class="comment">//枚举一下全部单词，相当于将单词映射到了tot这个hash表中</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w; i ++ ) &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; wd;<span class="comment">//定义每一组中的hash表，为滑动窗口服务。</span></span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">//枚举情况</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j + w &lt;= n; j += w) &#123;</span><br><span class="line">              <span class="comment">//枚举的长度要在字符串的长度以内，因此j+w &lt;=n</span></span><br><span class="line">              <span class="comment">//每次间隔长度为w，因此j += w</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= i + m * w) &#123;</span><br><span class="line">                  <span class="comment">//j代表的是从0到j的总长度，这里是判断窗口是否达到了最大，即m*w,i要加上是因为用总体长度和j判断才一致。</span></span><br><span class="line">                  <span class="comment">//在滑动窗口的大小达到最大时，要对左边的单词删除，对右边的单词增加。这里取出窗口最左边的单词</span></span><br><span class="line">                    <span class="keyword">auto</span> word = s.substr(j - m * w, w);</span><br><span class="line">                  <span class="comment">//将hash表中对应的部分--</span></span><br><span class="line">                    wd[word] -- ;</span><br><span class="line">                  <span class="comment">//如果wd对应单词数量减掉后，小于了tot中的对应单词的数量，说明减去了一个有效的单词，cnt需要--</span></span><br><span class="line">                    <span class="keyword">if</span> (wd[word] &lt; tot[word]) cnt -- ;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//找出右边新添加的单词</span></span><br><span class="line">                <span class="keyword">auto</span> word = s.substr(j, w);</span><br><span class="line">              <span class="comment">//对wd添加映射</span></span><br><span class="line">                wd[word] ++ ;</span><br><span class="line">              <span class="comment">//同理，如果为有效单词，则cnt++</span></span><br><span class="line">                <span class="keyword">if</span> (wd[word] &lt;= tot[word]) cnt ++ ;</span><br><span class="line">              <span class="comment">//判断是否cnt等于单词数量，满足则计算当前连续区间的起始位置，放入答案中。</span></span><br><span class="line">                <span class="keyword">if</span> (cnt == m) res.push_back(j - (m - <span class="number">1</span>) * w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 29 —— 两数相除（一百二十一）</title>
      <link href="2021/04/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-29-%E2%80%94%E2%80%94-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4%EF%BC%88%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>2021/04/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-29-%E2%80%94%E2%80%94-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4%EF%BC%88%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 dividend 除以除数 divisor 得到的商。</p><p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1:</p><p>输入: dividend = 10, divisor = 3<br>输出: 3<br>解释: 10/3 = truncate(3.33333..) = truncate(3) = 3</p><p>示例 2:</p><p>输入: dividend = 7, divisor = -3<br>输出: -2<br>解释: 7/-3 = truncate(-2.33333..) = -2</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、被除数和除数均为 32 位有符号整数。<br>2、除数不为 0。<br>3、假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是一道利用加减法实现除法运算。假设x/y=k，那么有如下思考：</p><p>1、若将k修改为二进制表示，假设为1101，那么，可得x = ky = ($2^3$+$2^2$+$2^0$)y。让我们思考一下，如果不用表示，x应该需要减掉k次y得到答案，但是如果将k使用二进制表示，x就可以减去logk次的y。又由于题目中有数值范围限制，因此最多x只会减去31次$2^n$y(0≤n≤31)，这样就将减去的次数调整为常数级别。</p><p>2、在判断x应该减去哪些$2^n$y的过程中就把商的二进制表示求出来了。具体可以这样思考：因为如果x/y&gt;$2^{30}$，就说明x&gt;$2^{30}$y，因此商二进制表示的第30位为1，也就表示x就需要减去$2^{30}$y；当然，如果x/y&gt;$2^{30}$，说明x&lt;$2^{30}$y，因此x就不需要减去该项，商的二进制表示的第30位就为0。上述这种判断直到把全部应该减去的$2^n$y部分剪完，也就求出来k的二进制表示了，然后再进一步求出k的十进制的值即可。</p><p>3、本题中涉及到的乘法要使用加法代替，涉及到的除法要使用减法代替</p><p>具体，请看代码注释</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;<span class="comment">//首先，因为两个整数相除存在溢出的问题，比如-2^31 / -1 = 2^31，超过整型最大值。因此采用long long类型避免了程序报错。如果题目不让，再进行判断处理。</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;LL&gt; <span class="built_in">exp</span>;<span class="comment">//定义y*2^n的值的数组</span></span><br><span class="line">        <span class="keyword">bool</span> is_minus = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> || x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) is_minus = <span class="literal">true</span>;<span class="comment">//判断正负号标志</span></span><br><span class="line"></span><br><span class="line">        LL a = <span class="built_in">abs</span>((LL)x), b = <span class="built_in">abs</span>((LL)y);<span class="comment">//全部强制类型转化为long long型</span></span><br><span class="line">        <span class="keyword">for</span> (LL i = b; i &lt;= a; i = i + i) <span class="built_in">exp</span>.push_back(i);<span class="comment">//将y*2^n的值计算出来</span></span><br><span class="line"></span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">exp</span>.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">          <span class="comment">//如果a也就是x  大于 对应的y*2^n，就减掉，然后商的第i位为1，直接使用左移运算符，计算出2的^i次方</span></span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="built_in">exp</span>[i]) &#123;</span><br><span class="line">                a -= <span class="built_in">exp</span>[i];</span><br><span class="line">                res += <span class="number">1l</span>l &lt;&lt; i;<span class="comment">//通过找出商的二进制表示，这里直接求出res的十进制的值。每找到某位为1，直接求出对应2的i次方的值，然后全部相加得出</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_minus) res = -res;<span class="comment">//如果除数或者被除数有负数，则商一定为负</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &gt; INT_MAX || res &lt; INT_MIN) res = INT_MAX;<span class="comment">//这里判断溢出，即大于最大int值或者小于最小int值，返回题目要求的最大int值。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 28 —— 实现 strStr()（一百二十）</title>
      <link href="2021/04/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-28-%E2%80%94%E2%80%94-%E5%AE%9E%E7%8E%B0-strStr-%EF%BC%88%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%EF%BC%89/"/>
      <url>2021/04/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-28-%E2%80%94%E2%80%94-%E5%AE%9E%E7%8E%B0-strStr-%EF%BC%88%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>实现 strStr() 函数。</p><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><p>说明：</p><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：haystack = “hello”, needle = “ll”<br>输出：2</p><p>示例 2：</p><p>输入：haystack = “aaaaa”, needle = “bba”<br>输出：-1</p><p>示例 3：</p><p>输入：haystack = “”, needle = “”<br>输出：0</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>0 &lt;= haystack.length, needle.length &lt;= 5 * 10^4<br>haystack 和 needle 仅由小写英文字符组成</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题有两种求解的方式，第一种是暴力求解，第二种为KMP算法（Knuth-Morris-Pratt字符串查找算法）的应用。</p><p>我将原题中的haystack数组名改为了s，needle改为了p，这样写代码比较方便简单，以下用s和p代替。</p><p>第一种暴力求解算法实现很简单，即为两重循环，外层循环s，内层循环p，找出匹配过程中的最大长度即可。这个思路很容易理解，也是所有人都能想到的，但是时间复杂度为O(nm)，有些大，如果题目中给出的数据范围过大，可能会出现超时的情况。</p><p>第二种为KMP算法，时间复杂度为O(n+m)。</p><p>首先，KMP算法一般将字符串下标调整为1开始比较好处理，所以，可以将题目中给出的下标前面添加空字符或者其他任意字符，让s和p的真正字符串起始下标+1。</p><p>接下来，按照如下操作步骤操作即可得出结论：</p><p>1、定义一个next数组，记为next[j]，意思是所有p[1-j]中非平凡（不包括p这个字符串本身）的相等的前缀与后缀的长度的最大值记录一个next[j]。这里的前缀和后缀表示：从下标1开始的前缀和以j为结尾的后缀。</p><p>2、在构造出next数组后，找出一个最大值即为答案。</p><p>这里做一个一般性的推演，来辅助理解next数组对求解的意义。</p><p><img src="/2021/04/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-28-%E2%80%94%E2%80%94-%E5%AE%9E%E7%8E%B0-strStr-%EF%BC%88%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%EF%BC%89/1.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//int strStr(string s, string needle) &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//KMP算法。一般习惯下标为1开始比较好处理。</span></span><br><span class="line">        <span class="comment">//next[i]:所有p[1-i]中的相等的前缀和后缀的长度的最大值</span></span><br><span class="line">        <span class="keyword">if</span>(p.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = s.size(), m = p.size();</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s, p = <span class="string">&#x27; &#x27;</span> + p;<span class="comment">//将字符串长度+1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(m + <span class="number">1</span>)</span></span>;<span class="comment">//定义一个next数组，且长度为m+1，因为p字符串的长度增加了1.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//求的时候i从2开始，因为next[1]=0.（始终记住，真正字符串的下标从1开始，所以next[1]=0）</span></span><br><span class="line">        <span class="comment">//本循环是求next数组的过程，因此也就是要找到p的每个位置上的对应前缀和后缀的最大值，因此分析过程与上图推演的类似，只是把s串换为p即可。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">          <span class="comment">//当j不为0时且p的第i位与p的j+1不匹配时，j就更新为next[j]。因为next[j]就是以j位置的下一次的最大匹配的位置，也就是满足p的前缀后缀相等的最大长度的下一个匹配的j的坐标。</span></span><br><span class="line">            <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++;<span class="comment">//说明匹配，j就往后移动继续匹配</span></span><br><span class="line">            next[i] = j;<span class="comment">//这里是找出了最大匹配的长度也就是j</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里是s和p串的匹配过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="comment">//当j不为0.且s的i位置与p的j+1位置不匹配，j进行更新。</span></span><br><span class="line">            <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="comment">//如果匹配，j++</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="comment">//当第一次匹配全部的p，返回当前的下标即(i-m+1)-1。这个括号后面的-1是因为开始我们将字符串本身的长度增加了1噢，所以要减掉。</span></span><br><span class="line">            <span class="keyword">if</span>(j == m) <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没找到，则返回-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 27 —— 移除元素（一百一十九）</title>
      <link href="2021/04/22/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-27-%E2%80%94%E2%80%94-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
      <url>2021/04/22/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-27-%E2%80%94%E2%80%94-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：nums = [3,2,2,3], val = 3<br>输出：2, nums = [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</p><p>示例 2：</p><p>输入：nums = [0,1,2,2,3,0,4,2], val = 2<br>输出：5, nums = [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>0 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 50<br>0 &lt;= val &lt;= 100</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题与上题的解题思路类似，可以采用类似双指针的算法进行考虑。具体思考如下：</p><p>1、两个指针指向开头，假设为i和k，其中i指针用于判断当前数组的值，k指针用于记录数组的长度。</p><p>2、首先取nums[i]与删除的目标值进行判断，如果不同，i++，k++；如果相同，i++，继续判断后面的值是否与目标值相同，如果不同，则将该值赋给k指向的元素，然后k++</p><p>3、重复第二步，直到i将数组遍历完，返回k即为删除目标元素后的数组长度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//与上题思路一致。</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != val) nums[k++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 26 —— 删除有序数组中的重复项（一百一十八）</title>
      <link href="2021/04/21/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-26-%E2%80%94%E2%80%94-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E5%85%AB%EF%BC%89/"/>
      <url>2021/04/21/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-26-%E2%80%94%E2%80%94-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：nums = [1,1,2]<br>输出：2, nums = [1,2]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</p><p>示例 2：</p><p>输入：nums = [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums = [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>0 &lt;= nums.length &lt;= 3 * 10^4<br>-10^4 &lt;= nums[i] &lt;= 10^4<br>nums 已按升序排列</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>根据题目要求，原地的意思就是不能开数组，不要写递归，用的空间必须是常数级别。</p><p>本题可以采用双指针算法来求解。</p><p>具体就是，一个指针用于遍历数组，一个指针用于将前面的重复元素修改为后面不同的元素。最终得出长度。这样做的原因是因为数组有序，相同的元素一定挨着，因此只需要比较两两之间的元素值是否相同，如果相同则跳过，直到找到不一样的元素后，长度+1，然后更新当前判断的值，继续寻找，直到把链表遍历完毕。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!i || nums[i] != nums[i - <span class="number">1</span>]) nums[k++] = nums[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 25 —— K 个一组翻转链表（一百一十七）</title>
      <link href="2021/04/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-25-%E2%80%94%E2%80%94-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>2021/04/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-25-%E2%80%94%E2%80%94-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>进阶：</p><p>1、你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br>2、你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p><img src="/2021/04/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-25-%E2%80%94%E2%80%94-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%83%EF%BC%89/1.png" alt></p><p>输入：head = [1,2,3,4,5], k = 2<br>输出：[2,1,4,3,5]</p><p>示例 2：</p><p><img src="/2021/04/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-25-%E2%80%94%E2%80%94-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%83%EF%BC%89/2.png" alt></p><p>输入：head = [1,2,3,4,5], k = 3<br>输出：[3,2,1,4,5]</p><p>示例 3：</p><p>输入：head = [1,2,3,4,5], k = 1<br>输出：[1,2,3,4,5]</p><p>示例 4：</p><p>输入：head = [1], k = 1<br>输出：[1]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>列表中节点的数量在范围 sz 内<br>1 &lt;= sz &lt;= 5000<br>0 &lt;= Node.val &lt;= 1000<br>1 &lt;= k &lt;= sz</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题延续之前上题的思路。</p><p>首先需要遍历一次链表，观察给出的用例是否大于k个，只有大于k个才存在翻转的必要。在保证大于k的前提下，我们有如下三个操作。</p><p>1、内部元素的反向操作</p><p><img src="/2021/04/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-25-%E2%80%94%E2%80%94-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%83%EF%BC%89/3.png" alt></p><p>2、虚拟头结点指向第k个节点的操作</p><p><img src="/2021/04/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-25-%E2%80%94%E2%80%94-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%83%EF%BC%89/4.png" alt></p><p>3、原来的实际头结点指向第k个结点的下一个结点的操作</p><p><img src="/2021/04/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-25-%E2%80%94%E2%80%94-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%83%EF%BC%89/5.png" alt></p><p>Tips：图中虚线是用于临时指向的指针，防止我们找不到该节点。</p><p>然后，每k个元素来一次上述操作，直到将全部链表遍历完毕。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//本题首先，需要先遍历一下链表，看其长度是否达到了k个要求。</span></span><br><span class="line">        <span class="comment">//如果达到k的要求，需要进行翻转操作。一共操作分三个部分</span></span><br><span class="line">        <span class="comment">//第一个部分，将内部元素的反向</span></span><br><span class="line">        <span class="comment">//第二个部分，将开头元素指向第k个节点元素</span></span><br><span class="line">        <span class="comment">//第三个部分，将k链表的头节点指向k节点元素的next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        dummy -&gt; next = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = dummy;;)&#123;</span><br><span class="line">            <span class="keyword">auto</span> q = p;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; q; i++) q = q -&gt; next;</span><br><span class="line">            <span class="keyword">if</span>(!q) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//定义两个节点，最开始节点a指向第一个元素，节点b指向第二个元素</span></span><br><span class="line">            <span class="keyword">auto</span> a =  p -&gt; next, b = a -&gt; next;</span><br><span class="line">            <span class="comment">//这个for循环对k个几点的内部的边进行反向操作</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> c = b -&gt; next; <span class="comment">//首先存储一下b的下一个节点，否则下面覆盖掉就找不到了</span></span><br><span class="line">                b -&gt; next = a;<span class="comment">//翻转方向</span></span><br><span class="line">                a = b, b = c; <span class="comment">//a到b的位置，b到c的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> d = p -&gt; next;</span><br><span class="line">            p -&gt; next = a;</span><br><span class="line">            d -&gt; next = b; </span><br><span class="line">            p = d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 24 —— 两两交换链表中的节点（一百一十六）</title>
      <link href="2021/04/19/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-24-%E2%80%94%E2%80%94-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>2021/04/19/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-24-%E2%80%94%E2%80%94-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p><img src="/2021/04/19/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-24-%E2%80%94%E2%80%94-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E5%85%AD%EF%BC%89/1.png" alt></p><p>输入：head = [1,2,3,4]<br>输出：[2,1,4,3]</p><p>示例 2：</p><p>输入：head = []<br>输出：[]</p><p>示例 3：</p><p>输入：head = [1]<br>输出：[1]</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h3><p>链表中节点的数目在范围 [0, 100] 内<br>0 &lt;= Node.val &lt;= 100</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是一道链表题，通过画图实现两个节点的交换过程，然后通过代码实现即可。这里注意如果链表结点数为偶数，则两两交换即可，如果链表结点数为奇数，则最后一个落单元素不用管。</p><p>大致过程如下：</p><p><img src="/2021/04/19/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-24-%E2%80%94%E2%80%94-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E5%85%AD%EF%BC%89/2.png" alt></p><p>由于本题是单链表，因此在实现的过程中，除了指向两个要交换的结点的指针外，还需要一个额外指针指向一对结点的前一个指针，保证交换后链表结构完整。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这是一个节点交换的问题。可以通过画图，将过程明晰后直接写代码。</span></span><br><span class="line">        <span class="comment">//这里需要注意一个问题，就是如果节点个数为奇数，则最后一个未匹配的单节点可以不用交换。</span></span><br><span class="line">        <span class="comment">//还有就是，虚拟头结点在每次链表的两个节点交换位置后往后移动两位。</span></span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        dummy -&gt; next =  head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = dummy; p -&gt; next &amp;&amp; p -&gt; next -&gt; next;)&#123;</span><br><span class="line">            <span class="keyword">auto</span> a = p -&gt; next, b = p -&gt; next -&gt; next; <span class="comment">//找到要交换的两个点</span></span><br><span class="line">            p -&gt; next = b;</span><br><span class="line">            a -&gt; next = b -&gt; next;</span><br><span class="line">            b -&gt; next = a;</span><br><span class="line">            p = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 23 —— 合并k个有序链表（一百一十五）</title>
      <link href="2021/04/18/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-23-%E2%80%94%E2%80%94-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>2021/04/18/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-23-%E2%80%94%E2%80%94-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p><p>示例 2：</p><p>输入：lists = []<br>输出：[]</p><p>示例 3：</p><p>输入：lists = [[]]<br>输出：[]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>k == lists.length<br>0 &lt;= k &lt;= 10^4<br>0 &lt;= lists[i].length &lt;= 500<br>-10^4 &lt;= lists[i][j] &lt;= 10^4<br>lists[i] 按 升序 排列<br>lists[i].length 的总和不超过 10^4</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题求解思路主要是基于二维链表的求解思路，每次遍历全部链表上对应的指针，求出全局最小值，将该节点接入新链表中，然后直到循环结束。因为链表有序，因此采用指针算法没有任何问题。</p><p>这里需要注意两个问题</p><p>1、有关求全局最小值的操作优化：使用小根堆的数据结构。具体解释如下：</p><p>小根堆，是一种父节点的值小于或等于其下方所有子节点的值的数据结构。我们将每个链表的指针节点存储到堆的数据结构中，每次取出顶点元素节点，时间复杂度为O(1)，然后将对应最小指针的next节点添加到堆中，由于我们是小根堆，因此堆需要重新排序，若假设总链表个数为k，则时间复杂度为O(logk)。因此，总体的事件复杂度为O(nlogk)。</p><p>2、对C++语言特性的运用即：STL容器以及仿函数的运用。具体解释如下：</p><p>在C++中，我们通常会采用STL容器来实现数据结构中的操作，比如vector容器、stack栈模型、queue队列模型、list链表模型、priotriy_queue优先级队列模型等等。在本题中，就是使用priotriy_queue优先队列模型，其具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的，因此我们使用此容器来当成一个堆的数据结构。</p><p>同时，由于该容器默认为大根堆，因此需要对其内部的比较规则进行重新修改，这里采用仿函数的机制进行。</p><p>仿函数，通俗点来说就是使一个类的使用看上去像一个函数，其实现就是类中实现一个operator()方法，这个类就有了类似函数的行为，就是一个仿函数类。在实现上，可以在C++中的结构体中重载一个operator()方法实现自定义比较，然后将该结构体在堆的定义上，当做参数传入即可，具体实现请看代码。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里需要自定义一个比较函数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Cmp</span>&#123;</span></span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(ListNode* a, ListNode* b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a -&gt; val &gt; b -&gt; val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            思路与双指针类似。也是在每个链表中添加一个指针，然后循环求出全局最小值，然后重复上述操作得出最终的归并后的有序链表。</span></span><br><span class="line"><span class="comment">            但是，求出全部指针中的最小值，不仅可以用循环的方式做，也可以用堆这种数据结构来做。假设所有链表的总长度为n，链表个数为k</span></span><br><span class="line"><span class="comment">            那么通过循环的方法的时间复杂度是nk，采用堆的数据结构的话的时间复杂度是nlogk</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, Cmp&gt; heap; <span class="comment">//这里定义的话，如果不传入vector&lt;ListNode*&gt;以及一个比较函数Cmp，堆会按照地址的大小进行排序，显然不是我们所希望的。同时，Cmp这个函数需要定义一个结构体，重载操作符并返回值的大小判断。</span></span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), tail = dummy; <span class="comment">//定义虚拟头结点，并定义一个新链表的尾结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> l : lists) <span class="keyword">if</span>(l) heap.push(l); <span class="comment">//将空链表去掉</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当堆里面有元素的时候，进行循环</span></span><br><span class="line">        <span class="keyword">while</span>(heap.size())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = heap.top(); <span class="comment">//取出对顶元素，即为全局最小值</span></span><br><span class="line">            heap.pop(); <span class="comment">//将堆顶元素弹出</span></span><br><span class="line"></span><br><span class="line">            tail = tail -&gt; next = t;<span class="comment">//将最小值插入并且将尾结点更新</span></span><br><span class="line">            <span class="keyword">if</span>(t -&gt; next) heap.push(t -&gt; next);<span class="comment">//如果t有下一个节点，那么把下一个节点添加到堆中，相当于把指针向前移动一位。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 22 —— 括号生成（一百一十四）</title>
      <link href="2021/04/17/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-22-%E2%80%94%E2%80%94-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>2021/04/17/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-22-%E2%80%94%E2%80%94-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：n = 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p><p>示例 2：</p><p>输入：n = 1<br>输出：[“()”]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1 &lt;= n &lt;= 8</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>这个题比较特殊，一般的求解思路在这里都会比较麻烦。这里破题的点在于思考括号生成的条件，这里给出来，大家以后记住就好。推论如下：</p><p>在假设括号类型相同的情况下有：</p><p>1、任意字符串前缀，左括号数量一定大于等于右括号数量</p><p>2、从整体来看，左右括号数量一定相等</p><p>本题需要根据以上信息，进行求解。</p><p>因为是一种搜索生成有效的括号的实例，所以我们可以采用最常见的深度优先遍历搜索算法，以递归的实现方式来求解题目。</p><p>在实现dfs函数中，需要传入的变量有：题目中给出的括号对数n、当前搜索中左括号的数量lc、当前搜索中右括号的数量rc，以及当前搜索的括号字符串结果seq。</p><p>具体，请看代码实现以及注释即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在什么情况下n个左括号和n个右括号构成的序列是合法的，存在一个推论,如下。（这里要求括号类型要相同）</span></span><br><span class="line"><span class="comment">                1、任意前缀中，左括号数量大于等于右括号数量</span></span><br><span class="line"><span class="comment">                2、左右括号数量相等</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            在本题中，根据以上信息，利用深度优先算法，使用递归的思想来求解。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        dfs(n,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n代表括号对数，lc代表目前seq中左括号的数量，rc代表目前seq中右括号的数量，seq代表当前的括号字符串结果。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> lc, <span class="keyword">int</span> rc, <span class="built_in">string</span> seq)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当左括号和右括号的数量均为n时，代表结束，产生的结果应放入结果中</span></span><br><span class="line">        <span class="keyword">if</span>(lc == n &amp;&amp; rc == n) res.push_back(seq);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当左括号没有达到n的数量时，就可以增加</span></span><br><span class="line">            <span class="keyword">if</span>(lc &lt; n) dfs(n,lc + <span class="number">1</span>, rc, seq+<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="comment">//当右括号没有达到n的数量时，左括号的数量必须严格大于右括号的数量的情况下才可以添加右括号，因为如果加上相等的条件，可能会造成前缀中，右括号的数量大于左括号的数量，条件会不满足！</span></span><br><span class="line">            <span class="keyword">if</span>(rc &lt; n &amp;&amp; lc &gt; rc) dfs(n, lc, rc + <span class="number">1</span>, seq + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 21 —— 合并两个有序链表（一百一十三）</title>
      <link href="2021/04/16/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-21-%E2%80%94%E2%80%94-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>2021/04/16/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-21-%E2%80%94%E2%80%94-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p><img src="/2021/04/16/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-21-%E2%80%94%E2%80%94-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%89%EF%BC%89/1.png" alt></p><p>输入：l1 = [1,2,4], l2 = [1,3,4]<br>输出：[1,1,2,3,4,4]</p><p>示例 2：</p><p>输入：l1 = [], l2 = []<br>输出：[]</p><p>示例 3：</p><p>输入：l1 = [], l2 = [0]<br>输出：[0]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>两个链表的节点数目范围是 [0, 50]<br>-100 &lt;= Node.val &lt;= 100<br>l1 和 l2 均按 非递减顺序 排列</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是一个经典链表题目，主要思想为双指针算法。</p><p>因为两个链表有序，因此双指针算法的应用条件已经成熟，我们有如下思考：</p><p>1、链表题，一般都需要虚拟头结点来作为辅助。由于我们不需要在原有链表上进行增删改的操作，因此虚拟头结点用于指向合并后的新链表的头结点，这样我们可以用虚拟头结点用于返回结果，即return dummy-&gt;next。</p><p>2、定义两个指针，分别指向两个链表的头结点，并开始进行比较。由于虚拟头结点的作用是标记链表的入口，即标记链表的实际头结点，因此虚拟头结点是不可以进行更新和赋值的操作的，所以，我们可以再定义一个尾结点，让尾结点进行合并和更新的操作，所以就可以使用auto  tail = dummy。</p><p>3、当某个链表遍历完毕之后，如果剩余链表仍然存在未遍历的情况，由于链表有序，那么可以证明剩余链表的各个结点数值一定大于等于合并链表的尾结点的数值，那么将tail的next指针指向剩余链表的开始结点即可。</p><p>4、最后返回虚拟头结点的next指针。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>); <span class="comment">//定义一个虚拟头结点</span></span><br><span class="line">        <span class="keyword">auto</span> tail = dummy; <span class="comment">//定义一个新的链表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 -&gt; val &gt; l2 -&gt; val)&#123;</span><br><span class="line">                tail -&gt; next = l2;</span><br><span class="line">                tail = tail -&gt; next;</span><br><span class="line">                l2 = l2 -&gt; next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tail -&gt; next = l1;</span><br><span class="line">                tail = tail -&gt; next;</span><br><span class="line">                l1 = l1 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">            tail -&gt; next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">            tail -&gt; next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 20 —— 有效的括号（一百一十二）</title>
      <link href="2021/04/15/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-20-%E2%80%94%E2%80%94-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>2021/04/15/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-20-%E2%80%94%E2%80%94-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：s = “()”<br>输出：true</p><p>示例 2：</p><p>输入：s = “()[]{}”<br>输出：true</p><p>示例 3：</p><p>输入：s = “(]”<br>输出：false</p><p>示例 4：</p><p>输入：s = “([)]”<br>输出：false</p><p>示例 5：</p><p>输入：s = “{[]}”<br>输出：true</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1 &lt;= s.length &lt;= $10^4$<br>s 仅由括号 ‘()[]{}’ 组成</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>求解匹配问题，一般需要用到一种特殊的数据结构，那就是栈。栈的特性是先进后出，在括号匹配问题上，同样符合这个性质，也就是，后面的左括号要率先被匹配掉，不然不符合规则。因此，我们有如下思考：</p><p>1、我们要利用栈，将左括号压入栈中。右括号用于在字符串遍历到时，和当前栈顶的元素进行匹配。如果匹配成功，则将栈顶元素弹出，继续匹配；如果匹配不成功，则直接返回false</p><p>2、在将字符串遍历完之后，要记得查看栈中是否还有元素，如果有，说明存在左括号没有右括号匹配的情况，此时也需要返回false</p><p>3、在编码技巧上，由于 ‘{‘ 和 ‘}’ 以及 ‘(‘ 和 ‘)’ 的ASCII码值差1， ‘[‘ 和 ‘]’ 的ASCII码值相差2，因此还可以通过这个特性简化代码。即判断差值是否小于等于2即可。因为，如果是不同类型的括号，差值一定大于2，相同类型的括号，差值一定在2以内。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                stk.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stk.size() &amp;&amp; <span class="built_in">abs</span>(stk.top() - c) &lt;= <span class="number">2</span>) stk.pop();<span class="comment">//根据ascii码来进行判断。如果匹配，差值一定小于等于2</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stk.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 19 —— 删除链表的倒数第N个节点（一百一十一）</title>
      <link href="2021/04/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-19-%E2%80%94%E2%80%94-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>2021/04/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-19-%E2%80%94%E2%80%94-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p><img src="/2021/04/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-19-%E2%80%94%E2%80%94-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%80%EF%BC%89/1.png" alt></p><p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p><p>示例 2：</p><p>输入：head = [1], n = 1<br>输出：[]</p><p>示例 3：</p><p>输入：head = [1,2], n = 1<br>输出：[1]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>链表中结点的数目为 sz<br>1 &lt;= sz &lt;= 30<br>0 &lt;= Node.val &lt;= 100<br>1 &lt;= n &lt;= sz</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是一个链表的问题，这类题目建议大家多画图，用图辅助理解效果最好。</p><p>首先，还是跟之前一样，强调一下虚拟头结点的重要性。在链表求解的过程中，引入虚拟头结点之后，我们就可以将head指针和其他链表的其他节点一样统一处理，这样就避免了head指针的特殊性，我们处理起来更舒服，因此强烈建议在处理链表问题时，一定要创建一个虚拟头结点，然后让其指向head。</p><p>好了，看题，有如下思路：</p><p>1、因为要求倒数第n个点，因此链表的长度是一定要知道的，所以我们需要构建一个循环，把链表的长度求出来。</p><p>2、假设求出来链表的长度为N，那么倒数第n个点，其实就是正数第N-n+1个点。（公式为：target = length - 倒数第几 +1）</p><p>3、由于本题是一个单链表，所以想要删除一个节点，其实就是将要删除的节点的上一个节点的next指针指向要删除节点的下一个节点即可，用图表示如下：</p><p><img src="/2021/04/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-19-%E2%80%94%E2%80%94-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%80%EF%BC%89/2.png" alt></p><p>4、倒数第n个节点的上一个节点就是倒数第n+1个节点，对应正数第N-(n+1)+1，即N-n个点。</p><p>具体，请看代码实现就好了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);<span class="comment">//创建虚拟头结点，里面的val随便设置，算法中不需要用。</span></span><br><span class="line">        dummy -&gt; next = head;<span class="comment">//设置虚拟头结点指向head</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> t = dummy;</span><br><span class="line">        <span class="keyword">while</span>(t)&#123;</span><br><span class="line">          <span class="comment">//求出链表长度</span></span><br><span class="line">            t = t -&gt; next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//开始进行删除操作</span></span><br><span class="line">        t = dummy;</span><br><span class="line">        <span class="comment">//倒数第n+1个点就是正数第length-(k+1)+1=length-k个点。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length - n - <span class="number">1</span>; i++) t = t -&gt;next;</span><br><span class="line">        t-&gt;next = t-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 18 —— 四数之和（一百一十）</title>
      <link href="2021/04/13/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-18-%E2%80%94%E2%80%94-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%EF%BC%89/"/>
      <url>2021/04/13/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-18-%E2%80%94%E2%80%94-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>注意：答案中不可以包含重复的四元组。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：nums = [1,0,-1,0,-2,2], target = 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br>示例 2：</p><p>输入：nums = [], target = 0<br>输出：[]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>0 &lt;= nums.length &lt;= 200<br>$-10^9$ &lt;= nums[i] &lt;=$10^9$<br>$-10^9$ &lt;= target &lt;= $10^9$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题在思路上与上题类似，是一个排序+双指针的做法。</p><p>首先，还是要强调一下，我们如果要使用双指针，一定保证有序，因此排序这个步骤不可省略。</p><p>在保证有序的前提下，我们进行如下的思考：</p><p>1、因为双指针，所以一定会固定2个数，然后用2个指针寻找满足条件的答案。</p><p>2、因此至少需要两重循环，假设固定nums[i]和nums[j]，然后使用k和u来寻找满足条件的答案。</p><p>3、这里有一个小的剪枝，即在搜索的过程中，不管是固定的两个数还是用指针寻找的两个数，只要前后两个数一致时，就可以跳过。（因为有序，因此相同的数一定挨着，因此我们只需要保证前后两个数不同，就能够视为枚举了不同的情况）</p><p>4、类似三数之和，这里规定，i&lt;j&lt;k&lt;u。</p><p>具体做法：</p><p>1、固定两个数，原则上k指针从j+1开始往右走，u指针从nums.size()-1处往左走。</p><p>2、首先在nums[i] + nums[j] + nums[k] + nums[u] ≥ target 且 u&gt;k 的情况下，让u—。</p><p>3、在上述条件满足的前提条件下，再判断nums[i] + nums[j] + nums[k] + nums[u] == target 与u &gt; k 是否满足即可。</p><p>4、如果满足，则加入答案中，不满足则继续寻找。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先还是排个序，然后固定两个值之后，用双指针求剩下两个值</span></span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; nums.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>,u = nums.size() <span class="number">-1</span>; k &lt; u; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k &gt; j + <span class="number">1</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>] ) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">while</span>(u &gt; k &amp;&amp; nums[i] + nums[j] + nums[k] + nums[u] &gt; target) u--;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] + nums[u] == target &amp;&amp; u &gt; k)&#123;</span><br><span class="line">                        res.push_back(&#123;nums[i],nums[j],nums[k],nums[u]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 17 —— 电话号码的字母组合（一百零九）</title>
      <link href="2021/04/12/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-17-%E2%80%94%E2%80%94-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B9%9D%EF%BC%89/"/>
      <url>2021/04/12/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-17-%E2%80%94%E2%80%94-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。</p><p>注意： 1 不对应任何字母。</p><p><img src="/2021/04/12/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-17-%E2%80%94%E2%80%94-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B9%9D%EF%BC%89/1.png" alt></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：digits = “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p><p>示例 2：</p><p>输入：digits = “”<br>输出：[]</p><p>示例 3：</p><p>输入：digits = “2”<br>输出：[“a”,”b”,”c”]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1、0 &lt;= digits.length &lt;= 4<br>2、digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题采用深度优先遍历的算法进行求解，在实现上使用递归的思想。</p><p>我们需要实现一个dfs的递归函数，其中需要知道给出的数字串、确定当前递归哪一位以及当前未完全遍历好的答案字符串。具体见注释说明即可~</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="built_in">string</span> strs[<span class="number">10</span>] = &#123;</span><br><span class="line">      <span class="comment">//使用字符串数组模拟手机位置上的按键</span></span><br><span class="line">            <span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.empty()) <span class="keyword">return</span> ans;</span><br><span class="line">        dfs(digits,<span class="number">0</span>,<span class="string">&quot;&quot;</span>);<span class="comment">//给定初始值，然后开始递归即可。</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//u表示当前遍历的层的深度，path为路径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; digits, <span class="keyword">int</span> u, <span class="built_in">string</span> path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == digits.size()) ans.push_back(path); <span class="comment">//如果深度达到最大，则答案加上这一次的路径结果</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//否则，根据strs，求出对应数字代表的字母的字符串,然后用for循环一个一个枚举。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c: strs[digits[u] - <span class="string">&#x27;0&#x27;</span>])&#123;</span><br><span class="line">                dfs(digits,u+<span class="number">1</span>,path+c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 16 —— 最接近的三数之和（一百零八）</title>
      <link href="2021/04/11/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-16-%E2%80%94%E2%80%94-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E5%85%AB%EF%BC%89/"/>
      <url>2021/04/11/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-16-%E2%80%94%E2%80%94-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>输入：nums = [-1,2,1,-4], target = 1<br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>3 &lt;= nums.length &lt;= 10^3<br>-10^3 &lt;= nums[i] &lt;= 10^3<br>-10^4 &lt;= target &lt;= 10^4</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>继续采用双指针做法来做本题。首先，固定i，对于每个j，找出一个最小值k使得，nums[i] + nums[j] + nums[k] &gt;= target。</p><p>又因为只要找出来nums[i] + nums[j] + nums[k] &gt;= target，那么必然nums[i] + nums[j] + nums[k-1] &lt; target。<br>这样的话，就可以比较一下哪个更加接近，最终确定答案。</p><p>这里面需要对pair这个数据结构进行一个复习，解释地址为：<a href="https://blog.csdn.net/u011499425/article/details/52756088">https://blog.csdn.net/u011499425/article/details/52756088</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        pair&lt;int,int&gt; res(INT_MAX,INT_MAX);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size(); i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>,k = nums.size() - <span class="number">1</span>; j &lt; k; j++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(k - <span class="number">1</span> &gt; j &amp;&amp; nums[i] + nums[j] + nums[k - <span class="number">1</span>] &gt;= target) k--;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">                res = min(res, <span class="built_in">make_pair</span>(<span class="built_in">abs</span>(sum - target),sum));</span><br><span class="line">                <span class="keyword">if</span>(k - <span class="number">1</span> &gt; j)&#123;</span><br><span class="line">                    sum = nums[i] + nums[j] + nums[k - <span class="number">1</span>];</span><br><span class="line">                    res = min(res, <span class="built_in">make_pair</span>(target - sum,sum));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 15 —— 三数之和（一百零七）</title>
      <link href="2021/04/10/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-15-%E2%80%94%E2%80%94-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%83%EF%BC%89/"/>
      <url>2021/04/10/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-15-%E2%80%94%E2%80%94-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：</p><p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]</p><p>示例 2：</p><p>输入：nums = []<br>输出：[]</p><p>示例 3：</p><p>输入：nums = [0]<br>输出：[]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>0 &lt;= nums.length &lt;= 3000<br>$-10^5$ &lt;= nums[i] &lt;= $10^5$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>我们可以使用双指针算法进行求解。</p><p>首先要明确，使用双指针算法的前提是有序，所以必须在使用之前对nums进行排序。</p><p>然后，假设有指针i、j、k，我们有如下思想：</p><p>为了最大限度减少重复的情况，我们可以规定i &lt; j &lt; k。</p><p>我们可以寻找满足nums[i]+nums[j]+nums[k] ≥ 0，因此当固定指针i时，当j指针往右移动时，因为数组有序，所以k指针一定往左移动，从中求出满足nums[i]+nums[j]+nums[k] = 0的情况。</p><p>注意，为了防止不重复，需要判断指针j的位置上的数值与下一个位置的数值是否一致，如果一致，则继续跳过。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针算法的前提是有序。令i&lt;j&lt;k，固定i，然后对j和k进行双指针。将时间复杂度从n^3降为n^2。同时为了避免重复的三元组，需要对循环迭代的元素进行比较，若前一个元素和后一个元素一致，则跳过，一直到不是该元素为止。当然这个可行的前提依旧是需要有序！</span></span><br><span class="line">        <span class="comment">//i &amp;&amp; nums[i] == nums[i - 1] 这种判断，可以将i==0的情况跳过，非常巧妙。</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] ) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span>, k = nums.size() - <span class="number">1</span>; j &lt; k; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">//j不是第一个数，同时数相同时，则跳过</span></span><br><span class="line">                <span class="keyword">while</span>(j &lt; k - <span class="number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k - <span class="number">1</span>] &gt;= <span class="number">0</span>) k--; <span class="comment">//如果k的下一个数不与j重叠，且三数之和大于0，则一直往前</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[k] == <span class="number">0</span>)&#123;</span><br><span class="line">                    res.push_back(&#123;nums[i],nums[j],nums[k]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 14 —— 最长公共前缀（一百零六）</title>
      <link href="2021/04/09/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-14-%E2%80%94%E2%80%94-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E5%85%AD%EF%BC%89/"/>
      <url>2021/04/09/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-14-%E2%80%94%E2%80%94-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：<br>输入：strs = [“flower”,”flow”,”flight”]<br>输出：”fl”</p><p>示例 2：<br>输入：strs = [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀。</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>0 &lt;= strs.length &lt;= 200<br>0 &lt;= strs[i].length &lt;= 200<br>strs[i] 仅由小写英文字母组成</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题在思路上比较简单，就是遍历字符串，看前缀是否相同。在做法上，要注意如果本身strs为空，那么直接返回空字符串即可。如果不为空，当遍历到第i个位置的时候，如果某个字符串长度小于i，说明前缀最大长度已经取到，直接返回即可；或者某字符串的第i个位置的字符与即将作为公共前缀的字符不一致，则也说明到了前缀的最大长度，返回即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">if</span>(strs.empty()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= strs[<span class="number">0</span>].size()) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str: strs)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str.size() &lt;= i || str[i] != c)</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            res += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 13 —— 罗马数字转整数（一百零五）</title>
      <link href="2021/04/08/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-13-%E2%80%94%E2%80%94-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E4%BA%94%EF%BC%89/"/>
      <url>2021/04/08/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-13-%E2%80%94%E2%80%94-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><p><img src="/2021/04/08/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-13-%E2%80%94%E2%80%94-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E4%BA%94%EF%BC%89/1.png" alt></p><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>1、I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>2、X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>3、C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</p><p>要求：给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1:<br>输入: “III”<br>输出: 3</p><p>示例 2:<br>输入: “IV”<br>输出: 4</p><p>示例 3:<br>输入: “IX”<br>输出: 9</p><p>示例 4:<br>输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3.</p><p>示例 5:<br>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1 &lt;= s.length &lt;= 15<br>s 仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’)<br>题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内<br>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。<br>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。<br>关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是将罗马数字转化为阿拉伯数字。需要注意一点即可做出来。我们可以发现，以4、9开头的罗马数字字符组合都是前数大于后数，是需要后数减掉前数的。因此，我们在遍历整个罗马数字字符的过程中，遇到前数大于后数的情况，那么相减对应表达的阿拉伯数字即可。<br>为了方便，我们可以采用哈希表将字母映射为数字，方便我们求解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; hash; <span class="comment">//将字母映射成为数字，开一个hash表</span></span><br><span class="line">        hash[<span class="string">&#x27;I&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        hash[<span class="string">&#x27;V&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line">        hash[<span class="string">&#x27;X&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">        hash[<span class="string">&#x27;L&#x27;</span>] = <span class="number">50</span>;</span><br><span class="line">        hash[<span class="string">&#x27;C&#x27;</span>] = <span class="number">100</span>;</span><br><span class="line">        hash[<span class="string">&#x27;D&#x27;</span>] = <span class="number">500</span>;</span><br><span class="line">        hash[<span class="string">&#x27;M&#x27;</span>] = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[s[i]] &lt; hash[s[i+<span class="number">1</span>]] &amp;&amp; i + <span class="number">1</span> &lt; s.size())&#123;</span><br><span class="line">                res -= hash[s[i]];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res += hash[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 12 —— 整数转罗马数字（一百零四）</title>
      <link href="2021/04/07/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-12-%E2%80%94%E2%80%94-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E5%9B%9B%EF%BC%89/"/>
      <url>2021/04/07/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-12-%E2%80%94%E2%80%94-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。<br><img src="/2021/04/07/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-12-%E2%80%94%E2%80%94-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E5%9B%9B%EF%BC%89/1.png" alt="罗马数字和阿拉伯数字的对应关系"></p><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1:<br>输入: 3<br>输出: “III”</p><p>示例 2:<br>输入: 4<br>输出: “IV”</p><p>示例 3:<br>输入: 9<br>输出: “IX”</p><p>示例 4:<br>输入: 58<br>输出: “LVIII”<br>解释: L = 50, V = 5, III = 3.</p><p>示例 5:<br>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1 &lt;= num &lt;= 3999</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题在做的时候，需要考虑罗马数字的特征，主要有以下几点：<br>1、相同的字母连续出现，表示单个字符表示的数字的和，例如III=3,表示三个1相加。<br>2、罗马字符表示的小数在在大的数的右边，表示这些数字相加得到的数，如：VIII=8, XII=12；<br>3、罗马字符表示的小数在大的数的左边（限于 IV、IX、XL、XC、CD和CM），所表示的数等于大数减小数得到的数，如：IV=4, IX=9；<br>4、正常使用时，连写的数字重复不超过三次；</p><p>首先，因为题目中的num的范围是1到3999，因此我们先把所有的整数枚举一下：<br><img src="/2021/04/07/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-12-%E2%80%94%E2%80%94-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E5%9B%9B%EF%BC%89/2.png" alt><br>我们其实在本题有很多做法，最朴素的做法就是对阿拉伯数字每个位进行探究，然后对应位置加上罗马字符即可，但这样很麻烦。</p><p>这里提供一种巧妙做法。<br>我们可以发现，在1、2、3，10、20、30，100、200、300以及1000、2000、3000都是一个累加的关系，6、7、8以及后面对应规律数字都是累加的关系，只有4、5、9开头的整数没有规律。根据这个现象，我们可以作如下规律的计算：<br>考虑百位的话，从大到小考虑900、500、400和100，当数字大于900时，就添加一个CM，将数字减去900；当数字大于500，就添加一个D，将数字减去500；当数字大于400，就添加一个CD，将数字减去400；当数字大于100，就添加一个C，将数字减去100。其他位的处理方式之相对应。<br>可用数组来预定义处理的数字，然后再进行求解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> values[] = &#123;</span><br><span class="line">            <span class="number">1000</span>,</span><br><span class="line">            <span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,</span><br><span class="line">            <span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,</span><br><span class="line">            <span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> reps[] = &#123;</span><br><span class="line">            <span class="string">&quot;M&quot;</span>,</span><br><span class="line">            <span class="string">&quot;CM&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;CD&quot;</span>,<span class="string">&quot;C&quot;</span>,</span><br><span class="line">            <span class="string">&quot;XC&quot;</span>,<span class="string">&quot;L&quot;</span>,<span class="string">&quot;XL&quot;</span>,<span class="string">&quot;X&quot;</span>,</span><br><span class="line">            <span class="string">&quot;IX&quot;</span>,<span class="string">&quot;V&quot;</span>,<span class="string">&quot;IV&quot;</span>,<span class="string">&quot;I&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=<span class="number">12</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(num &gt;= values[i])&#123;</span><br><span class="line">                num -= values[i];</span><br><span class="line">                res += reps[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 11 —— 盛水最多的容器（一百零三）</title>
      <link href="2021/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-11-%E2%80%94%E2%80%94-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%89%EF%BC%89/"/>
      <url>2021/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-11-%E2%80%94%E2%80%94-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：<br><img src="/2021/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-11-%E2%80%94%E2%80%94-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%89%EF%BC%89/1.png" alt><br>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>示例 2：<br>输入：height = [1,1]<br>输出：1</p><p>示例 3：<br>输入：height = [4,3,2,1,4]<br>输出：16</p><p>示例 4：<br>输入：height = [1,2,1]<br>输出：2</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>n = height.length<br>2 &lt;= n &lt;= 3 <em> 10^4<br>0 &lt;= height[i] &lt;= 3 </em> 10^4</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题又是一道有关指针扫描的问题，思路如下：<br>将两个指针分别指向左端点和右端点，然后求面积；接着比较两个指针代表的边界高度，哪个小就往前移动，继续求面积，最后得出最大的面积。</p><p>这里需要证明上述方法是能得到最优解的方法：<br>假设最优解对应的两条线的下标是 i′,j′(i′&lt;j′)，在 i,j 不断靠近的过程中，不妨假设 i 先走到 i′，则此时有 j′&lt;j。反证，如果此时 ai ≤ aj，设 S 表示 i,j能盛多少水，S′ 表示 i′,j′能盛多少水，则：<br>S=min(ai,aj)∗(j−i)<br> =ai∗(j−i)</p><blockquote><p>ai∗(j′−i)<br> ≥min(ai,aj′)∗(j′−i)=S′<br>与 S′是最优解矛盾，因此 ai&gt;aj，所以 j 会一直走到 j′，从而得到最优解。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = height.size() - <span class="number">1</span>; i &lt; j;)&#123;</span><br><span class="line">            res = max(res,(min(height[i],height[j]) * (j - i)));</span><br><span class="line">            <span class="keyword">if</span>(height[i] &gt; height[j]) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Django】有关多用户管理的一点小经验分享</title>
      <link href="2021/04/05/%E3%80%90Django%E3%80%91%E6%9C%89%E5%85%B3%E5%A4%9A%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
      <url>2021/04/05/%E3%80%90Django%E3%80%91%E6%9C%89%E5%85%B3%E5%A4%9A%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近，笔者因为需要开发一个系统作为毕设的展示，因此就产生了有关多用户管理的问题。在这里我把自己的需求重新阐明一下：能够通过Django自带的用户管理框架，实现多用户的管理，例如登录、登出、session、有效期等管理。<br>翻看很多同行写的文章，发现有关Django的多用户开发很多都含糊其词。主要原因是因为Django的django-admin框架的用户管理要么是用其自带的User类作为用户管理类，要么是自定义用户类别，并继承AbstractUser类。但是，无法实现两个或者多个类同时继承AbstractUser类，并且在settings.py文件中，AUTH_USER_MODEL也仅仅允许添加一个类。因此为了达到我们能够实现的需求，我有如下的设计思想，这个思想在后续的实践中证明可行。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>假设有用户类型A和用户类型B两中用户。</p><h2 id="Step1-定义一个User类，使其继承AbstractUser类。"><a href="#Step1-定义一个User类，使其继承AbstractUser类。" class="headerlink" title="Step1:定义一个User类，使其继承AbstractUser类。"></a>Step1:定义一个User类，使其继承AbstractUser类。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">AbstractUser</span>):</span></span><br><span class="line">    is_type1 = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line">    is_type2 = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 这里添加三类用户的除Django-admin框架的User类属性外的额外属性</span></span><br><span class="line">    <span class="comment"># 比如姓名</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>通过上面的代码，可以清楚的看到，User类中设置一个布尔标志，来对用户角色加以区分。<br>这样设计的好处就是将不同类型的用户进行了统一化。</p><h2 id="Step2-定义用户类型1的用户类和用户类型2的用户类"><a href="#Step2-定义用户类型1的用户类和用户类型2的用户类" class="headerlink" title="Step2:定义用户类型1的用户类和用户类型2的用户类"></a>Step2:定义用户类型1的用户类和用户类型2的用户类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这里是用户类型1的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User_Type_1</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    user = models.OneToOneField(User, on_delete=models.CASCADE, primary_key=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 一类用户的特有属性</span></span><br><span class="line">    user_type_1_teyoushuxing = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;tb_user_type_1&#x27;</span>  <span class="comment"># 修改表名</span></span><br><span class="line">        verbose_name = <span class="string">&#x27;第一类用户管理&#x27;</span>  <span class="comment"># 管理系统后台显示名称</span></span><br><span class="line">        verbose_name_plural = verbose_name  <span class="comment"># 后台显示</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#这里是用户类型2的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User_Type_2</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    user = models.OneToOneField(User, on_delete=models.CASCADE, primary_key=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 二类用户的特有属性</span></span><br><span class="line">    user_type_2_teyoushuxing = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;tb_user_type_2&#x27;</span>  <span class="comment"># 修改表名</span></span><br><span class="line">        verbose_name = <span class="string">&#x27;第二类用户管理&#x27;</span>  <span class="comment"># 管理系统后台显示名称</span></span><br><span class="line">        verbose_name_plural = verbose_name  <span class="comment"># 后台显示</span></span><br></pre></td></tr></table></figure><p>我们可以看到，通过代码<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user = models.OneToOneField(User, on_delete=models.CASCADE, primary_key=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>将User和两类用户进行了绑定，这样做我们就实现了对User的一个扩展，同时实现了不同用户之前的互不干扰。</p><h2 id="Step3-在注册创建用户时"><a href="#Step3-在注册创建用户时" class="headerlink" title="Step3:在注册创建用户时"></a>Step3:在注册创建用户时</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            user = User.objects.create_user(</span><br><span class="line">                username=username,</span><br><span class="line">                password=password,</span><br><span class="line">                name=name</span><br><span class="line">            )</span><br><span class="line">            usertype_1 = User_Type_1.objects.create(user=user, user_type_1_teyoushuxing=user_type_1_teyoushuxing)</span><br><span class="line">        <span class="keyword">except</span> DatabaseError <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(e)</span><br><span class="line">            <span class="keyword">return</span> HttpResponseBadRequest(<span class="string">&#x27;注册失败&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Step4-在登录用户时"><a href="#Step4-在登录用户时" class="headerlink" title="Step4:在登录用户时"></a>Step4:在登录用户时</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate</span><br><span class="line">    <span class="comment"># 默认认证方法是针对username字段进行用户名的判断</span></span><br><span class="line">    user = authenticate(username=username, password=password)</span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponseBadRequest(<span class="string">&#x27;用户名或者密码错误&#x27;</span>)</span><br></pre></td></tr></table></figure><p>直接使用内置的authenticate获取用户即可，然后根据扩展属性名来获取扩展的特有属性即可。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 10 —— 正则表达式匹配（一百零二）</title>
      <link href="2021/04/05/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-10-%E2%80%94%E2%80%94-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E4%BA%8C%EF%BC%89/"/>
      <url>2021/04/05/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-10-%E2%80%94%E2%80%94-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><p>1、’.’ 匹配任意单个字符<br>2、’*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：<br>输入：s = “aa” p = “a”<br>输出：false<br>解释：”a” 无法匹配 “aa” 整个字符串。</p><p>示例 2:<br>输入：s = “aa” p = “a<code>*</code>“<br>输出：true<br>解释：因为 ‘<code>*</code>‘ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p><p>示例 3：<br>输入：s = “ab” p = “.<code>*</code>“<br>输出：true<br>解释：”.<code>*</code>“ 表示可匹配零个或多个（’<code>*</code>‘）任意字符（’.’）。</p><p>示例 4：<br>输入：s = “aab” p = “c<code>*</code>a<code>*</code>b”<br>输出：true<br>解释：因为 ‘<code>*</code>‘ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p><p>示例 5：<br>输入：s = “mississippi” p = “mis<code>*</code>is<code>*</code>p<code>*</code>.”<br>输出：false</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>0 &lt;= s.length &lt;= 20<br>0 &lt;= p.length &lt;= 30<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 <code>*</code>。<br>保证每次出现字符 * 时，前面都匹配到有效的字符</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题采用动态规划的方式求解。<br>一、状态表示  f[i,j]<br>    1、集合<br>        所有s[1-i]，p[1-j]的全部匹配方式。<br>    2、属性<br>        是否存在一个合法方案，布尔值<br>二、状态计算<br>    1、p[j] ≠ ‘<code>*</code>‘, f(i,j) = (s[i] == p[j] || p[j] = ‘.’) &amp;&amp; f(i-1,j-1))<br>    2、p[j] = ‘<code>*</code>‘, 这里需要枚举*到底表示几个字符。从表示1个字符开始以此类推。公式如下：<br>    f(i,j) = f(i,j-2) || (f(i-1,j-2) &amp;&amp; s[i] == p[j]) || (f(i-2,j-2) &amp;&amp; s[i] == p[j] &amp;&amp; s[i-1] == p[j-1]) || …<br>    最终，优化如下：<br>    f(i,j) = f(i,j-2) || (f(i-1,j) &amp;&amp; s[i] == (p[j] || p[j] == ‘.’))</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), m = p.size();</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s, p = <span class="string">&#x27; &#x27;</span> + p; <span class="comment">//为了让s和p的下标从1开始。</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">f</span><span class="params">(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m+<span class="number">1</span>))</span></span>; <span class="comment">//定义状态转移方程</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123; <span class="comment">//两个空串的匹配在初始化已经赋值为true，第二个字符串从1开始是也是因为空串匹配情况已经排除了    </span></span><br><span class="line">                <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= m &amp;&amp; p[j+<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> ) <span class="keyword">continue</span>; <span class="comment">//将类似 a*  的情况中遍历到a的情况略过，因为a和*要看成整体，任何一个小部分都不可单独存在。</span></span><br><span class="line">                <span class="keyword">if</span>(i &amp;&amp; p[j] != <span class="string">&#x27;*&#x27;</span>)&#123; <span class="comment">//i要从1开始，因为i==0时，不表示任何字符，且i-1会越界</span></span><br><span class="line">                    <span class="comment">//这是本题中的第一种情况</span></span><br><span class="line">                    f[i][j] = f[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; (p[j] == <span class="string">&#x27;.&#x27;</span> || s[i] == p[j]);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p[j] == <span class="string">&#x27;*&#x27;</span> )&#123;</span><br><span class="line">                    <span class="comment">//这里说个问题，如果在if中加入判断i是否为0的条件，那么只会走上面的步骤，所以要把判断i放到公式中判断</span></span><br><span class="line">                    f[i][j] = f[i][j<span class="number">-2</span>] || i &amp;&amp; f[i<span class="number">-1</span>][j] &amp;&amp; (s[i] == p[j<span class="number">-1</span>] || p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 9 —— 回文数（一百零一）</title>
      <link href="2021/04/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-9-%E2%80%94%E2%80%94-%E5%9B%9E%E6%96%87%E6%95%B0%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%80%EF%BC%89/"/>
      <url>2021/04/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-9-%E2%80%94%E2%80%94-%E5%9B%9E%E6%96%87%E6%95%B0%EF%BC%88%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：<br>输入：x = 121<br>输出：true</p><p>示例 2：<br>输入：x = -121<br>输出：false<br>解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p><p>示例 3：<br>输入：x = 10<br>输出：false<br>解释：从右向左读, 为 01 。因此它不是一个回文数。</p><p>示例 4：<br>输入：x = -101<br>输出：false</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>-2^31 &lt;= x &lt;= 2^31 - 1</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>首先，这里直接对负数进行剪枝，如果x &lt; 0，那么直接返回0即可。<br>然后在保证x为整数的情况下，进行如下两种思考：<br>Part1 进行两个字符串的比较<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = to_string(x)</span><br><span class="line"><span class="keyword">return</span> s == <span class="built_in">string</span>(s.rbegin(),s.rend())</span><br></pre></td></tr></table></figure></p><p>Part2 数字翻转并比较<br>因为题目中没有对数据类型的限制，因此为了防止int类型溢出，采用long long 来存储翻转后的数字，然后进行x == res的比较即可。<br>我们需要将x中从个位开始抠出来，然后每次*10即可，具体看下方代码。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = x;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span>;<span class="comment">//x % 10 会取出x的个位数</span></span><br><span class="line">            x /= <span class="number">10</span>;<span class="comment">//x除完之后将x的个位数去掉</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> y == res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 8 —— 字符串转换整数（一百）</title>
      <link href="2021/03/31/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-8-%E2%80%94%E2%80%94-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%EF%BC%88%E4%B8%80%E7%99%BE%EF%BC%89/"/>
      <url>2021/03/31/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-8-%E2%80%94%E2%80%94-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%EF%BC%88%E4%B8%80%E7%99%BE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</p><p>函数 myAtoi(string s) 的算法如下：</p><ul><li>读入字符串并丢弃无用的前导空格</li><li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li><li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li><li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li><li>如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。</li><li>返回整数作为最终结果。</li></ul><p>注意：<br>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例一<br>输入：s = “42”<br>输出：42</p><p>示例二<br>输入：s = “   -42”<br>输出：-42</p><p>示例三<br>输入：s = “4193 with words”<br>输出：4193</p><p>示例四<br>输入：s = “words and 987”<br>输出：0<br>解释：由于字符串开头就存在除了“-”和“+”字符以外的字符’w’，且不是一个数字，所以读入停止</p><p>示例五<br>输入：s = “-91283472332”<br>输出：-2147483648<br>解释：-91283472332小于 -2^31,因此答案固定位-2^31对应的值</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>0 &lt;= s.length &lt;= 200<br>s 由英文字母（大写和小写）、数字（0-9）、’ ‘、’+’、’-‘ 和 ‘.’ 组成</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>这里注意因为题目给的条件限制过于多，推荐先根据题目意思，按顺序读取字符串，把前导0、空格等剔除之后，并根据题中要求进行条件判断，把错误的内容全部去除，最后将数字存储为long long类型，根据数字的正负号对应判断其是否大于2^31-1或者-2^31,然后求出答案。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(s[k] == <span class="string">&#x27; &#x27;</span> &amp;&amp; k &lt; s.size()) k++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k == s.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minus = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[k] == <span class="string">&#x27;-&#x27;</span>) minus = <span class="number">-1</span>, k++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[k] == <span class="string">&#x27;+&#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; s.size() &amp;&amp; s[k] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[k] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            res = res * <span class="number">10</span> + s[k] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res *= minus;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 7 —— 整数反转（九十九）</title>
      <link href="2021/03/31/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-7-%E2%80%94%E2%80%94-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC%EF%BC%88%E4%B9%9D%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
      <url>2021/03/31/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-7-%E2%80%94%E2%80%94-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC%EF%BC%88%E4%B9%9D%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 [−2^31,  2^31 − 1] ，就返回 0。</p><p>假设环境不允许存储 64 位整数（有符号或无符号）。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：<br>输入：x = 123<br>输出：321</p><p>示例 2：<br>输入：x = -123<br>输出：-321</p><p>示例 3：<br>输入：x = 120<br>输出：21</p><p>示例 4：<br>输入：x = 0<br>输出：0</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>-2^31 &lt;= x &lt;= 2^31 - 1</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题可以依次从右往左计算出每位数字，然后逆序累加在一个整数中。</p><p>本题有两点需要注意：<br>1、由于int型整数逆序后可能会溢出，要用long long类型记录中间结果；<br>2、在C++中，负数的取模运算和数学意义上的取模运算不同，其结果还是负数，例如 −12 % 10 = −2，所以我们不需要对负数进行额外处理。</p><p>时间复杂度分析：一共有 O(logn) 位，对于每一位的计算量是常数级的，所以总时间复杂度是 O(logn).</p><p>解释一下为什么O(logn):<br>比如数字n=100，那其数字长度与 log以10为底的100的对数 有关。本题中更关心的是数x，对应的数字长度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            <span class="comment">//x % 10 把x的每一位抠出来,然后再更新x=x/10即可。 秦九韶算法</span></span><br><span class="line">            <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; res &gt; (INT_MAX - x % <span class="number">10</span>) / <span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> &amp;&amp; res &lt; (INT_MIN - x % <span class="number">10</span>) / <span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 6 —— Z字形变换（九十八）</title>
      <link href="2021/03/31/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-6-%E2%80%94%E2%80%94-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B9%9D%E5%8D%81%E5%85%AB%EF%BC%89/"/>
      <url>2021/03/31/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-6-%E2%80%94%E2%80%94-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B9%9D%E5%8D%81%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p><p><img src="/2021/03/31/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-6-%E2%80%94%E2%80%94-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B9%9D%E5%8D%81%E5%85%AB%EF%BC%89/1.png" alt><br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：<br>输入：s = “PAYPALISHIRING”, numRows = 3<br>输出：”PAHNAPLSIIGYIR”</p><p>示例 2：<br>输入：s = “PAYPALISHIRING”, numRows = 4<br>输出：”PINALSIGYAHRPI”<br>解释：<br><img src="/2021/03/31/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-6-%E2%80%94%E2%80%94-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B9%9D%E5%8D%81%E5%85%AB%EF%BC%89/2.png" alt></p><p>示例 3：<br>输入：s = “A”, numRows = 1<br>输出：”A”</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1 &lt;= s.length &lt;= 1000<br>s 由英文字母（小写和大写）、’,’ 和 ‘.’ 组成<br>1 &lt;= numRows &lt;= 1000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>在一般题目中，有按照某情况打印字符等题目，都需要进行找规律，找到了规律再辅以代码实现即可。我们可以先在草稿纸上画个图，来辅助理解。<br>先画行数是4的情况：</p><p><img src="/2021/03/31/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-6-%E2%80%94%E2%80%94-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B9%9D%E5%8D%81%E5%85%AB%EF%BC%89/3.png" alt></p><p>对于行数是 n 的情况，有如下发现：</p><p>1、第一行和最后一行，分别对应两个等差数列，前一个首项是0，后一个首项是n-1，公差均为 2(n−1)；<br>对于第 i 行(0&lt;i&lt;n−1)，是两个公差为 2(n−1) 的等差数列交替排列，首项分别是 i 和 2n−i−2；<br>所以我们可以从上到下，依次打印每行的字符。</p><p>时间复杂度分析：每个字符均需要遍历一遍O(n)，每个字符仅计算O(1)的时间，所以时间复杂度是O(n).</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//本题主要在于找规律，找到从第一列访问到后面数的规律就可以了。</span></span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>|| i == n - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j&lt; s.size();j += <span class="number">2</span> * n - <span class="number">2</span>)&#123;</span><br><span class="line">                    res+=s[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i, k = <span class="number">2</span> * n - <span class="number">2</span> - i; j &lt; s.size() || k &lt; s.size(); j += <span class="number">2</span> * n - <span class="number">2</span>, k += <span class="number">2</span> * n - <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j &lt; s.size()) res += s[j];</span><br><span class="line">                    <span class="keyword">if</span>(k &lt; s.size()) res += s[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 5 —— 最长回文子串（九十七）</title>
      <link href="2021/03/30/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-5-%E2%80%94%E2%80%94-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B9%9D%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>2021/03/30/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-5-%E2%80%94%E2%80%94-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B9%9D%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：<br>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p><p>示例 2：<br>输入：s = “cbbd”<br>输出：”bb”</p><p>示例 3：<br>输入：s = “a”<br>输出：”a”</p><p>示例 4：<br>输入：s = “ac”<br>输出：”a”</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>1 &lt;= s.length &lt;= 1000<br>s 仅由数字和英文字母（大写和/或小写）组成</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>根据回文串的特征来求解本题。<br>首先，当回文串的字符数量为奇数时，一定以某个点为中心，然后字符对称相等；当回文串的字符数量为偶数时，一定以中间两个点为中心，然后字符对称相等。根据这一点，我们可以遍历整个数组，枚举每一个点为中心的情况，最终求出全局回文串最大长度。<br>tips:<br>以i为中心，遍历奇数的情况和偶数的情况。奇数，则初始化l = i - 1,r = i + 1。偶数，则初始化l = i, r = i + 1</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//长度为奇数的情况</span></span><br><span class="line">            <span class="keyword">int</span> l = i - <span class="number">1</span>,r = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.size() &amp;&amp; s[l] == s[r])&#123;</span><br><span class="line">                l --;</span><br><span class="line">                r ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(res.size() &lt; r - l - <span class="number">1</span>) res = s.substr(l + <span class="number">1</span>, r - l - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//长度为偶数的情况</span></span><br><span class="line">            l = i, r = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.size() &amp;&amp; s[l] == s[r])&#123;</span><br><span class="line">                l --;</span><br><span class="line">                r ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(res.size() &lt; r - l - <span class="number">1</span>) res = s.substr(l + <span class="number">1</span>, r - l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 4 —— 寻找两个正序数组的中位数（九十六）</title>
      <link href="2021/03/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-4-%E2%80%94%E2%80%94-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%EF%BC%88%E4%B9%9D%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>2021/03/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-4-%E2%80%94%E2%80%94-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%EF%BC%88%E4%B9%9D%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>示例 1：<br>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2</p><p>示例 2：<br>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p><p>示例 3：<br>输入：nums1 = [0,0], nums2 = [0,0]<br>输出：0.00000</p><p>示例 4：<br>输入：nums1 = [], nums2 = [1]<br>输出：1.00000</p><p>示例 5：<br>输入：nums1 = [2], nums2 = []<br>输出：2.00000</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>nums1.length == m<br>nums2.length == n<br>0 &lt;= m &lt;= 1000<br>0 &lt;= n &lt;= 1000<br>1 &lt;= m + n &lt;= 2000<br>$-10^6$ &lt;= nums1[i], nums2[i] &lt;= $10^6$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>首先需要明确，这里所指的中位数，在两个数组个数总和为奇数时，就是排序后的中位数，也是第k = (m+n)/2 的数。如果两个数组总和为偶数时，就是排序后最中间的两个数的平均数。</p><p>然后本题在思路上，采用递归的思想，将问题转化为子问题考虑，即：思考如何求解合并后的数组的第k小的数即可，因为中位数就是当k =（m+n)/2 的情况。</p><p>在方法上，有如下思考：<br>因为数组是正序，因此不用担心乱序的问题。<br>假设 m,n ≥ k/2。我们先从 nums1 和 nums2 中各取前 k/2 个元素（也就是看一下两个数组的前 k/2 个元素），有如下三种情况，这里详解一种情况，其他的就都会了。<br>1、nums1[k/2] &lt; nums2[k/2]<br>当上述情况出现时，由于两个数组取出的数的个数一致，但因为nums1[k/2] 小于 nums2[k/2]，就会有nums2中取出来的数严格小于nums1[k/2]的数的数量小于k/2。因此，总共来看，小于nums1[k/2]的个数一定小于k。所以，在合并后，nums1[k/2]对应的数一定在第k个数之前。<br>所以，把nums1[k/2]的数之前的数全部删除，然后继续按照上述思路求解。</p><p>2、nums1[k/2] &gt; nums2[k/2]<br>与上述思路一致，这里只不过删除nums2中的前k/2个元素</p><p>3、nums1[k/2] == nums2[k/2]<br>这里nums1[k/2]或者nums2[k/2]就是答案。</p><p>现在考虑边界情况，如果 m &lt; k/2，则我们从 nums1 中取m个元素，从 nums2 中取 k/2 个元素（由于 k=(n+m)/2，因此 m,n 不可能同时小于 k/2.）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = nums1.size() + nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(total % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = find(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,total/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> right = find(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,total/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> find(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,total/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1,<span class="keyword">int</span> i,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2,<span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//i代表从nums1的第i个数开始，j代表从nums2的第j个数开始，k代表第k个数</span></span><br><span class="line">        <span class="keyword">if</span>(nums1.size() - i &gt; nums2.size() - j) <span class="keyword">return</span> find(nums2,j,nums1,i,k);<span class="comment">//固定nums1较短，nums2较长</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理边界问题</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1.size() == i)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> min(nums1[i],nums2[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums1.size() == i) <span class="keyword">return</span> nums2[j+k<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> si = min((<span class="keyword">int</span>)nums1.size(),i + k / <span class="number">2</span>), sj = j + k - k / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums1[si - <span class="number">1</span>] &gt; nums2[sj - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> find(nums1,i,nums2,sj,k-(sj - j));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> find(nums1,si,nums2,j,k-(si - i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 3 —— 无重复字符的最长子串（九十五）</title>
      <link href="2021/03/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-3-%E2%80%94%E2%80%94-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B9%9D%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>2021/03/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-3-%E2%80%94%E2%80%94-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B9%9D%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p><strong>示例 1:</strong><br>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p><strong>示例 2:</strong><br>输入: s = “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><p><strong>示例 3:</strong><br>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><p><strong>示例 4:</strong><br>输入: s = “”<br>输出: 0</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>0 &lt;= s.length &lt;= 5 * 10^4<br>s 由英文字母、数字、符号和空格组成</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>采用双指针问题进行求解。<br>在双指针或者滑动窗口算法中，需要思考的就是如何能够枚举子串不重不漏，最后找到题目的答案。在本题中，可以通过以子串的尾结点为分类标准，比如尾结点的下标为0，为1，为2，…，直到枚举完毕，然后每次处理1类的问题，最后求全局最优解即可。在本题具体问题中，当枚举以i为尾结点的所有子串的时候，有这个结论，即当i往后移动后，对应的不重复子串要么不动，要么往后移动。因此，我们就可以通过这个属性将每个字串的最大不重复子串的长度找出来，然后求全局最大值即可。</p><p>证明：当i和j指针包含的子串达到最大不重复子串要求时，i指针往后移动后，j指针一定要么不动要么往后移动。<br>因为当i往后移动后，只有两种情况：<br>1、i往后走的下一个字符在子串中没有出现，那么j就不移动，仍然符合最大不重复子串的要求<br>2、i往后走的下一个字符在子串中出现，那么j往左移动就一定不是题目要求，因为子串中一定包含重复元素，因此，j只能往后移动，直到其内部子串达到不重复为止。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; heap;<span class="comment">//用hash表统计一下每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            heap[s[i]]++;</span><br><span class="line">            <span class="keyword">while</span>(heap[s[i]] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                heap[s[j++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res,i-j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 2 —— 两数相加（九十四）</title>
      <link href="2021/03/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-2-%E2%80%94%E2%80%94-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88%E4%B9%9D%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>2021/03/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-2-%E2%80%94%E2%80%94-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88%E4%B9%9D%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><p><img src="/2021/03/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-2-%E2%80%94%E2%80%94-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88%E4%B9%9D%E5%8D%81%E5%9B%9B%EF%BC%89/1.jpg" alt><br>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.</p><h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><p>输入：l1 = [0], l2 = [0]<br>输出：[0]</p><h3 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h3><p>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><p>每个链表中的节点数在范围 [1, 100] 内<br>0 &lt;= Node.val &lt;= 9<br>题目数据保证列表表示的数字不含前导零</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>首先，大家需要知道做题的一个技巧，设置虚拟头结点。这样做的好处就是能够统一化处理头结点和其他节点；同时还能够通过其构造新的链表。<br>例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">dummy -&gt; next = head;</span><br></pre></td></tr></table></figure><br>在本题中，主要是模拟一个加法的操作。新的结果的每一位都是存储对应l1的数和l2的数与进位三个数的和的个位数，然后计算出针对下一位的进位，一直算到结束即可。<br>假设，三个数的和为t。</p><ul><li>对应该位上结果的数为：t % 10</li><li>对应的进位是 t /= 10</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;<span class="comment">//cur表示当前这个和链表的尾结点是哪个点</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">//表示进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 || l2 || t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1) t += l1 -&gt; val, l1 = l1 -&gt; next;<span class="comment">//如果l1存在，那么t加上对应的数值，l1往下走</span></span><br><span class="line">            <span class="keyword">if</span>(l2) t += l2 -&gt; val, l2 = l2 -&gt; next;<span class="comment">//如果l2存在，那么t加上对应的数值，l2往下走</span></span><br><span class="line">            cur -&gt; next = <span class="keyword">new</span> ListNode(t % <span class="number">10</span>);<span class="comment">//创建一个新节点，用于存储对应位置的值，t % 10</span></span><br><span class="line">            cur = cur -&gt; next;<span class="comment">//节点往下更新</span></span><br><span class="line">            t /= <span class="number">10</span>;<span class="comment">//求进位，然后继续循环，直到不符合while循环条件即可</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;<span class="comment">//通过虚拟头结点，轻松找到对应链表的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】LeetCode 1 —— 两数之和（九十三）</title>
      <link href="2021/03/26/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-1-%E2%80%94%E2%80%94-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E4%B9%9D%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>2021/03/26/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91LeetCode-1-%E2%80%94%E2%80%94-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E4%B9%9D%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a><strong>样例</strong></h2><p>示例 1：</p><p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p><p>示例 2：</p><p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]</p><p>示例 3：</p><p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>2 &lt;= nums.length &lt;= 10^3<br>-10^9 &lt;= nums[i] &lt;= 10^9<br>-10^9 &lt;= target &lt;= 10^9<br>只会存在一个有效答案</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>有两个点需要注意即可做出。<br>1、思路：采用y = target - nums[i]，然后判断y是否在nums数组中即可。<br>2、方法要点：这里为了能够达到O(n)的复杂度，使用hash表存储nums的下标和值，然后在hash表中找最快。</p><p>tips:在 C++ 11 中，map的底层实现是平衡树，时间复杂度是O(logn)，unordered_map底层实现是哈希表，时间复杂度是O(1)。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个题可以通过第二个数，然后采用target-第二个数的结果与nums中进行比较得出。当然，为了达到o(n)的复杂度，采用hash表来存储nums的下标和值。C++中的map底层实现是平衡树，时间复杂度是O(logn)；unordered_map底层实现是哈希表，时间复杂度是O(1)的。这是C++11及以上特性的。</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; heap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (heap.count(r)) <span class="keyword">return</span> &#123;heap[r],i&#125;;</span><br><span class="line">            heap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——耍杂技的牛（九十二）</title>
      <link href="2021/03/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E8%80%8D%E6%9D%82%E6%8A%80%E7%9A%84%E7%89%9B%EF%BC%88%E4%B9%9D%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>2021/03/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E8%80%8D%E6%9D%82%E6%8A%80%E7%9A%84%E7%89%9B%EF%BC%88%E4%B9%9D%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>农民约翰的N头奶牛（编号为1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。</p><p>奶牛们不是非常有创意，只提出了一个杂技表演：</p><p>叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。</p><p>奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。</p><p>这N头奶牛中的每一头都有着自己的重量Wi以及自己的强壮程度Si。</p><p>一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。</p><p>您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行输入整数N，表示奶牛数量。</p><p>接下来N行，每行输入两个整数，表示牛的重量和强壮程度，第i行表示第i头牛的重量$W_i$以及它的强壮程度$S_i$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示最大风险值的最小可能值。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤50000 ,<br>1≤$W_i$≤10,000,<br>1≤$S_i$≤1,000,000,000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3<br>10 3<br>2 5<br>3 3</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>2</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>根据题，我们可以有如下思考：<br>            交换前                                 交换后<br>第i头牛   $W<em>1$+…+$W</em>{i-1}$-$S<em>i$ $W_1$+…+$W</em>{i-1}$+$W<em>{i+1}$-$S_i$<br>第i+1头牛 $W_1$+…+$W</em>{i}$-$S<em>{i+1}$ $W_1$+…+$W</em>{i-1}$-$S_{i+1}$</p><p>为了比较大小关系，把公共部分去掉得到<br>            交换前                                 交换后<br>第i头牛   -$S<em>i$                               $W</em>{i+1}$-$S<em>i$<br>第i+1头牛 $W</em>{i}$-$S<em>{i+1}$                    -$S</em>{i+1}$</p><p>要比较的是交换前的两行数值和交换后的两行数值的值，分析如下：<br>当$W<em>i$+$S_i$ &gt; $W</em>{i+1}$+$S_{i+1}$时，交换后危险系数会降低。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">PII cows[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> w,s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        cows[i] = &#123;w+s,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(cows,cows+n);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>,res = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> w = cows[i].second,s = cows[i].first - w;</span><br><span class="line">        res = max(res,sum-s);</span><br><span class="line">        sum+=w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——货仓选址（九十一）</title>
      <link href="2021/03/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80%EF%BC%88%E4%B9%9D%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>2021/03/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80%EF%BC%88%E4%B9%9D%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>在一条数轴上有 N 家商店，它们的坐标分别为 A1~AN。</p><p>现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。</p><p>为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行输入整数N。</p><p>第二行N个整数$A_1$~$A_N$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示距离之和的最小值。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤100000 ,<br>0≤$A_i$≤40000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>4<br>6 2 9 1</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>12</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>根据题，可列以下式子<br>res = min{|a1-x|+|a2-x|+|a3-x|+…+|an-x|}<br>若n为奇数，则x应在其中位数设立货仓<br>若n为偶数，则x应在中间两个数中间设立货仓</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)res+=<span class="built_in">abs</span>(a[i]-a[n/<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 快速选择算法 </tag>
            
            <tag> 绝对值不等式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——排队打水（九十）</title>
      <link href="2021/03/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E9%98%9F%E6%89%93%E6%B0%B4%EF%BC%88%E4%B9%9D%E5%8D%81%EF%BC%89/"/>
      <url>2021/03/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E9%98%9F%E6%89%93%E6%B0%B4%EF%BC%88%E4%B9%9D%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>有 n 个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是$t_i$，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数 n。</p><p>第二行包含 n 个整数，其中第 i 个整数表示第 i 个人装满水桶所花费的时间$t_i$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示最小的等待时间之和。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤$10^5$,<br>1≤$t_i$≤$10^4$</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>7<br>3 6 1 4 2 5 7</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>56</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>根据题意，<br>第一个同学不用等待，等待时间为0；第二个同学等第一个同学的打水时间，为3；第三个同学等待第一个和第二个同学的打水时间，为3+6=9；依次类推。<br>从题中，可以看出此题与之前的石堆合并的问题有些相似，将用时最少的尽量放到前面，最墨迹的尽量放到最后，这样的方法会使得最终的时间最少。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t[i]);</span><br><span class="line">    </span><br><span class="line">    sort(t,t+n);</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) res += t[i] * (n-i<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 排序不等式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——合并果子（八十九）</title>
      <link href="2021/03/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90%EF%BC%88%E5%85%AB%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
      <url>2021/03/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90%EF%BC%88%E5%85%AB%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。</p><p>达达决定把所有的果子合成一堆。</p><p>每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。</p><p>可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。</p><p>达达在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p><p>因为还要花大力气把这些果子搬回家，所以达达在合并果子时要尽可能地节省体力。</p><p>假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使达达耗费的体力最少，并输出这个最小的体力耗费值。</p><p>例如有3种果子，数目依次为1，2，9。</p><p>可以先将1、2堆合并，新堆数目为3，耗费体力为3。</p><p>接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。</p><p>所以达达总共耗费体力=3+12=15。</p><p>可以证明15为最小的体力耗费值。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>输入包括两行，第一行是一个整数n，表示果子的种类数。</p><p>第二行包含n个整数，用空格分隔，第i个整数ai是第i种果子的数目。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。</p><p>输入数据保证这个值小于2^31。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤10000 ,<br>1≤ai≤20000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3<br>1 2 9 </p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>15</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p><img src="/2021/03/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90%EF%BC%88%E5%85%AB%E5%8D%81%E4%B9%9D%EF%BC%89/1.jpg" alt="哈夫曼树"><br>哈夫曼问题<br>1、最小值一定在最深的位置。<br>2、具有最优子结构（通过贪心的方法得到的解是全局最优解）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        heap.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(heap.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = heap.top();heap.pop();</span><br><span class="line">        <span class="keyword">int</span> b = heap.top();heap.pop();</span><br><span class="line">        res+=a+b;</span><br><span class="line">        heap.push(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 二叉堆 </tag>
            
            <tag> Huffman树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——区间覆盖（八十八）</title>
      <link href="2021/03/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96%EF%BC%88%E5%85%AB%E5%8D%81%E5%85%AB%EF%BC%89/"/>
      <url>2021/03/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96%EF%BC%88%E5%85%AB%E5%8D%81%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定N个闭区间[ai,bi]以及一个线段区间[s,t]，请你选择尽量少的区间，将指定线段区间完全覆盖。</p><p>输出最少区间数，如果无法完全覆盖则输出-1。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含两个整数s和t，表示给定线段区间的两个端点。</p><p>第二行包含整数N，表示给定区间数。</p><p>接下来N行，每行包含两个整数ai,bi，表示一个区间的两个端点。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示所需最少区间数。</p><p>如果无解，则输出-1。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤10^5 ,<br>−10^9≤ai≤bi≤10^9,<br>−10^9≤s≤t≤10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>1 5<br>3<br>-1 3<br>2 4<br>3 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>2</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>题解思路：<br>1、将所有区间按照左端点从小到大排序<br>2、从前往后依次枚举每个区间，在所有能覆盖start的区间中，选择一个右端点最大的区间，然后将start更新成右端点的最大值。</p><p>证明方法的正确性<br>    由于可以通过替换法，将最优解的ans的区间替换为算法的方法得出的区间，这样不会增加区间数量，且满足题目要求，因此最后ans==cnt。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Range &amp;W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; W.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st,ed;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;st,&amp;ed);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        range[i] = &#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(range,range+n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i,r=<span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n&amp;&amp;range[j].l&lt;=st)&#123;</span><br><span class="line">            r = max(r,range[j].r);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; st)&#123;</span><br><span class="line">            res = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">if</span>(r &gt;=ed) &#123;</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        st = r;</span><br><span class="line">        i = j<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!success) res = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——区间分组（八十七）</title>
      <link href="2021/03/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4%E5%88%86%E7%BB%84%EF%BC%88%E5%85%AB%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>2021/03/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4%E5%88%86%E7%BB%84%EF%BC%88%E5%85%AB%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定N个闭区间($a_i$,$b_i$)，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。</p><p>输出最小组数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数N，表示区间数。</p><p>接下来N行，每行包含两个整数$a_i$,$b_i$，表示一个区间的两个端点。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示最小组数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤10^5 ,<br>$−10^9$≤$a_i$≤$b_i$≤$10^9$</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3<br>-1 1<br>2 4<br>3 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>2</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>思路如下<br>1、将所有区间按照左端点从小到大排序<br>2、从前往后处理每个区间,判断区间能否将其放到某个现有的组中<br>    (1)L[i] ≤ Max_r.如果不存在这样的组，则开新组，然后再将其放入<br>    (2)L[i] &gt; Max_r.如果存在这样的组(有多个组满足，随便挑一个放入即可)，将其放入该组中，并更新当前组的Max_r</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Range &amp;W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; W.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        range[i] = &#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(range,range+n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> r = range[i];</span><br><span class="line">        <span class="keyword">if</span>(heap.empty()||heap.top() &gt;= r.l) heap.push(r.r);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> t = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            heap.push(r.r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,heap.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——最大不相交区间数量（八十六）</title>
      <link href="2021/03/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%8C%BA%E9%97%B4%E6%95%B0%E9%87%8F%EF%BC%88%E5%85%AB%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>2021/03/02/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%8C%BA%E9%97%B4%E6%95%B0%E9%87%8F%EF%BC%88%E5%85%AB%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定N个闭区间[ai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。</p><p>输出可选取区间的最大数量。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数N，表示区间数。</p><p>接下来N行，每行包含两个整数ai,bi，表示一个区间的两个端点。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示可选取区间的最大数量。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤10^5 ,<br>−10^9≤$a_i$≤$b_i$≤10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3<br>-1 1<br>2 4<br>3 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>2</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>与上题一样的思路。<br>思路如下：<br>1、将每个区间按右端点从小到大排序<br>2、从前往后依次枚举每个区间。<br>    如果当前区间已经被覆盖，则直接pass。否则选择当前区间的右端点。</p><p>简单证明<br>首先，我们选择的cnt是可行的方案数，ans是所有可行方案的最大值，因此ans≥cnt。<br>然后，按照选择思路，会选出cnt个点，所有的区间每一个区间至少包含一个我们选择的点，因此通过反证法，假设ans大于cnt，就意味着可以选择出比cnt更多相互之间没有交集的区间，也就需要ans个点，又因为cnt满足了每个区间至少包含一个选择的点，所以ans＞cnt不成立，因此只能是ans=cnt。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Range &amp;W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; W.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(range, range+n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; range[i].l)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            ed = range[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——区间选点（八十五）</title>
      <link href="2021/03/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9%EF%BC%88%E5%85%AB%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>2021/03/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9%EF%BC%88%E5%85%AB%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定N个闭区间[ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。</p><p>输出选择的点的最小数量。</p><p>位于区间端点上的点也算作区间内。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数N，表示区间数。</p><p>接下来N行，每行包含两个整数ai,bi，表示一个区间的两个端点。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示所需的点的最小数量。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤10^5 ,<br>−10^9≤ai≤bi≤10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3<br>-1 1<br>2 4<br>3 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>2</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>贪心的特点是每次选择均选择在当前情况下的最好选择，没有对全局有思考，因此算法在总体上有些短视。<br>思路如下：<br>1、将每个区间按右端点从小到大排序<br>2、从前往后依次枚举每个区间。<br>    如果当前区间已经被覆盖，则直接pass。否则选择当前区间的右端点。</p><p>可以证明，根据这种方法一定能够得到最优解。<br>假设，ans是我们最后要求的答案，cnt是我们求出的可行点数的和。<br>首先，ans≤cnt，因为ans是可行点数中最小值。<br>然后，又因为cnt的选择是选择右端点，且若区间覆盖则会被pass掉，这就导致每个点之间均无任何重叠的可能性，因此会找到cnt个点对应的相互没有交集的区间，因此cnt≤ans，因此可以证明，cnt=ans。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Range &amp;W)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; W.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;range[i].l, &amp;range[i].r);</span><br><span class="line"></span><br><span class="line">    sort(range, range + n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (range[i].l &gt; ed)</span><br><span class="line">        &#123;</span><br><span class="line">            res ++ ;</span><br><span class="line">            ed = range[i].r;<span class="comment">//上一次选中的区间的右端点的坐标。当前备选区间的左端点如果小于等于ed，那么说明两个区间有交集，那么上一次选中区间的右端点也能包含在当前备选区间里，所以这个区间不必产生新的点就可以满足题意，所以被舍掉，不用考虑。只有左端点大于ed的区间才会产生新的点，只有遇到这样的区间计数器才会加1，同时ed要更新。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——滑雪（八十四）</title>
      <link href="2021/03/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%BB%91%E9%9B%AA%EF%BC%88%E5%85%AB%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>2021/03/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%BB%91%E9%9B%AA%EF%BC%88%E5%85%AB%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个R行C列的矩阵，表示一个矩形网格滑雪场。<br>矩阵中第 i 行第 j 列的点表示滑雪场的第 i 行第 j 列区域的高度。<br>一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。<br>当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。</p><p>下面给出一个矩阵作为例子：<br>1  2  3  4 5</p><p>16 17 18 19 6</p><p>15 24 25 20 7</p><p>14 23 22 21 8</p><p>13 12 11 10 9</p><p>在给定矩阵中，一条可行的滑行轨迹为24-17-2-1。<br>在给定矩阵中，最长的滑行轨迹为25-24-23-…-3-2-1，沿途共经过25个区域。<br>现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含两个整数R和C。<br>接下来R行，每行包含C个整数，表示完整的二维矩阵。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示可完成的最长滑雪长度。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤R,C≤300 ,<br>0≤矩阵中整数≤10000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>5 5<br>1 2 3 4 5<br>16 17 18 19 6<br>15 24 25 20 7<br>14 23 22 21 8<br>13 12 11 10 9</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>25</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>一、状态表示<br>1、集合<br>    f[i,j]  所有从(i,j)开始滑的路径<br>2、属性<br>    路径的最大长度<br>二、状态计算<br><img src="/2021/03/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%BB%91%E9%9B%AA%EF%BC%88%E5%85%AB%E5%8D%81%E5%9B%9B%EF%BC%89/1.jpg" alt><br>往右划的最大值：f[i,j+1]+1  其他部分类推即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;v = f[x][y];</span><br><span class="line">    <span class="keyword">if</span>(v!=<span class="number">-1</span>) <span class="keyword">return</span> v;</span><br><span class="line">    v = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a=x+dx[i],b=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=<span class="number">1</span>&amp;&amp;a&lt;=n&amp;&amp;b&gt;=<span class="number">1</span>&amp;&amp;b&lt;=m&amp;&amp;h[a][b]&lt;h[x][y])&#123;</span><br><span class="line">            v = max(v,dp(a,b)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            res=max(res,dp(i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——没有上司的舞会（八十三）</title>
      <link href="2021/03/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A%EF%BC%88%E5%85%AB%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>2021/03/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A%EF%BC%88%E5%85%AB%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>Ural大学有N名职员，编号为1~N。</p><p>他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。</p><p>每个职员有一个快乐指数，用整数 Hi 给出，其中 1≤i≤N。</p><p>现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。</p><p>在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行一个整数N。</p><p>接下来N行，第 i 行表示 i 号职员的快乐指数Hi。</p><p>接下来N-1行，每行输入一对整数L, K,表示K是L的直接上司。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出最大的快乐指数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤6000 ,<br>−128≤Hi≤127</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>7<br>1<br>1<br>1<br>1<br>1<br>1<br>1<br>1 3<br>2 3<br>6 4<br>7 4<br>4 5<br>3 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>5</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>一、状态表示<br>1、集合<br>    f[u,0]  所有从以u为根的子树中选择，并且不选择u这个点的方案<br>    f[u,1]  所有从以u为根的子树中选择，并且选择u这个点的方案<br>2、属性<br>    最大的快乐度<br>二、状态计算<br>    f[u,0] = Σ max(f[Si,0],f[Si,1])<br>    f[u,1] = Σ f(Si,0)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> happy[N];</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> has_father[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx]=h[a],h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = happy[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u];i!=<span class="number">-1</span>;i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        dfs(j);</span><br><span class="line">        f[u][<span class="number">0</span>] += max(f[j][<span class="number">0</span>],f[j][<span class="number">1</span>]);</span><br><span class="line">        f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;happy[i]);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        has_father[a] = <span class="literal">true</span>;</span><br><span class="line">        add(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(has_father[root]) root++;</span><br><span class="line">    </span><br><span class="line">    dfs(root);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,max(f[root][<span class="number">0</span>],f[root][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——最短Hamilton路径（八十二）</title>
      <link href="2021/02/26/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84%EF%BC%88%E5%85%AB%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>2021/02/26/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84%EF%BC%88%E5%85%AB%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行输入整数n。</p><p>接下来n行每行n个整数，其中第i行第j个整数表示点i到j的距离（记为a[i,j]）。</p><p>对于任意的x,y,z，数据保证 a[x,x]=0，a[x,y]=a[y,x] 并且 a[x,y]+a[y,z]&gt;=a[x,z]。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示最短Hamilton路径的长度。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤20<br>0≤a[i,j]≤$10^7$</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>5<br>0 2 4 5 1<br>2 0 6 5 3<br>4 6 0 8 3<br>5 5 8 0 5<br>1 3 3 5 0</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>18</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态压缩DP </tag>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——整数划分（七十九）</title>
      <link href="2021/02/26/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%EF%BC%88%E4%B8%83%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
      <url>2021/02/26/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%EF%BC%88%E4%B8%83%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>一个正整数n可以表示成若干个正整数之和，形如：n=$n_1$+$n_2$+…+$n_k$，其中$n_1$≥$n_2$≥…≥$n_k$,k≥1。</p><p>我们将这样的一种表示称为正整数n的一种划分。</p><p>现在给定一个正整数n，请你求出n共有多少种不同的划分方法。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>共一行，包含一个整数n。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，包含一个整数，表示总划分数量。</p><p>由于答案可能很大，输出结果请对$10^9$+7取模。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤1000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>7</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>根据题，可以思考为由体积为1到n，n个物品，然后有一个体积为n的背包，求一个恰好装满背包的方案数（每种物品可以用无限次）。<br>一、状态表示<br>1、集合<br>    所有从1到i中选，总体积恰好是j的选择方法<br>2、属性<br>    方案数（数量）<br>二、状态计算<br>    根据背包问题，根据最后第i个物品选择的数量划分集合。<br>    f[i][j] = f[i-1][j]+f[i][j-i]   </p><p>若当集合改为：所有总和是i，并且恰好表示成j个数的和的方案时，也能做，这里略过。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;=n;j++)&#123;</span><br><span class="line">            f[j] = (f[j]+f[j-i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 计数类DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——石子合并（七十八）</title>
      <link href="2021/02/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%EF%BC%88%E4%B8%83%E5%8D%81%E5%85%AB%EF%BC%89/"/>
      <url>2021/02/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%EF%BC%88%E4%B8%83%E5%8D%81%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>设有N堆石子排成一排，其编号为1，2，3，…，N。</p><p>每堆石子有一定的质量，可以用一个整数来描述，现在要将这N堆石子合并成为一堆。</p><p>每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p><p>例如有4堆石子分别为 1 3 5 2， 我们可以先合并1、2堆，代价为4，得到4 5 2， 又合并 1，2堆，代价为9，得到9 2 ，再合并得到11，总代价为4+9+11=24；</p><p>如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22。</p><p>问题是：找出一种合理的方法，使总的代价最小，输出最小代价。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行一个数N表示石子的堆数N。</p><p>第二行N个数，表示每堆石子的质量(均不超过1000)。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示最小代价。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤300</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>4<br>1 3 5 2</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>22</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>一、状态表示 f(i,j)<br>1、集合<br>    所有将i到j区间合并成一堆的方案的集合<br>2、属性<br>    方案的最小代价<br>二、状态计算<br><img src="/2021/02/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%EF%BC%88%E4%B8%83%E5%8D%81%E5%85%AB%EF%BC%89/1.jpg" alt><br>最终结果为 min{f(i,k)+f(k+1,j)+s[j]-s[i-1]}，且k的范围是i到j-1。  // s[i]代表从0开始到i的代价和</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> s[N]; <span class="comment">//前缀和</span></span><br><span class="line"><span class="keyword">int</span> f[N][N];<span class="comment">//状态方程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n;i++) </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt;s[i],s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+len<span class="number">-1</span>;</span><br><span class="line">            f[i][j] = <span class="number">1e8</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i;k&lt;j;k++)&#123;</span><br><span class="line">                f[i][j] = min(f[i][j],f[i][k]+f[k+<span class="number">1</span>][j]+s[j]-s[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 区间DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——编辑距离（七十七）</title>
      <link href="2021/02/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%88%E4%B8%83%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>2021/02/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%88%E4%B8%83%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定n个长度不超过10的字符串以及m次询问，每次询问给出一个字符串和一个操作次数上限。</p><p>对于每次询问，请你求出给定的n个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。</p><p>每个对字符串进行的单个字符的插入、删除或替换算作一次操作。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含两个整数n和m。</p><p>接下来n行，每行包含一个字符串，表示给定的字符串。</p><p>再接下来m行，每行包含一个字符串和一个整数，表示一次询问。</p><p>字符串中只包含小写字母，且长度均不超过10。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出共m行，每行输出一个整数作为结果，表示一次询问中满足条件的字符串个数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n,m≤1000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3 2<br>abc<br>acd<br>bcd<br>ab 1<br>acbd 2</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>1<br>3</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是针对最短编辑距离的简单变形，状态表示基本类似，只是需要多算几步，多加几个判断条件，符合当前的题目的要求即可。具体，看代码就好了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15</span>, M = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//n 总共的字符串的个数  m为询问个数</span></span><br><span class="line"><span class="keyword">int</span> f[N][N];<span class="comment">// 状态函数</span></span><br><span class="line"><span class="keyword">char</span> str[M][N]; <span class="comment">//存储字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit_distance</span><span class="params">(<span class="keyword">char</span> a[],<span class="keyword">char</span> b[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> la = <span class="built_in">strlen</span>(a+<span class="number">1</span>),lb = <span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=lb;i++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=la;i++) f[i][<span class="number">0</span>] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=la;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lb;j++)&#123;</span><br><span class="line">            f[i][j] = min(f[i<span class="number">-1</span>][j]+<span class="number">1</span>,f[i][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">            f[i][j] = min(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]+(a[i]!=b[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> f[la][lb];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str[i]+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">char</span> s[N];</span><br><span class="line">        <span class="keyword">int</span> limit;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,s+<span class="number">1</span>,&amp;limit);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edit_distance(str[i],s) &lt;= limit)</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——最短编辑距离（七十六）</title>
      <link href="2021/02/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%88%E4%B8%83%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>2021/02/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%88%E4%B8%83%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定两个字符串A和B，现在要将A经过若干操作变为B，可进行的操作有：</p><ul><li>删除–将字符串A中的某个字符删除。</li><li>插入–在字符串A的某个位置插入某个字符。</li><li>替换–将字符串A中的某个字符替换为另一个字符。</li></ul><p>现在请你求出，将A变为B至少需要进行多少次操作</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n，表示字符串A的长度。</p><p>第二行包含一个长度为n的字符串A。</p><p>第三行包含整数m，表示字符串B的长度。</p><p>第四行包含一个长度为m的字符串B。</p><p>字符串中均只包含大写字母。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示最少操作次数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n,m≤1000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>10<br>AGTCTGACGC<br>11<br>AGTAAGTAGGC</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>4</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>一、状态表示<br>1、集合<br>    所有将a[1~i]变成b[1~j]的操作方式<br>2、属性<br>    最小的步骤数<br>二、状态计算<br><img src="/2021/02/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%88%E4%B8%83%E5%8D%81%E5%85%AD%EF%BC%89/1.jpg" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m; <span class="comment">//两个字符串的长度</span></span><br><span class="line"><span class="keyword">char</span> a[N],b[N]; <span class="comment">//存储两个字符串</span></span><br><span class="line"><span class="keyword">int</span> f[N][N]; <span class="comment">//存储状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,a+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;m,b+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化边界情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=m;i++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=n;i++) f[i][<span class="number">0</span>] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=m;j++)&#123;</span><br><span class="line">            f[i][j] = min(f[i<span class="number">-1</span>][j]+<span class="number">1</span>,f[i][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) f[i][j] = min(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = min(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——最长公共子序列（七十五）</title>
      <link href="2021/02/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%83%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>2021/02/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%83%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定两个长度分别为N和M的字符串A和B，求既是A的子序列又是B的子序列的字符串长度最长是多少。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含两个整数N和M。</p><p>第二行包含一个长度为N的字符串，表示字符串A。</p><p>第三行包含一个长度为M的字符串，表示字符串B。</p><p>字符串均由小写字母构成。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示最大长度。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N,M≤1000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>4 5<br>acbd<br>abedc</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>3</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>一、状态表示 f(i,j)<br>1、集合<br>    所有A(1~i)与B(1~j)的公共子序列的集合<br>2、属性<br>    全部子序列的最大值<br>二、状态计算<br> <img src="/2021/02/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%83%E5%8D%81%E4%BA%94%EF%BC%89/1.jpg" alt></p><p> 00：f[i-1, j-1]<br> 01：f[i-1, j]<br> 10：f[i, j-1]<br> 11：if a[i]==b[j]  f[i-1,j-1]+1</p><p> 比较大小，可以重复，但不能遗漏。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; a + <span class="number">1</span> &gt;&gt; b + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=m; j++)&#123;</span><br><span class="line">            f[i][j] = max(f[i - <span class="number">1</span>][j],f[i][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) f[i][j] = max(f[i][j],f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——最长上升子序列二（七十四）</title>
      <link href="2021/02/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E4%BA%8C%EF%BC%88%E4%B8%83%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>2021/02/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E4%BA%8C%EF%BC%88%E4%B8%83%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数N。<br>第二行包含N个整数，表示完整序列。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示最大长度。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤100000 ，<br>$−10^9$≤数列中的数≤$10^9$</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>7<br>3 1 2 1 8 5 6</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>4</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>这里继承上篇最长上升子序列的内容，添加了优化方案。<br>首先，之前的计算是仍然存在冗余的，具体举个例子来分析一下：如果3能放在8的前面，那么就可以知道，1一定可以放到8的前面。<br>因此，这里针对第i个元素的最长上升子序列，就可以有如下思考：计算出i之前，长度依次为1~i-1的每个上升子序列结尾能够存放的最小值。这样做的好处就是，当求第a[i]的最长上升子序列时，只需要找出比a[i]小的最大的上升子序列的结尾的数对应的子序列的长度+1就是题目所求。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N]; <span class="comment">//存储每个数</span></span><br><span class="line"><span class="keyword">int</span> q[N]; <span class="comment">//存储不同长度下上升子序列的结尾最小值，应该严格单调递增</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">//存储当前的最大长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &lt; a[i]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = max(len, r + <span class="number">1</span>);</span><br><span class="line">        q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——最长上升子序列（七十三）</title>
      <link href="2021/02/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%83%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>2021/02/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%83%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数N。<br>第二行包含N个整数，表示完整序列。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示最大长度。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤1000 ，<br>$−10^9$≤数列中的数≤$10^9$</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>7<br>3 1 2 1 8 5 6</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>4</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>一、状态表示 f[i]<br>1、集合<br>    所有以第i个数结尾的上升子序列<br>2、属性<br>    集合中每一个上升子序列长度的最大值</p><p>二、状态计算<br> 以第i-1位上的数来划分集合，可以有如下划分：<br> 0/a[1]/a[2]/…/a[i-1]<br>但是，因为要求的是上升子序列，因此上述i类不一定全部存在。</p><p>f[i] = max(f[j]+1),j=0,1,2,…,i-1</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= n; i++)&#123;</span><br><span class="line">        f[i] = <span class="number">1</span>; <span class="comment">//只有a[i]一个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])</span><br><span class="line">                f[i] = max(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res = max(res,f[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> 最长上升子序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——数字三角形（七十二）</title>
      <link href="2021/02/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E4%B8%83%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>2021/02/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E4%B8%83%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。<br>        7<br>      3   8<br>    8   1   0<br>  2   7   4   4<br>4   5   2   6   5</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n，表示数字三角形的层数。</p><p>接下来n行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示最大的路径数字和。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤500 ,<br>−10000≤三角形中的整数≤10000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>5<br>7<br>3 8<br>8 1 0<br>2 7 4 4<br>4 5 2 6 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>30</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>对本题思考发现，如果从上往下思考，会导致每个数考虑从左边下来还是右边下来，这样导致一些特判的发生，会写很多边界判定代码。若从下往上思考，则每个数考虑从哪个方向上来的，这样就不需要很多特判了，除了最后一行的数之外，其他行均有下方两个方向上来。</p><p>一、状态表示——f(i,j)<br>1、集合<br>    从底向上走到（i，j）所有路线的集合<br>2、属性<br>    路线数字和最大值<br>二、状态计算（集合划分）<br>max{f(i+1,j)+w(i,j),f(i,j+1)+w(i,j)}</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[N][N],f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[n][i] = w[n][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i ; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=i; j++)&#123;</span><br><span class="line">            f[i][j] = max(f[i+<span class="number">1</span>][j]+w[i][j],f[i+<span class="number">1</span>][j+<span class="number">1</span>]+w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——分组背包问题（七十一）</title>
      <link href="2021/02/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%83%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>2021/02/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%83%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>有 N 组物品和一个容量是 V 的背包。</p><p>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 $v<em>{ij}$，价值是 $w</em>{ij}$，其中 i 是组号，j 是组内编号。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p><p>输出最大价值。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。</p><p>接下来有 N 组数据：</p><ul><li>每组数据第一行有一个整数 $S_i$，表示第 i 个物品组的物品数量；</li><li>每组数据接下来有 $S<em>i$ 行，每行有两个整数 $v</em>{ij}$,$w_{ij}$，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；</li></ul><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示最大价值。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>0&lt;N,V≤100<br>0&lt;$S<em>i$≤100<br>0&lt;$v</em>{ij}$,$w_{ij}$≤100</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3 5<br>2<br>1 2<br>2 4<br>1<br>3 4<br>1<br>4 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>8</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>1、状态表示<br>集合：等价于从前i组物品中选择，且总体积不大于j。<br>属性：求集合中的最大值。</p><p>2、伪代码：<br>for(int i = 0;i<n;i++){ for(int j="m;">=v; j—){<br>        f[j] = max(f[j],f[j - v[0]] + w[0],f[j - v[1]] + w[1],…,f[j - v[s-1]] + w[s-1]);<br>    }<br>}</n;i++){></p><p>result = f[m]</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> f[N],v[N],w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s; j++) <span class="built_in">cin</span> &gt;&gt; v[j] &gt;&gt; w[j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; s; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v[k]) f[j] = max(f[j],f[j-v[k]] + w[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包问题 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——多重背包问题二（七十）</title>
      <link href="2021/02/22/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%BA%8C%EF%BC%88%E4%B8%83%E5%8D%81%EF%BC%89/"/>
      <url>2021/02/22/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%BA%8C%EF%BC%88%E4%B8%83%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>有 N 种物品和一个容量是 V 的背包。</p><p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示最大价值。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>0&lt;N≤1000<br>0&lt;V≤2000<br>0&lt;vi,wi,si≤2000</p><p>提示：<br>本题考查多重背包的二进制优化方法。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>4 5<br>1 2 3<br>2 4 1<br>3 4 3<br>4 5 2</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>10</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题是将多重背包问题拆分成为01背包问题。思路如下：<br>因为每种物品，假设为第i件物品，有s[i]个，那么将之看做有s[i]个物品，那么总体就一共有Σ(i=0,…,n)s[i] 个物品，这样就转化为了每个物品仅可用一次的01背包问题。但是，由于按照这种思路拆分非常麻烦，根据题目中给出的数量，若有1000件物品，每件物品有2000个，那么最多一共2000000个物品，按照体积最大计算，复杂度在10的9次方左右，在C++中会溢出。因此需要采用一种2进制的拆分方法。</p><p>二进制拆分方法的原问题如下：<br>给定任意一个数，问最少可以将其分成多少个数，且每个数可选可不选，将从0至该数的内的任何数进行表示。</p><p>假设s为给定数字，那么最少需要log以2为底的s的对数（向上取整）个数来参与表示。同时，给出两个例子，来让大家辅助思考。<br>例子1：<br>s=7,最少需要有3个数表示，分别为1，2，4<br>0=三个数不选<br>1=1<br>2=2<br>3=1+2<br>4=4<br>5=1+4<br>6=2+4<br>7=1+2+4</p><p>例子2：<br>s=10,最少需要4个数表示，分别为1，2，4，3  （因为1，2，4可以表示0-7，那么再加上3就可以表示0-10的数了）<br>8=1+3+4<br>9=2+3+4<br>10=1+2+3+4</p><p>这里补充一个小常识，在C++中一秒大概完成10的7次方次的操作，根据此可以对自己算法的复杂度进行估计。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Good</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Good&gt; goods;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;n &gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v,w,s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s; k*=<span class="number">2</span>)&#123;</span><br><span class="line">            s-=k;</span><br><span class="line">            goods.push_back(&#123;v*k,w*k&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">0</span>) goods.push_back(&#123;v*s,w*s&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> good:goods)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j&gt;=good.v; j--)</span><br><span class="line">            f[j] = max(f[j],f[j - good.v]+good.w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包问题 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——多重背包问题（六十九）</title>
      <link href="2021/02/22/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E5%85%AD%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
      <url>2021/02/22/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E5%85%AD%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>有 N 种物品和一个容量是 V 的背包。</p><p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示最大价值。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>0&lt;N,V≤100<br>0&lt;vi,wi,si≤100</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>4 5<br>1 2 3<br>2 4 1<br>3 4 3<br>4 5 2</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>10</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题仍然需要使用动态规划的方法进行求解。<br>首先，f[i]代表总体积为i的情况下的最大价值<br>伪代码表示如下：<br>for(int i = 0; i &lt; n; i++){<br>    for(int j = m; j &gt;= v[i]; j—)<br>        f[j] = max(f[j], f[j-v[i]] + w[i], f[j - 2v[i]] + 2w[i], …);<br>}</p><p>1、f[i] = 0<br>最终答案为f[m]</p><p>2、f[0] = 0, f[i] = -INF(i!=0)<br>最终答案为(f[0,…,m])</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v,w,s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt;w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k&lt;=s &amp;&amp; k*v&lt;=j;k++)</span><br><span class="line">                f[j] = max(f[j],f[j - k * v] + k * w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包问题 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——完全背包问题（六十八）</title>
      <link href="2021/02/21/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E5%85%AD%E5%8D%81%E5%85%AB%EF%BC%89/"/>
      <url>2021/02/21/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E5%85%AD%E5%8D%81%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。</p><p>第 i 种物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示最大价值。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>10</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>根据动态规划思想，有如下内容：<br>一、状态表示 f(i,j)<br>1、本题的相关集合：所有只从前i个物品中选，总体积不超过j的方案的集合<br>2、本题的相关属性：最大价值<br>二、状态计算<br>1、枚举状态</p><ul><li>状态1：在f(i,j)中，所有仅选择0个第i个物品的方案的集合</li><li>状态2：在f(i,j)中，所有仅选择1个第i个物品的方案的集合</li><li>状态3：在f(i,j)中，所有仅选择2个第i个物品的方案的集合</li><li>…</li><li>状态k：在f(i,j)中，所有仅选择k个第i个物品的方案的集合<br>2、最终计算<br>将上述的k个状态分别求出来最大价值，在其中求最大即为答案。<br>f(i, j) = max(f(i-1,j), f(i-1,j-Vi)+Wi, f(i-1,j-2Vi)+2Wi, …)<br>又由于：<br>f(i, j-Vi) = max(f(i-1,j-Vi), f(i-1,j-2Vi)+Wi, …),与f(i, j)仅差一个Wi，因此，可推导出最终递推公式：<br>f(i, j) = max(f(i-1,j),f(i, j-Vi)+Wi)</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、01背包:  f[i][j] = max(f[i-1][j],f[i-1][j-v]+w)</span></span><br><span class="line"><span class="comment">2、完全背包:f[i][j] = max(f[i-1][j],f[i][j-v]+w)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//朴素做法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i]) f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = v[i]; j &lt;= m; j++)</span><br><span class="line">            f[j] = max(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——01背包问题（六十七）</title>
      <link href="2021/02/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%9401%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E5%85%AD%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>2021/02/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%9401%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E5%85%AD%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p><p>第 i 件物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示最大价值。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>8</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>背包问题的状态表示：<br>令，f[i][j] 表示只看前i个物品，总体积是j的情况下的最大价值。<br>那么，result = max{f[n][0~V]}</p><p>f[i][j]存在以下两种情况:<br>case1 不选第i件物品，f[i][j] = f[i - 1][j]<br>case2 选第i件物品，f[i][j] = f[i - 1][j - V[i]] + w[i]<br>f[i][j] = max{case1, case2}</p><p>设置f[0][0] = 0</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">////采用二维数组的算法代码</span></span><br><span class="line"><span class="comment">// #include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const int N = 1010;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int n,m;</span></span><br><span class="line"><span class="comment">// int f[N][N];</span></span><br><span class="line"><span class="comment">// int v[N],w[N];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int main()&#123;</span></span><br><span class="line"><span class="comment">//     cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line"><span class="comment">//     for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     for(int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">//         for(int j = 0; j&lt;= m; j++)&#123;</span></span><br><span class="line"><span class="comment">//             f[i][j] = f[i - 1][j];</span></span><br><span class="line"><span class="comment">//             if(j &gt;= v[i]) f[i][j] = max(f[i][j],f[i-1][j-v[i]] + w[i]);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//     int res = 0;</span></span><br><span class="line"><span class="comment">//     for(int i = 0; i&lt;= m; i++) res = max(res,f[n][i]);</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     cout &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//采用一维数组的算法代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> f[N];<span class="comment">//表示体积为i的情况下的最大价值</span></span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j&gt;= v[i]; j--) </span><br><span class="line">            f[j] = max(f[j],f[j-v[i]] + w[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    f[0] = 0;</span></span><br><span class="line"><span class="comment">    当f[i] = 0时，f[m] 体积代表小于等于m的情况下的最大价值</span></span><br><span class="line"><span class="comment">    当f[i] = -INF时，f[m]体积代表等于m的情况下的最大价值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【理财】对基金理财的一些自己的笔记</title>
      <link href="2021/02/14/%E3%80%90%E7%90%86%E8%B4%A2%E3%80%91%E5%AF%B9%E5%9F%BA%E9%87%91%E7%90%86%E8%B4%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/14/%E3%80%90%E7%90%86%E8%B4%A2%E3%80%91%E5%AF%B9%E5%9F%BA%E9%87%91%E7%90%86%E8%B4%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>这里基于观看B站up主“二狗学长好”的一期视频中的内容整理成为自己的笔记。<br>原视频链接请点击<a href="https://www.bilibili.com/video/BV1ci4y1c72i?t=1078">这里</a></p><h2 id="对支付宝基金界面的讲解"><a href="#对支付宝基金界面的讲解" class="headerlink" title="对支付宝基金界面的讲解"></a>对支付宝基金界面的讲解</h2><p><img src="/2021/02/14/%E3%80%90%E7%90%86%E8%B4%A2%E3%80%91%E5%AF%B9%E5%9F%BA%E9%87%91%E7%90%86%E8%B4%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AC%94%E8%AE%B0/1.png" alt="支付宝理财基金界面"></p><ol><li>这是基金的名称，在支付宝的基金搜索框中可以对其进行搜索</li><li>这是基金的代号，在任何一款基金的app中，都可以根据代号找到这款基金，这是这个基金的唯一标识</li><li>这是基金的类型，基金一般有4种类型，分别是股票型基金、债券型基金、货币型基金和混合型基金，其中混合型基金和股票型基金均为高风险、高收益的基金类型</li><li>这里是该基金主要布局的行业</li><li>这里是指如果前期投资1万元，一年后受益为1.1万元左右</li><li>这里是指今日与昨日对比的涨幅情况，红色为涨绿色为跌</li><li>这里是该只基金的净值，从基金成立初日开始，净值为1，净值会根据每日的上涨和下跌进行浮动，与股价的含义类似</li><li>净值估算是，就是通过持仓判断其基金的涨跌情况，一个判断今日是否买入基金的依据。</li><li>这里是可以根据时间，将基金的涨幅根据时间段展现出来，也就是走势图</li><li>这里是对于9的表格化展现，也是记录基金的涨幅</li><li>这里的基金档案是该基金的持有规模，一般建议规模在10个亿以上的基金比较好</li><li>这里成立时间建议考虑至少3-5年以上的基金</li><li>这里的开放买入和开放卖出的意思是允许随时买、随时卖，但，基金不一定支持随时买随时卖的情况，有些是定期的基金，意味着买入后可能需要三个月或者六个月之后才允许卖出，这里需要注意</li><li>定投是指在固定的时间间隔内，买入固定份额或固定价格的基金</li><li>买入需要注意是需要费率的，从图中可以看出，买入的费率之前为1.5%，在支付宝中，打了1折，为0.15%。</li><li>每日下午三点前买入基金，那么从今日开始计算受益，若买入在下午三点后买入，则受益从明日下午三点后收盘进行计算。</li><li>这里可以看到，买入的金额越大，费率越低，不过一般人没那么多钱。。。</li><li>这里是指，卖出也存在费率，持有时间越长，卖出费率越低</li></ol><h2 id="PE指标"><a href="#PE指标" class="headerlink" title="PE指标"></a>PE指标</h2><p>股票的市盈率 (Price-to-Earning Ratio，P/E 或 PER)，又称为市盈率，指每股市价除以每股盈余 (Earnings Per Share，EPS)，通常作为股票是便宜抑或昂贵的指标 (通货膨胀会使每股收益虚增，从而扭曲市盈率的比较价值)。市盈率把企业的股价与其制造财富的能力联系起来。<br>这里的指标，是一种判断大盘的走势的关键性指标，一般不代表具体行业。</p><h2 id="夏普比率"><a href="#夏普比率" class="headerlink" title="夏普比率"></a>夏普比率</h2><p>在金融领域，夏普比率（英语：Sharpe ratio），又叫夏普指数（Sharpe index），衡量的是一项投资（例如证券或投资组合）在对其调整风险后，相对于无风险资产的表现。它的定义是投资收益与无风险收益之差的期望值，再除以投资标准差（即其波动性）。它代表投资者额外承受的每一单位风险所获得的额外收益。<br>夏普比率是一种衡量基金赚钱能力的指标，夏普比率越高，赚钱能力越强。</p><h2 id="最大回撤"><a href="#最大回撤" class="headerlink" title="最大回撤"></a>最大回撤</h2><p>最大回辙是指最高点和最低点最多亏损的比率。</p>]]></content>
      
      
      <categories>
          
          <category> 理财 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基金 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——线性同余方程（六十六）</title>
      <link href="2021/02/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%EF%BC%88%E5%85%AD%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>2021/02/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%EF%BC%88%E5%85%AD%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定n组数据ai,bi,mi，对于每组数求出一个xi，使其满足ai∗xi≡bi(mod mi)，如果无解则输出impossible。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n。</p><p>接下来n行，每行包含一组数据ai,bi,mi。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p><a href="https://oi-wiki.org/math/crt/">中国剩余定理</a></p><p>输出共n行，每组数据输出一个整数表示一个满足条件的xi，如果无解则输出impossible。</p><p>每组数据结果占一行，结果可能不唯一，输出任意一个满足条件的结果均可。</p><p>输出答案必须在int范围之内。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤10^5,<br>1≤ai,bi,mi≤2*10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>2<br>2 3 6<br>4 3 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>impossible<br>-3</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>ax ≡ b(mod m) 等价于存在一个整数y，使得 ax = my + b，将式子转化便成为了ax + my = b，就转化为了扩展欧几里得算法的内容。注意有解的前提是b要整除a和m的最大公约数，如果不能则无解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n -- )&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a,&amp;b,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">int</span> d = exgcd(a, m, x, y);</span><br><span class="line">        <span class="keyword">if</span>(b % d) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (LL)x * (b / d) % m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性同余方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——扩展欧几里得算法（六十五）</title>
      <link href="2021/01/31/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>2021/01/31/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定n对正整数ai,bi，对于每对数，求出一组xi,yi，使其满足ai<em>xi+bi</em>yi=gcd(ai,bi)。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n。</p><p>接下来n行，每行包含两个整数ai,bi。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出共n行，对于每组ai,bi，求出一组满足条件的xi,yi，每组结果占一行。</p><p>本题答案不唯一，输出任意满足条件的xi,yi均可。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤10^5 ,<br>1≤ai,bi≤2*10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>2<br>4 6<br>8 18</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>-1 1<br>-2 1</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>扩展欧几里德算法是欧几里得算法的扩展。</p><p>定理：若a和b为正整数，则存在整数x,y使得gcd(a,b)=ax+by;</p><p>换句话说gcd(a,b)可以表示为a,b的整洗数线性组合，例如：gcd(6,14)=2,而2=(-2)x6+1x14.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n -- )&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a,&amp;b);</span><br><span class="line">        </span><br><span class="line">        exgcd(a, b, x, y);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 扩展欧几里得算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——快速幂求逆元（六十四）</title>
      <link href="2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B1%82%E9%80%86%E5%85%83%EF%BC%88%E5%85%AD%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B1%82%E9%80%86%E5%85%83%EF%BC%88%E5%85%AD%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定n组ai,pi，其中pi是质数,求ai模pi的乘法逆元，若逆元不存在则输出impossible。</p><p>注意：请返回在0∼p−1之间的逆元。</p><p><img src="/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B1%82%E9%80%86%E5%85%83%EF%BC%88%E5%85%AD%E5%8D%81%E5%9B%9B%EF%BC%89/1.jpg" alt></p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n。</p><p>接下来n行，每行包含一个数组ai,pi，数据保证pi是质数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出共n行，每组数据输出一个结果，每个结果占一行。</p><p>若ai模pi的乘法逆元存在，则输出一个整数，表示逆元，否则输出impossible。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤10^5 ,<br>1≤ai,pi≤2*10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3<br>4 3<br>8 5<br>6 3</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>1<br>2<br>impossible</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p><img src="/2021/01/30/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B1%82%E9%80%86%E5%85%83%EF%BC%88%E5%85%AD%E5%8D%81%E5%9B%9B%EF%BC%89/2.jpg" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a^k % p</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>; <span class="comment">//把k的末位删掉</span></span><br><span class="line">        a = (LL)a*a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a,&amp;p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = qmi(a, p - <span class="number">2</span>, p);</span><br><span class="line">        <span class="keyword">if</span>(a % p) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——快速幂（六十三）</title>
      <link href="2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%88%E5%85%AD%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%88%E5%85%AD%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定n组ai,bi,pi，对于每组数据，求出ai^bi mod pi的值。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n。</p><p>接下来n行，每行包含三个整数ai,bi,pi。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>对于每组数据，输出一个结果，表示ai^bi mod pi的值。</p><p>每个结果占一行</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤100000 ,<br>1≤ai,bi,pi≤2*10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>2<br>3 2 5<br>4 3 9</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>4<br>1</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p><a href="https://oi-wiki.org/math/quick-pow/">快速幂解释</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a^k % p</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>; <span class="comment">//把k的末位删掉</span></span><br><span class="line">        a = (LL)a*a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,k,p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a,&amp;k,&amp;p);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,qmi(a,k,p));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——筛除法求欧拉函数（六十二）</title>
      <link href="2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%AD%9B%E9%99%A4%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%EF%BC%88%E5%85%AD%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%AD%9B%E9%99%A4%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%EF%BC%88%E5%85%AD%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个正整数n，求1~n中每个数的欧拉函数之和。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>共一行，包含一个整数n。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，包含一个整数，表示1~n中每个数的欧拉函数之和。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤10^6</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>6</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>12</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>1、如果i是质数，那么其欧拉函数值应为i-1<br>2、当i % primes[j] == 0时，说明primes[j]是i的一个质因子，根据欧拉公式，phi[i]一定乘过(1-1/primes[j])这一项，最终推出phi[primes[j] x i] = primes[j] x phi[i]<br>3、当i % primes[j] != 0时，说明primes[j]是i x primes[j]的一个最小质因子，最终推出phi[prime[j] x i] = phi[i] x (primes[j] - 1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> primes[N],cnt;</span><br><span class="line"><span class="keyword">int</span> phi[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get_euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)&#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[primes[j] * i] = primes[j] * phi[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[primes[j] * i] = (primes[j] - <span class="number">1</span>) * phi[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res += phi[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; get_euler(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欧拉函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——欧拉函数（六十一）</title>
      <link href="2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%EF%BC%88%E5%85%AD%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%EF%BC%88%E5%85%AD%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定n个正整数ai，请你求出每个数的欧拉函数。<br><img src="/2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%EF%BC%88%E5%85%AD%E5%8D%81%E4%B8%80%EF%BC%89/1.jpg" alt></p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n。</p><p>接下来n行，每行包含一个正整数ai。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出共n行，每行输出一个正整数ai的欧拉函数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤100 ,<br>1≤ai≤2*10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3<br>3<br>6<br>8</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>2<br>2<br>4</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>根据定义的公式求解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;= a / i; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a % i == <span class="number">0</span>)&#123;</span><br><span class="line">                res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">1</span>) res = res / a * (a - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欧拉函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——最大公约数（六十）</title>
      <link href="2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%EF%BC%88%E5%85%AD%E5%8D%81%EF%BC%89/"/>
      <url>2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%EF%BC%88%E5%85%AD%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定n对正整数ai,bi，请你求出每对数的最大公约数</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n。</p><p>接下来n行，每行包含一个整数对ai,bi。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出共n行，每行输出一个整数对的最大公约数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤10^5 ,<br>1≤ai,bi≤2*10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>2<br>3 6<br>4 6</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>3<br>2</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>a和b的最大公约数 与 b和a mod b的最大公约数 一致，因此产生以下模板，这个模板记住就好。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,gcd(a,b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最大公约数 </tag>
            
            <tag> 欧几里得算法 </tag>
            
            <tag> 辗转相除法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——约数之和（五十九）</title>
      <link href="2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E4%BA%94%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
      <url>2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E4%BA%94%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定n个正整数ai，请你输出这些数的乘积的约数之和，答案对10^9+7取模。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n。</p><p>接下来n行，每行包含一个整数ai。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示所给正整数的乘积的约数之和，答案需对10^9+7取模。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤100 ,<br>1≤ai≤2*10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3<br>2<br>6<br>8</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>252</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p><img src="/2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E4%BA%94%E5%8D%81%E4%B9%9D%EF%BC%89/1.jpg" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt; //由于约数最大有2*10^9级别，数组开不了这么大，因此用hash表来做</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; primes;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">1</span>) primes[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> prime : primes) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = prime.first; <span class="comment">//表示质数的底数</span></span><br><span class="line">        <span class="keyword">int</span>  a = prime.second; <span class="comment">//表示质数的指数</span></span><br><span class="line">        LL t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a--) t =( t * p + <span class="number">1</span>) % mod;</span><br><span class="line">        res = res * t % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 约数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——约数的个数（五十八）</title>
      <link href="2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%BA%A6%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%88%E4%BA%94%E5%8D%81%E5%85%AB%EF%BC%89/"/>
      <url>2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%BA%A6%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%88%E4%BA%94%E5%8D%81%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定n个正整数ai，请你输出这些数的乘积的约数个数，答案对10^9+7取模。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n。</p><p>接下来n行，每行包含一个整数ai。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示所给正整数的乘积的约数个数，答案需对10^9+7取模。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤100 ,<br>1≤ai≤2*10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3<br>2<br>6<br>8</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>12</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p><img src="/2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%BA%A6%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%88%E4%BA%94%E5%8D%81%E5%85%AB%EF%BC%89/1.jpg" alt></p><p>本题思路就是：分解每一个数的质因数，然后再根据约数合数定理求出结果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt; //由于约数最大有2*10^9级别，数组开不了这么大，因此用hash表来做</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; primes;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">1</span>) primes[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> prime : primes) res = res*(prime.second + <span class="number">1</span>) % mod;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 约数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——试除法求约数（五十七）</title>
      <link href="2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E8%AF%95%E9%99%A4%E6%B3%95%E6%B1%82%E7%BA%A6%E6%95%B0%EF%BC%88%E4%BA%94%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>2021/01/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E8%AF%95%E9%99%A4%E6%B3%95%E6%B1%82%E7%BA%A6%E6%95%B0%EF%BC%88%E4%BA%94%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定n个正整数ai，对于每个整数ai,请你按照从小到大的顺序输出它的所有约数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n。</p><p>接下来n行，每行包含一个整数ai。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出共n行，其中第 i 行输出第 i 个整数ai的所有约数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤100,<br>2≤ai≤2*10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>2<br>6<br>8</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>1 2 3 6<br>1 2 4 8 </p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>由于约数也是成对出现，因此只需要把小于n/i的约数找到即可，剩下的因为配对一定可以找到。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / i; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(i != n / i) res.push_back(n / i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(res.begin(),res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">auto</span> res = get_divisors(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t : res) <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 约数 </tag>
            
            <tag> 试除法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——筛质数（五十六）</title>
      <link href="2021/01/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%AD%9B%E8%B4%A8%E6%95%B0%EF%BC%88%E4%BA%94%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>2021/01/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%AD%9B%E8%B4%A8%E6%95%B0%EF%BC%88%E4%BA%94%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个正整数n，请你求出1~n中质数的个数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>共一行，包含整数n。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，包含一个整数，表示1~n中质数的个数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤10^6</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>8</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>4</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>埃氏筛法：<br>以前方的数为基础，删掉可以整除的后方的数。将全部的数过滤完之后，剩余的就是质数。比如：2，3，4，5，6，7，8，9，10，11，12，13，14。跟据2，把4，6，8，10，12，14删除；跟据3，把6，9，12删除；跟据4，把8，12删除；依此类推。</p><p>线性筛法：<br>n只会被最小质因子筛掉<br>1、i % primes[j] == 0<br>    primes[j] 一定是i的最小质因子，primes[j]一定是primes[j] <em> i的最小质因子<br>2、i % primes[j] != 0<br>    primes[j]一定小于i的所有质因子，primes[j]也一定是primes[j] </em> i的最小质因子<br>对于一个合数x，假设primes[j]是x的最小质因子，当i枚举到x/primes[j]时，内层for循环就已经可以将x筛掉了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primes[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//埃氏筛法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =  i + i; j&lt;= n;j+=i) st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线性筛法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes_1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++ )&#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// primes[j]一定是i的最小质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    get_primes(n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 质数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——分界质因数（五十五）</title>
      <link href="2021/01/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%88%86%E7%95%8C%E8%B4%A8%E5%9B%A0%E6%95%B0%EF%BC%88%E4%BA%94%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>2021/01/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%88%86%E7%95%8C%E8%B4%A8%E5%9B%A0%E6%95%B0%EF%BC%88%E4%BA%94%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定n个正整数ai，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n。</p><p>接下来n行，每行包含一个正整数ai。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>对于每个正整数ai,按照从小到大的顺序输出其分解质因数后，每个质因数的底数和指数，每个底数和指数占一行。</p><p>每个正整数的质因数全部输出完毕后，输出一个空行。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤100 ,<br>1≤ai≤2*10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>2<br>6<br>8</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>2 1<br>3 1</p><p>2 3</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题仍旧以试除法为主。<br>这里仅仅指出一点就是，因为n中最多只包含一个大于sqrt(n)的质因子，因此在代码编写的时候，把小于sqrt(n)的质因子找出来之后，再处理大于的情况会更加简便。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123; <span class="comment">// i一定是质数时if才可能成立。因为当枚举到i的时候，n已经把从2到i-1的数除干净了！注意n是一直在while循环中变化的！</span></span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                n /= i;</span><br><span class="line">                s++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i , s);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        divide(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 质数 </tag>
            
            <tag> 质因数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——试除法判定质数（五十四）</title>
      <link href="2021/01/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%A4%E5%AE%9A%E8%B4%A8%E6%95%B0%EF%BC%88%E4%BA%94%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>2021/01/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%A4%E5%AE%9A%E8%B4%A8%E6%95%B0%EF%BC%88%E4%BA%94%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定n个正整数ai，判定每个数是否是质数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n。</p><p>接下来n行，每行包含一个正整数ai。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共n行，其中第 i 行输出第 i 个正整数ai是否为质数，是则输出“Yes”，否则输出“No”。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤100 ,<br>1≤ai≤2^31−1</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>2<br>2<br>6</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>Yes<br>No</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>质数：在大于1的整数中，如果只包含1和本身这两个约数，这个数被称为质数或者叫做素数。<br>利用试除法来对质数进行判定。</p><p>由于有d整除n，那么一定有(n/d)整除n，因此只需要试除小于n/d的数即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++) <span class="comment">//在判断条件中，推荐。不推荐：i &lt;= sqrt(n),i*i &lt; n此类的写法。</span></span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="keyword">bool</span> flag;</span><br><span class="line">        flag = is_prime(num);</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——二分图的最大匹配（五十三）</title>
      <link href="2021/01/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%EF%BC%88%E4%BA%94%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>2021/01/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%EF%BC%88%E4%BA%94%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个二分图，其中左半部包含n1个点（编号1~n1），右半部包含n2个点（编号1~n2），二分图共包含m条边。</p><p>数据保证任意一条边的两个端点都不可能在同一部分中。</p><p>请你求出二分图的最大匹配数。</p><p>*二分图的匹配：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。</p><p>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。*</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含三个整数 n1、 n2 和 m。</p><p>接下来m行，每行包含两个整数u和v，表示左半部点集中的点u和右半部点集中的点v之间存在一条边。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示二分图的最大匹配数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n1,n2≤500 ,<br>1≤u≤n1,<br>1≤v≤n2,<br>1≤m≤10^5</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>2 2 4<br>1 1<br>1 2<br>2 1<br>2 2</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>2</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>匈牙利算法是一种在多项式时间内求解任务分配问题的组合优化算法，并推动了后来的原始对偶方法。通过寻找增广路径，把增广路径中的匹配边和非匹配边的相互交换，这样就会多出一条匹配边，直到找不到增广路径为止。<br>具体理解可见<a href="https://www.cxyxiaowu.com/874.html">这里</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n1,n2,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> match[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[x]; i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[j] == <span class="number">0</span> || find(match[j]))&#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        add(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= n1; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span>(find(i)) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 匈牙利算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——染色法判定二分图（五十二）</title>
      <link href="2021/01/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%AE%9A%E4%BA%8C%E5%88%86%E5%9B%BE%EF%BC%88%E4%BA%94%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>2021/01/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%AE%9A%E4%BA%8C%E5%88%86%E5%9B%BE%EF%BC%88%E4%BA%94%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个n个点m条边的无向图，图中可能存在重边和自环。</p><p>请你判断这个图是否是二分图。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含两个整数n和m。</p><p>接下来m行，每行包含两个整数u和v，表示点u和点v之间存在一条边。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>如果给定图是二分图，则输出“Yes”，否则输出“No”。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n,m≤10^5</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>4 4<br>1 3<br>1 4<br>2 3<br>2 4</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>Yes</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。<br>二分图存在两个性质<br>    性质一：一个图如果是二分图，那么这个图一定可以被二染色。<br>    性质二：二分图当且仅当图中不含有奇数环（环的点数为奇数为奇数环）。</p><p>代码思路如下：<br>    for(int i = 1; i &lt;= n; i++){<br>        if i未被染色：<br>            dfs(i，颜色编号); //用深度优先遍历，把i所在的连通块整个染一遍颜色<br>    }</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> color[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i  = h[u]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!color[j])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(j,<span class="number">3</span>-c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color[j]==c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        add(a,b),add(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i,<span class="number">1</span>))&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 染色法 </tag>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——Kruskal算法求最小生成树（五十一）</title>
      <link href="2021/01/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Kruskal%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88%E4%BA%94%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>2021/01/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Kruskal%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88%E4%BA%94%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。</p><p>求最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。</p><p>给定一张边带权的无向图G=(V, E)，其中V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。</p><p>由V中的全部n个顶点和E中n-1条边构成的无向连通子图被称为G的一棵生成树，其中边的权值之和最小的生成树被称为无向图G的最小生成树。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含两个整数n和m。</p><p>接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤10^5 ,<br>1≤m≤2*10^5,</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>4 5<br>1 2 1<br>1 3 2<br>1 4 3<br>2 3 2<br>3 4 4</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>6</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p> Kruskal算法是一个求最小生成树的算法，该算法在图中存在相同权值的边时也有效。<br> 算法思路如下：<br> 1、将所有边按权重从小到大排序<br> 2、枚举每条边ab,权重c<br>    if(ab不连通) 将这条边加入集合中<br>说白了，就是尝试将边加入最小生成树中。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge &amp;W)<span class="keyword">const</span>&#123; <span class="comment">// 重载小于号按照权重排序</span></span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(edges,edges+m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = edges[i].a, b = edges[i].b, w= edges[i].w;</span><br><span class="line">        a = find(a), b = find(b);</span><br><span class="line">        <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kruskal算法 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——Prim算法求最小生成树 （五十）</title>
      <link href="2021/01/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Prim%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%EF%BC%88%E4%BA%94%E5%8D%81%EF%BC%89/"/>
      <url>2021/01/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Prim%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%EF%BC%88%E4%BA%94%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。</p><p>求最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。</p><p>给定一张边带权的无向图G=(V, E)，其中V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。</p><p>由V中的全部n个顶点和E中n-1条边构成的无向连通子图被称为G的一棵生成树，其中边的权值之和最小的生成树被称为无向图G的最小生成树。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含两个整数n和m。</p><p>接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤500 ,<br>1≤m≤10^5,<br>图中涉及边的边权的绝对值均不超过10000。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>4 5<br>1 2 1<br>1 3 2<br>1 4 3<br>2 3 2<br>3 4 4</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>6 </p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>普里姆算法（Prim’s algorithm），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小。</p><p>算法伪代码：<br>1、dist[i]&lt;- +∞ //初始化全部的点到集合的距离为﹢∞<br>2、for (int i = 0;i&lt;n;i++){<br>    t &lt;- 找到集合外距离最近的点<br>    用t更新其他点到集合的距离<br>    st[t] = true<br>}</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i) res+=dist[t];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            dist[j] = min(dist[j],g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a,&amp;b,&amp;c);</span><br><span class="line">        g[a][b] = g[b][a] = min(g[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t= prim();</span><br><span class="line">    <span class="keyword">if</span>(t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
            <tag> Prim算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——Floyd求最短路（四十九）</title>
      <link href="2021/01/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Floyd%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
      <url>2021/01/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Floyd%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个n个点m条边的有向图，图中可能存在重边和自环，边权可能为负数。</p><p>再给定k个询问，每个询问包含两个整数x和y，表示查询从点x到点y的最短距离，如果路径不存在，则输出“impossible”。</p><p>数据保证图中不存在负权回路。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含三个整数n，m，k</p><p>接下来m行，每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><p>接下来k行，每行包含两个整数x，y，表示询问点x到点y的最短距离。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共k行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出“impossible”。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤200 ,<br>1≤k≤n^2<br>1≤m≤20000,<br>图中涉及边长绝对值均不超过10000。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3 3 2<br>1 2 1<br>2 3 2<br>1 3 1<br>2 1<br>1 3</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>impossible<br>1</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>Floyd-Warshall算法（英语：Floyd-Warshall algorithm），中文亦称弗洛伊德算法或佛洛依德算法，是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权（但不可存在负权回路）的最短路径问题，同时也被用于计算有向图的传递闭包。</p><p>Floyd-Warshall算法的伪代码描述如下：</p><p>1 let dist be a |V| × |V| array of minimum distances initialized to ∞ (infinity)<br>2 for each vertex v<br>3    dist[v][v] ← 0<br>4 for each edge (u,v)<br>5    dist[u][v] ← w(u,v)  // the weight of the edge (u,v)<br>6 for k from 1 to |V|<br>7    for i from 1 to |V|<br>8       for j from 1 to |V|<br>9          if dist[i][j] &gt; dist[i][k] + dist[k][j]<br>10             dist[i][j] ← dist[i][k] + dist[k][j]<br>11         end if<br>其中dist[i][j]表示由点i到点j的权重，当其为 ∞ 表示两点之间没有任何连接。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, Q;</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                d[i][j] = min(d[i][j], d[i][k]+d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;Q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a,&amp;b,&amp;w);</span><br><span class="line">        d[a][b] = min(d[a][b],w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    floyd();</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(d[a][b] &gt; INF / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Floyd算法 </tag>
            
            <tag> 多源汇最短路问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——SPFA判断负环（四十八）</title>
      <link href="2021/01/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94SPFA%E5%88%A4%E6%96%AD%E8%B4%9F%E7%8E%AF%EF%BC%88%E5%9B%9B%E5%8D%81%E5%85%AB%EF%BC%89/"/>
      <url>2021/01/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94SPFA%E5%88%A4%E6%96%AD%E8%B4%9F%E7%8E%AF%EF%BC%88%E5%9B%9B%E5%8D%81%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个n个点m条边的有向图，图中可能存在重边和自环， 边权可能为负数。</p><p>请你判断图中是否存在负权回路。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n和m。</p><p>接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>如果图中存在负权回路，则输出“Yes”，否则输出“No”。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤2000 ,<br>1≤m≤10000,<br>图中涉及边长绝对值均不超过10000。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3 3<br>1 2 -1<br>2 3 4<br>3 1 -4</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>Yes</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>在这个算法中，cnt[N]数组存储目前经过某点的边数。假设一共n个点，当cnt数组经过x点后，对应边数≥n，那么意味着从1到x经过了至少n条边，也就至少经过了n+1个点，根据抽屉原理，路径有n+1个点，因此一定有两个点值相同，因此一定存在对应该点的自环，又因为如果该边权重大于0，那么算法不可能接收此边入cnt中，因此该自环一定是负权回路，由此进行判断图中是否存在。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="keyword">int</span> dist[N], cnt[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c; ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">        <span class="keyword">int</span> t =q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t];i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j =e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])&#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        add(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (spfa()) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPFA算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——SPFA求最短路（四十七）</title>
      <link href="2021/01/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94SPFA%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>2021/01/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94SPFA%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个n个点m条边的有向图，图中可能存在重边和自环， 边权可能为负数。</p><p>请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出impossible。</p><p>数据保证不存在负权回路。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n和m。</p><p>接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示1号点到n号点的最短距离。</p><p>如果路径不存在，则输出”impossible”。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n,m≤10^5 ,<br>图中涉及边长绝对值均不超过10000。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3 3<br>1 2 5<br>2 3 -3<br>1 3 4</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>2</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>有一个博客写的特别好，请移步<a href="https://blog.csdn.net/qq_35644234/article/details/61614581">这里</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c; ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">        <span class="keyword">int</span> t =q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t];i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j =e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])&#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        add(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = spfa();</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPFA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——求有边数限制的最短路（四十六）</title>
      <link href="2021/01/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%B1%82%E6%9C%89%E8%BE%B9%E6%95%B0%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%88%E5%9B%9B%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>2021/01/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%B1%82%E6%9C%89%E8%BE%B9%E6%95%B0%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%88%E5%9B%9B%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个n个点m条边的有向图，图中可能存在重边和自环， 边权可能为负数。</p><p>请你求出从1号点到n号点的最多经过k条边的最短距离，如果无法从1号点走到n号点，输出impossible。</p><p>注意：图中可能 存在负权回路 。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含三个整数n，m，k。</p><p>接下来m行，每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示从1号点到n号点的最多经过k条边的最短距离。</p><p>如果不存在满足条件的路径，则输出“impossible”。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n,k≤500 ,<br>1≤m≤10000,<br>任意边长的绝对值不超过10000。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3 3 1<br>1 2 1<br>2 3 1<br>1 3 3</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>3</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>Bellman-Ford 算法和 Dijkstra 算法同为解决单源最短路径的算法。对于带权有向图 G = (V, E)，Dijkstra 算法要求图 G 中边的权值均为非负，而 Bellman-Ford 算法能适应一般的情况（即存在负权边的情况）。一个实现的很好的 Dijkstra 算法比 Bellman-Ford 算法的运行时间要低。</p><p>Bellman-Ford 算法采用动态规划（Dynamic Programming）进行设计，实现的时间复杂度为 O(V*E)，其中 V 为顶点数量，E 为边的数量。Dijkstra 算法采用贪心算法（Greedy Algorithm）范式进行设计，普通实现的时间复杂度为 O(V2)，若基于 Fibonacci heap 的最小优先队列实现版本则时间复杂度为 O(E + VlogV)。</p><p>Bellman-Ford 算法描述：</p><p>1、创建源顶点 v 到图中所有顶点的距离的集合 distSet，为图中的所有顶点指定一个距离值，初始均为 Infinite，源顶点距离为 0；<br>2、计算最短路径，执行 V - 1 次遍历；<br>    对于图中的每条边：如果起点 u 的距离 d 加上边的权值 w 小于终点 v 的距离 d，则更新终点 v 的距离值 d；<br>3、检测图中是否有负权边形成了环，遍历图中的所有边，计算 u 至 v 的距离，如果对于 v 存在更小的距离，则说明存在环；</p><p>伪代码实现：<br>1 BELLMAN-FORD(G, w, s)<br>2   INITIALIZE-SINGLE-SOURCE(G, s)<br>3   for i  1 to |V[G]| - 1<br>4        do for each edge (u, v)  E[G]<br>5             do RELAX(u, v, w) //松弛操作，即dist[u] = min(dist[u],dist[v] + w)<br>6   for each edge (u, v)  E[G]<br>7        do if d[v] &gt; d[u] + w(u, v)<br>8             then return FALSE<br>9   return TRUE</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m,k;</span><br><span class="line"><span class="keyword">int</span> dist[N],backup[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b ,w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k; i++)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = edges[j].a, b =edges[j].b, w= edges[j].w;</span><br><span class="line">            dist[b] = min(dist[b],backup[a] + w);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n, &amp; m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = bellman_ford();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bellman-Ford算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——Dijkstra求最短路2（四十五）</title>
      <link href="2021/01/26/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Dijkstra%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF2%EF%BC%88%E5%9B%9B%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>2021/01/26/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Dijkstra%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF2%EF%BC%88%E5%9B%9B%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为非负值。</p><p>请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n和m。</p><p>接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示1号点到n号点的最短距离。</p><p>如果路径不存在，则输出-1。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n,m≤1.5×10^5 ,<br>图中涉及边长均不小于0，且不超过10000。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3 3<br>1 2 2<br>2 3 1<br>1 3 4</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>3</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>采用堆的数据结构来辅助dijkstra算法，这样在求不在s数组中的点t离起点的距离最近的点的时间复杂度可从O(n)变为O(1)。同时，由于采用堆的数据结构，因此每次修改一个点的时间复杂度为mlog(n)。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.push(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.push(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        add(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dijkstra() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆优化的dijkstra算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学思维（郑乐隽）电子书链接</title>
      <link href="2021/01/26/%E6%95%B0%E5%AD%A6%E6%80%9D%E7%BB%B4%EF%BC%88%E9%83%91%E4%B9%90%E9%9A%BD%EF%BC%89%E7%94%B5%E5%AD%90%E4%B9%A6%E9%93%BE%E6%8E%A5/"/>
      <url>2021/01/26/%E6%95%B0%E5%AD%A6%E6%80%9D%E7%BB%B4%EF%BC%88%E9%83%91%E4%B9%90%E9%9A%BD%EF%BC%89%E7%94%B5%E5%AD%90%E4%B9%A6%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p><a href="https://pan.baidu.com/s/1j3Lk_eQH1mJypc-UqlFF9g">请点这里！提取码：8td0</a></p>]]></content>
      
      
      <categories>
          
          <category> 电子书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电子书资源 </tag>
            
            <tag> kindle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——Dijkstra求最短路1（四十四）</title>
      <link href="2021/01/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Dijkstra%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF1%EF%BC%88%E5%9B%9B%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>2021/01/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Dijkstra%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF1%EF%BC%88%E5%9B%9B%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p><p>请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n和m。</p><p>接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示1号点到n号点的最短距离。</p><p>如果路径不存在，则输出-1。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤500 ,<br>1≤m≤10^5,<br>图中涉及边长均不超过10000。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3 3<br>1 2 2<br>2 3 1<br>1 3 4</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>3</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题考查迪杰斯特拉算法。<br>一般朴素的迪杰斯特拉算法的思路如下：<br>Step 1：初始化s（代表当前已确定最短距离的点），同时初始化距离，dist[1] = 0, dist[i] = +∞ //一号点距离为0，其他点距离为无穷大<br>Step 2：for i:0-&gt;n:<br>         t &lt;- 不在s中的，距离最近的点<br>         s &lt;- t<br>         用t更新其他点的距离：dist[x] &gt; dist[t] + w</p><p>由于该题展示的图是一种稠密图，用邻接矩阵存比较合适。如果是稀疏图用邻接表存比较合适。<br>另外，代码中采用0x3f3f3f3f作为无穷大的定义，这里有一些解释，仅供参考。<br><img src="/2021/01/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Dijkstra%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF1%EF%BC%88%E5%9B%9B%E5%8D%81%E5%9B%9B%EF%BC%89/1.jpg" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N]; <span class="comment">//表示各点到1号点的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N]; <span class="comment">//表示每个点是否已经确定最短路，是一个标识数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=n; j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;= n; j++)&#123;</span><br><span class="line">            dist[j] = min(dist[j], dist[t] + g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        g[a][b] = min(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = dijkstra();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——有向图的拓扑序列（四十三）</title>
      <link href="2021/01/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>2021/01/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个n个点m条边的有向图，点的编号是1到n，图中可能存在重边和自环。</p><p>请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出-1。</p><p>若一个由图中所有点构成的序列A满足：对于图中的每条边(x, y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含两个整数n和m</p><p>接下来m行，每行包含两个整数x和y，表示存在一条从点x到点y的有向边(x, y)。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。</p><p>否则输出-1。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n,m≤10^5</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3 3<br>1 2<br>2 3<br>1 3</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>1 2 3</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>拓扑序列一定针对有向图来进行的，其定义为：拓扑序列是顶点活动网中将活动按发生的先后次序进行的一种排列。拓扑排序，是对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。</p><p>本题思路代码框架如下：<br>queue &lt;- 所有入度为0的点<br>while (queue不空){<br>    t &lt;- 队头<br>    枚举t的所有出边 t -&gt; j<br>    删掉t -&gt; j //因为t是入度为0的点，一定在最前方，因此删掉t -&gt; j 不影响整体规则<br>    d[j]— //d[]代表某点的入度<br>    if d[j] == 0{<br>        queue &lt;- j<br>    }<br>}</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="keyword">int</span> q[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i]) q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            d[j] --;</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">0</span>) q[++tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span> ,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a,b);</span><br><span class="line">        d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (topsort())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
            <tag> 宽度优先遍历算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——图中点的层次（四十二）</title>
      <link href="2021/01/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9B%BE%E4%B8%AD%E7%82%B9%E7%9A%84%E5%B1%82%E6%AC%A1%EF%BC%88%E5%9B%9B%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>2021/01/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9B%BE%E4%B8%AD%E7%82%B9%E7%9A%84%E5%B1%82%E6%AC%A1%EF%BC%88%E5%9B%9B%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个n个点m条边的有向图，图中可能存在重边和自环。</p><p>所有边的长度都是1，点的编号为1~n。</p><p>请你求出1号点到n号点的最短距离，如果从1号点无法走到n号点，输出-1。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含两个整数n和m。</p><p>接下来m行，每行包含两个整数a和b，表示存在一条从a走到b的长度为1的边。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示1号点到n号点的最短距离。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n,m≤1^5</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>4 5<br>1 2<br>2 3<br>3 4<br>1 3<br>1 4</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>1</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>在题中，给出所有边的长度均为1，这里意味着边权值为1，可以采用宽度优先遍历的算法来搜索最短路问题。另外，在使用宽度优先遍历算法求最短路问题时，第一次被遍历的点可以保证是最短路，因此需要求出第一次遍历到某个点时对应的的最短路径即可。<br><img src="/2021/01/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9B%BE%E4%B8%AD%E7%82%B9%E7%9A%84%E5%B1%82%E6%AC%A1%EF%BC%88%E5%9B%9B%E5%8D%81%E4%BA%8C%EF%BC%89/1.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="keyword">int</span> d[N],q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    </span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">-1</span>)&#123;</span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>;</span><br><span class="line">                q[++tt] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bfs() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树与图的广度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——树的重心（四十一）</title>
      <link href="2021/01/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>2021/01/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一颗树，树中包含n个结点（编号1~n）和n-1条无向边。</p><p>请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。</p><p>重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n，表示树的结点数。</p><p>接下来n-1行，每行包含两个整数a和b，表示点a和点b之间存在一条边。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数m，表示将重心删除后，剩余各个连通块中点数的最大值。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤10^5</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>9<br>1 2<br>1 7<br>1 4<br>2 8<br>2 5<br>4 3<br>3 9<br>4 6</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>4</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p><img src="/2021/01/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B8%80%EF%BC%89/1.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = N;<span class="comment">//存储全局答案，即最小中的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">//标记一下，已经被搜过了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sum  = <span class="number">1</span>, res = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j]) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = dfs(j); <span class="comment">// 表示当前子树的大小</span></span><br><span class="line">            res = max(res,s);</span><br><span class="line">            sum += s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res = max(res, n-sum);</span><br><span class="line">    </span><br><span class="line">    ans = min(ans,res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a,b),add(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树与图的深度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——八数码（四十）</title>
      <link href="2021/01/22/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%85%AB%E6%95%B0%E7%A0%81%EF%BC%88%E5%9B%9B%E5%8D%81%EF%BC%89/"/>
      <url>2021/01/22/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%85%AB%E6%95%B0%E7%A0%81%EF%BC%88%E5%9B%9B%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>在一个3×3的网格中，1~8这8个数字和一个“x”恰好不重不漏地分布在这3×3的网格中。</p><p>例如：</p><p>1 2 3<br>x 4 6<br>7 5 8<br>在游戏过程中，可以把“x”与其上、下、左、右四个方向之一的数字交换（如果存在）。</p><p>我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：</p><p>1 2 3<br>4 5 6<br>7 8 x<br>例如，示例中图形就可以通过让“x”先后与右、下、右三个方向的数字交换成功得到正确排列。</p><p>交换过程如下：</p><p>1 2 3       1 2 3       1 2 3       1 2 3<br>x 4 6       4 x 6       4 5 6       4 5 6<br>7 5 8       7 5 8       7 x 8       7 8 x</p><p>现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>输入占一行，将3×3的初始网格描绘出来。</p><p>例如，如果初始网格如下所示：<br>1 2 3</p><p>x 4 6</p><p>7 5 8</p><p>则输入为：1 2 3 x 4 6 7 5 8</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出占一行，包含一个整数，表示最少交换次数。</p><p>如果不存在解决方案，则输出”-1”。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>2  3  4  1  5  x  7  6  8 </p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>19</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题有两个问题比较复杂，一个是有关网格的状态表示，另一个是如何记录每个状态的距离。第一个问题，采用一个字符串队列来存储。第二个问题根据不同的语言，采用字典或者其他类似的数据结构处理。具体做题思路就是给出起始状态，定义好终止状态，然后枚举x上、下、左、右4个位置进行交换，然后判断是否能够满足题意，若满足则返回距离数值作为答案，不满足返回-1。<br>需要注意的是，BFS求得最短问题，都是基于边权值均为1的基础上。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="built_in">string</span> start)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> end = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; d;</span><br><span class="line">    </span><br><span class="line">    q.push(start);</span><br><span class="line">    d[start] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> distance = d[t];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(t == end) <span class="keyword">return</span> distance;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">int</span> k = t.find(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        <span class="keyword">int</span> x = k / <span class="number">3</span>, y = k % <span class="number">3</span>; <span class="comment">//将一维坐标转化为二维的小技巧</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; <span class="number">3</span> &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                swap(t[k], t[a * <span class="number">3</span> + b]);</span><br><span class="line">                <span class="keyword">if</span> (!d.count(t))&#123;</span><br><span class="line">                    d[t] = distance + <span class="number">1</span>;</span><br><span class="line">                    q.push(t);</span><br><span class="line">                &#125;</span><br><span class="line">                swap(t[k],t[a * <span class="number">3</span> + b]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> start;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        start += c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bfs(start) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——走迷宫（三十九）</title>
      <link href="2021/01/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E8%B5%B0%E8%BF%B7%E5%AE%AB%EF%BC%88%E4%B8%89%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
      <url>2021/01/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E8%B5%B0%E8%BF%B7%E5%AE%AB%EF%BC%88%E4%B8%89%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个n*m的二维整数数组，用来表示一个迷宫，数组中只包含0或1，其中0表示可以走的路，1表示不可通过的墙壁。</p><p>最初，有一个人位于左上角(1, 1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。</p><p>请问，该人从左上角移动至右下角(n, m)处，至少需要移动多少次。</p><p>数据保证(1, 1)处和(n, m)处的数字为0，且一定至少存在一条通路。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含两个整数n和m。</p><p>接下来n行，每行包含m个整数（0或1），表示完整的二维数组迷宫。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示从左上角移动至右下角的最少移动次数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n,m≤100</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>5 5<br>0 1 0 0 0<br>0 1 0 1 0<br>0 0 0 0 0<br>0 1 1 1 0<br>0 0 0 1 0</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>8</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p><img src="/2021/01/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E8%B5%B0%E8%BF%B7%E5%AE%AB%EF%BC%88%E4%B8%89%E5%8D%81%E4%B9%9D%EF%BC%89/1.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[N][N],d[N][N];</span><br><span class="line">PII q[N*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>,tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    </span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)&#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q[++tt] = &#123;x,y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; g[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bfs() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——n皇后问题（三十八）</title>
      <link href="2021/01/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%89%E5%8D%81%E5%85%AB%EF%BC%89/"/>
      <url>2021/01/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%89%E5%8D%81%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>n-皇后问题是指将 n 个皇后放在 n∗n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。<br><img src="/2021/01/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%89%E5%8D%81%E5%85%AB%EF%BC%89/1.png" alt><br>现在给定整数n，请你输出所有的满足条件的棋子摆法。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>共一行，包含整数n。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>每个解决方案占n行，每行输出一个长度为n的字符串，用来表示完整的棋盘状态。</p><p>其中”.”表示某一个位置的方格状态为空，”Q”表示某一个位置的方格上摆着皇后。</p><p>每个方案输出完成后，输出一个空行。</p><p>输出方案的顺序任意，只要不重复且没有遗漏即可。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>4</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>.Q..<br>…Q<br>Q…<br>..Q.</p><p>..Q.<br>Q…<br>…Q<br>.Q..</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>第一种思路：全排列+剪枝。<br>这是一道基于上题的思路（全排列）+剪枝的问题。因为n皇后要求每一个皇后都拥有独立的行和列，因此为全部的皇后进行全排列的过程中，一定存在不满足要求的部分，这些部分需要通过剪枝操作将其剔除出结果，最后剩下的即为答案。</p><p>第二种思路：枚举全部格子进行搜索。<br>每个格子都进行枚举，每个格子都有两种选择，放皇后和不放皇后，然后继续往下寻找，直到皇后全部放好之后输出即可。这里同样需要注意递归后的保护现场。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// //第一种方法思路代码</span></span><br><span class="line"><span class="comment">// #include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const int N = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int n;</span></span><br><span class="line"><span class="comment">// char g[N][N];</span></span><br><span class="line"><span class="comment">// bool col[N],dg[N],udg[N]; //设col为列数组，dg为对角线数组，udg为反对角线数组。同时因为枚举的时候按行枚举，因此保证了每行只有一个，所以不用加row[N]这个数组。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void dfs(int u)&#123;</span></span><br><span class="line"><span class="comment">//     if (u == n)&#123;//找到一组方案 </span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; n; i++) puts(g[i]);</span></span><br><span class="line"><span class="comment">//         puts(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//         return;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     for (int i = 0; i &lt; n; i++)&#123;</span></span><br><span class="line"><span class="comment">//         if(!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i])&#123;</span></span><br><span class="line"><span class="comment">//             g[u][i] = &#x27;Q&#x27;;</span></span><br><span class="line"><span class="comment">//             col[i] = dg[u + i] = udg[n-u+i] = true;</span></span><br><span class="line"><span class="comment">//             dfs(u + 1);</span></span><br><span class="line"><span class="comment">//             col[i] = dg[u + i] = udg[n-u+i] = false;</span></span><br><span class="line"><span class="comment">//             g[u][i] = &#x27;.&#x27;;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int main()&#123;</span></span><br><span class="line"><span class="comment">//     cin &gt;&gt; n;</span></span><br><span class="line"><span class="comment">//     for(int i = 0;i &lt; n; i++)&#123;</span></span><br><span class="line"><span class="comment">//         for(int j = 0; j &lt; n ;j++)&#123;</span></span><br><span class="line"><span class="comment">//             g[i][j] = &#x27;.&#x27;;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     dfs(0);</span></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法思路代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> row[N],col[N],dg[N],udg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> s)</span></span>&#123; <span class="comment">// x y 定位棋盘的格子位置，s代表当前的皇后数</span></span><br><span class="line">    <span class="keyword">if</span>(y == n)&#123;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不放皇后</span></span><br><span class="line">    dfs(x,y+<span class="number">1</span>,s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//放皇后</span></span><br><span class="line">    <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x+y] &amp;&amp; !udg[x-y+n])&#123;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[x+y] = udg[x-y+n] = <span class="literal">true</span>;</span><br><span class="line">        dfs(x,y+<span class="number">1</span>,s+<span class="number">1</span>);</span><br><span class="line">        row[x] = col[y] = dg[x+y] = udg[x-y+n] = <span class="literal">false</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——排列数字（三十七）</title>
      <link href="2021/01/18/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>2021/01/18/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个整数n，将数字1~n排成一排，将会有很多种排列方法。</p><p>现在，请你按照字典序将所有的排列方法输出。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>共一行，包含一个整数n。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>按字典序输出所有排列方案，每个方案占一行。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤7</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p><img src="/2021/01/18/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%83%EF%BC%89/1.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> path[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 深度优先算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——字符串哈希（三十六）</title>
      <link href="2021/01/18/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%EF%BC%88%E4%B8%89%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>2021/01/18/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%EF%BC%88%E4%B8%89%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个长度为n的字符串，再给定m个询问，每个询问包含四个整数l1,r1,l2,r2，请你判断[l1,r1]和[l2,r2]这两个区间所包含的字符串子串是否完全相同。</p><p>字符串中只包含大小写英文字母和数字。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n和m，表示字符串长度和询问次数。</p><p>第二行包含一个长度为n的字符串，字符串中只包含大小写英文字母和数字。</p><p>接下来m行，每行包含四个整数l1,r1,l2,r2，表示一次询问所涉及的两个区间。</p><p>注意，字符串的位置从1开始编号。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>对于每个询问输出一个结果，如果两个字符串子串完全相同则输出“Yes”，否则输出“No”。</p><p>每个结果占一行。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n,m≤10^5</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>8 3<br>aabbaabb<br>1 3 5 7<br>1 3 6 8<br>1 2 1 2</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>Yes<br>No<br>Yes</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题采用字符串前缀hash算法求解非常方便。<br><img src="/2021/01/18/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%EF%BC%88%E4%B8%89%E5%8D%81%E5%85%AD%EF%BC%89/1.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>,P=<span class="number">131</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line">ULL h[N],p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>,&amp;n,&amp;m,str+<span class="number">1</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l1,r1,l2,r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;l1,&amp;r1,&amp;l2,&amp;r2);</span><br><span class="line">        <span class="keyword">if</span> (get(l1,r1) == get(l2,r2)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串前缀哈希法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——模拟散列表（三十五）</title>
      <link href="2021/01/16/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>2021/01/16/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>维护一个集合，支持如下几种操作：</p><p>“I x”，插入一个数x；<br>“Q x”，询问数x是否在集合中出现过；</p><p>现在要进行N次操作，对于每个询问操作输出对应的结果。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数N，表示操作数量。</p><p>接下来N行，每行包含一个操作指令，操作指令为”I x”，”Q x”中的一种。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>对于每个询问指令“Q x”，输出一个询问结果，如果x在集合中出现过，则输出“Yes”，否则输出“No”。</p><p>每个结果占一行。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤10^5<br>−10^9≤x≤10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>5<br>I 1<br>I 2<br>I 3<br>Q 2<br>Q 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>Yes<br>No</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题考查哈希算法。<br>哈希算法，是一种将大域映射为小域的一种处理算法。同时，由于将大域映射为小域，所以必然可能导致映射冲突的问题，不同的数值被映射到同一个值下。因此，这里需要一个处理冲突的方法，最常见的两种为拉链法和开放寻址法。</p><p><img src="/2021/01/16/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89/2.png" alt="开放寻址法"><br><img src="/2021/01/16/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89/1.png" alt="拉链法"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;<span class="comment">//将结果变为正数，k为哈希值</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k]= idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[k]; i != <span class="number">-1</span>;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span>(e[i]==x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);<span class="comment">//memset是计算机中C/C++语言初始化函数。作用是将某一块内存中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,op,&amp;x);<span class="comment">//如果使用scanf读取一个字符，尽量使用字符串去读。因为scanf会把回车、空格、制表符忽略掉。</span></span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>) insert(x);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(find(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——模拟堆（三十四）</title>
      <link href="2021/01/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E5%A0%86%EF%BC%88%E4%B8%89%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>2021/01/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E5%A0%86%EF%BC%88%E4%B8%89%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>维护一个集合，初始时集合为空，支持如下几种操作：</p><p>“I x”，插入一个数x；<br>“PM”，输出当前集合中的最小值；<br>“DM”，删除当前集合中的最小值（数据保证此时的最小值唯一）；<br>“D k”，删除第k个插入的数；<br>“C k x”，修改第k个插入的数，将其变为x；<br>现在要进行N次操作，对于所有第2个操作，输出当前集合的最小值。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数N。<br>接下来N行，每行包含一个操作指令，操作指令为”I x”，”PM”，”DM”，”D k”或”C k x”中的一种。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>对于每个输出指令“PM”，输出一个结果，表示当前集合中的最小值。<br>每个结果占一行。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤10^5<br>−10^9≤x≤10^9<br>数据保证合法。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>8<br>I -10<br>PM<br>I -10<br>D 1<br>C 2 8<br>I 6<br>PM<br>DM</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>-10<br>6</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>通过堆的基本操作，即实现交换堆中的两个元素的基础上进行的up操作和down操作就能够实现题目中给出的几个目标任务。<br><img src="/2021/01/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E5%A0%86%EF%BC%88%E4%B8%89%E5%8D%81%E5%9B%9B%EF%BC%89/1.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], ph[N], hp[N], cnt; <span class="comment">//ph存储第k个插入的数在堆里的下标，hp存储堆中的某个点是第几个插入的元素。维护这样一个数据结构，能够快速找到符合题目要求的第k个插入元素的相关操作。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="comment">//对维护的数组ph和hp也要进行交换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap(ph[hp[a]],ph[hp[b]]);<span class="comment">//交换ph中的两个点</span></span><br><span class="line">    swap(hp[a], hp[b]);<span class="comment">//交换hp中的两个点</span></span><br><span class="line">    swap(h[a], h[b]);<span class="comment">//交换了两个点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = u;<span class="comment">//设置一个临时变量</span></span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;<span class="comment">//判断根节点与左子节点的大小关系，如果小则准备替换</span></span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//判断根节点与右子节点的大小关系，如果小则准备替换</span></span><br><span class="line">    <span class="keyword">if</span> (u != t)<span class="comment">//如果上述判断存在，则u和t铁定不一样，那么进行替换，否则跳过</span></span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u, t);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>]) #和根节点进行比较即可，因为根节点一定最小，和最小的根节点比较，不会修改另一半的分支</span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            m ++ ;</span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            up(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            heap_swap(<span class="number">1</span>, cnt);</span><br><span class="line">            cnt -- ;</span><br><span class="line">            down(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            heap_swap(k, cnt);</span><br><span class="line">            cnt -- ;</span><br><span class="line">            up(k);</span><br><span class="line">            down(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            up(k);</span><br><span class="line">            down(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——堆排序（三十三）</title>
      <link href="2021/01/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>2021/01/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>输入一个长度为n的整数数列，从小到大输出前m小的数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n和m。</p><p>第二行包含n个整数，表示整数数列。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，包含m个整数，表示整数数列中前m小的数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤m≤n≤10^5 ，<br>1≤数列中元素≤10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>5 3<br>4 5 1 3 2</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>1 2 3</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p><img src="/2021/01/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89/1.png" alt><br><img src="/2021/01/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89/2.png" alt><br><img src="/2021/01/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89/3.png" alt><br><img src="/2021/01/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89/4.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],sz;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span> &lt;=sz &amp;&amp; h[u*<span class="number">2</span>]&lt;h[t]) t = u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span> &lt;=sz &amp;&amp; h[u*<span class="number">2</span>+<span class="number">1</span>] &lt; h[t]) t = u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)&#123;</span><br><span class="line">        swap(h[u],h[t]);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line">    sz = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>;i;i--) down(i);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,h[<span class="number">1</span>]);</span><br><span class="line">        h[<span class="number">1</span>] = h[sz];</span><br><span class="line">        sz--;</span><br><span class="line">        down(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——食物链（三十二）</title>
      <link href="2021/01/13/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%A3%9F%E7%89%A9%E9%93%BE%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>2021/01/13/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%A3%9F%E7%89%A9%E9%93%BE%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。</p><p>A吃B， B吃C，C吃A。</p><p>现有N个动物，以1－N编号。</p><p>每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。</p><p>有人用两种说法对这N个动物所构成的食物链关系进行描述：</p><p>第一种说法是”1 X Y”，表示X和Y是同类。</p><p>第二种说法是”2 X Y”，表示X吃Y。</p><p>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。</p><p>当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><p>1） 当前的话与前面的某些真的话冲突，就是假话；<br>2） 当前的话中X或Y比N大，就是假话；<br>3） 当前的话表示X吃X，就是假话。</p><p>你的任务是根据给定的N和K句话，输出假话的总数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行是两个整数N和K，以一个空格分隔。</p><p>以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。</p><p>若D=1，则表示X和Y是同类。</p><p>若D=2，则表示X吃Y。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>只有一个整数，表示假话的数目。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤50000 ,<br>0≤K≤100000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>100 7<br>1 101 1<br>2 1 2<br>2 2 3<br>2 3 3<br>1 1 3<br>2 3 1<br>1 5 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>3</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>这里因为只有三种动物，且三种动物是一个环链式被吃的结构。因此，可以构造一个树形结构，来对三个种类的动物的被吃关系进行界定。假设根节点为某一个动物，可以通过与根节点之间的距离，或者用距离进行模运算的结果来作为被吃的判断依据。比如当与根节点距离模的余数为1的点是可以吃根节点的，那么余数为2的点是可以被根节点吃掉的，余数为0的点是与根节点是同类动物。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =  <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = find(p[x]);</span><br><span class="line">        d[x]+=d[p[x]];</span><br><span class="line">        p[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> t,x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(x &gt; n || y &gt; n)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> px = find(x),py = find(y);</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">1</span> )&#123;</span><br><span class="line">                <span class="keyword">if</span>(px==py &amp;&amp; (d[x]-d[y])%<span class="number">3</span>) res++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px != py)&#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y]-d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(px == py &amp;&amp; (d[x]-d[y]<span class="number">-1</span>)%<span class="number">3</span>)res++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px!=py)&#123;</span><br><span class="line">                    p[px]=py;</span><br><span class="line">                    d[px] = d[y] + <span class="number">1</span> -d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——连通块中点的数量（三十一）</title>
      <link href="2021/01/13/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E8%BF%9E%E9%80%9A%E5%9D%97%E4%B8%AD%E7%82%B9%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>2021/01/13/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E8%BF%9E%E9%80%9A%E5%9D%97%E4%B8%AD%E7%82%B9%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个包含n个点（编号为1~n）的无向图，初始时图中没有边。</p><p>现在要进行m个操作，操作共有三种：</p><p>“C a b”，在点a和点b之间连一条边，a和b可能相等；<br>“Q1 a b”，询问点a和点b是否在同一个连通块中，a和b可能相等；<br>“Q2 a”，询问点a所在连通块中点的数量；</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行输入整数n和m。</p><p>接下来m行，每行包含一个操作指令，指令为“C a b”，“Q1 a b”或“Q2 a”中的一种。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>对于每个询问指令”Q1 a b”，如果a和b在同一个连通块中，则输出“Yes”，否则输出“No”。</p><p>对于每个询问指令“Q2 a”，输出一个整数表示点a所在连通块中点的数量</p><p>每个结果占一行。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n,m≤10^5</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>5 5<br>C 1 2<br>Q1 1 2<br>Q2 1<br>C 2 5<br>Q2 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>Yes<br>2<br>3</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p> 连通块的基本定义为：若从A可以到B且B可以到A，那么A、B两个点在同一个连通块当中。<br> 本题的思路就是把连通块当做集合来处理，和前一道题类似。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N],sz[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回x的祖宗节点，并进行路径压缩优化</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        sz[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="keyword">if</span>(find(b)==find(a)) <span class="keyword">continue</span>;</span><br><span class="line">            sz[find(b)] += sz[find(a)];</span><br><span class="line">            p[find(a)] = find(b);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="keyword">if</span>(find(a) == find(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sz[find(a)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——合并集合（三十）</title>
      <link href="2021/01/13/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89/"/>
      <url>2021/01/13/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>一共有n个数，编号是1~n，最开始每个数各自在一个集合中。</p><p>现在要进行m个操作，操作共有两种：</p><p>“M a b”，将编号为a和b的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；<br>“Q a b”，询问编号为a和b的两个数是否在同一个集合中；</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行输入整数n和m。</p><p>接下来m行，每行包含一个操作指令，指令为“M a b”或“Q a b”中的一种。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>对于每个询问指令”Q a b”，都要输出一个结果，如果a和b在同一集合内，则输出“Yes”，否则输出“No”。</p><p>每个结果占一行。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n,m≤10^5</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>4 5<br>M 1 2<br>M 3 4<br>Q 1 2<br>Q 1 3<br>Q 3 4</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>Yes<br>No<br>Yes</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>并查集：<br>1、将两个集合合并<br>2、询问两个元素是否在一个集合中<br>用树的结构存储两个集合来求解，构造的树的基本原理：每个集合用一颗树表示，树根的编号就是整个集合的编号，每个节点存储其父节点，p[x]表示x的父节点。<br>问题1：如何判断树根？if(p[x] == x)<br>问题2：如何求x的集合编号？while(p[x] != x) x = p[x]<br>问题3：如何合并两个集合？px是x的集合编号，py是y的集合编号，p[x]=y</p><p>因为问题2中求x的集合编号的时间和树的深度有关，因此这里可以优化，即当路径探索到根节点之后，将此路径的全部节点的父节点全部修改为根节点，进行路径压缩。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回x的祖宗节点，并进行路径压缩优化</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>) p[find(a)] = find(b);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(find(a) == find(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——最大异或对（二十九）</title>
      <link href="2021/01/12/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
      <url>2021/01/12/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>在给定的N个整数A1，A2……AN中选出两个进行xor（异或）运算，得到的结果最大是多少？</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行输入一个整数N。</p><p>第二行输入N个整数A1～AN。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数表示答案。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤10^5 ,<br>0≤Ai&lt;2^31</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3<br>1 2 3</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>3</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p><img src="/2021/01/12/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89/1.png" alt="题解"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">3000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> son[M][<span class="number">2</span>],idx;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;~i;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> &amp;s = son[p][x &gt;&gt; i &amp; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!s) s = ++idx;<span class="comment">//创建新节点</span></span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>,p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;~i;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> s = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!s])&#123;</span><br><span class="line">            res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            p = son[p][!s];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = son[p][s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        insert(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++) res = max(res,query(a[i]));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> trie树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——Trie树（二十八）</title>
      <link href="2021/01/12/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Trie%E6%A0%91%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89/"/>
      <url>2021/01/12/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Trie%E6%A0%91%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>Trie字符串统计。<br>维护一个字符串集合，支持两种操作：</p><p>“I x”向集合中插入一个字符串x；<br>“Q x”询问一个字符串在集合中出现了多少次。<br>共有N个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数N，表示操作数。</p><p>接下来N行，每行包含一个操作指令，指令为”I x”或”Q x”中的一种。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>对于每个询问指令”Q x”，都要输出一个整数作为结果，表示x在集合中出现的次数。</p><p>每个结果占一行。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤2*10^4</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>5<br>I abc<br>Q abc<br>Q ab<br>I ab<br>Q ab</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>1<br>0<br>1</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p><img src="/2021/01/12/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Trie%E6%A0%91%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89/Trie树.png" alt="Trie树解释"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>],cnt[N],idx;<span class="comment">//下标为0的点，既是根节点也是空节点</span></span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; str[i];i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; str[i];i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,op,str);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>) insert(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,query(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trie树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——KMP（二十七）</title>
      <link href="2020/12/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94KMP%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>2020/12/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94KMP%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。<br>模板串P在模式串S中多次作为子串出现。<br>求出模板串P在模式串S中所有出现的位置的起始下标。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行输入整数N，表示字符串P的长度。<br>第二行输入字符串P。<br>第三行输入整数M，表示字符串S的长度。<br>第四行输入字符串S。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤10^5<br>1≤M≤10^6</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3<br>aba<br>5<br>ababa</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>0 2</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>在网络上，有关KMP解释我认为最好的，可以参考<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">这篇博客</a>的解释。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="keyword">char</span> s[M],p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求next的过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>; i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = ne[j]; </span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//kmp匹配过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt;= m;i ++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n);</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——单调队列（二十六）</title>
      <link href="2020/12/07/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>2020/12/07/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个大小为n≤10^6的数组。</p><p>有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。</p><p>您只能在窗口中看到k个数字。</p><p>每次滑动窗口向右移动一个位置。</p><p>以下是一个例子：</p><p>该数组为[1 3 -1 -3 5 3 6 7]，k为3。<br><img src="/2020/12/07/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/1.jpg" alt="例子"><br>您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>输入包含两行。</p><p>第一行包含两个整数n和k，分别代表数组长度和滑动窗口的长度。</p><p>第二行有n个整数，代表数组的具体数值。</p><p>同行数据之间用空格隔开。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出包含两个。</p><p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p><p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>8 3<br>1 3 -1 -3 5 3 6 7</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>-1 -3 -3 -3 3 3<br>3 3 5 5 6 7</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题核心思想：构造一个单调队列进行求解。<br><img src="/2020/12/07/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/2.jpg" alt="题解"><br>在代码中，以i作为窗口的右端点，因此需要判断队头元素是否在滑动窗口内部。<br>本题需要认真思考。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt -- ;</span><br><span class="line">        q[ ++ tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt -- ;</span><br><span class="line">        q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——单调栈（二十五）</title>
      <link href="2020/12/06/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8D%95%E8%B0%83%E6%A0%88%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>2020/12/06/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8D%95%E8%B0%83%E6%A0%88%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数N，表示数列长度。</p><p>第二行包含N个整数，表示整数数列。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，包含N个整数，其中第i个数表示第i个数的左边第一个比它小的数，如果不存在则输出-1。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤N≤10^5<br>1≤数列中元素≤10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>5<br>3 4 2 7 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>-1 3 -1 2 2</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>单调栈，就是满足栈的性质，同时从栈顶到栈底的元素是严格递增（或者递减）。<br>在本题中，我们仅需要构造一个单调栈，并每次对栈进行维护，保证单调栈的栈顶满足题目中所给出的要求，即存储左边第一个比当前数小的数。思路如下：<br>1、当遍历序列的第一个数时，该数在序列最左边，无左边最小的数，因此输出-1，并将当前数字压入栈中<br>2、继续遍历，当遍历到第n个数时，该数和栈中的元素进行比较，若该数大于等于栈中元素，则对栈进行弹出，直到栈为空或者找到第一个比该数小的元素为止，然后未找到则输出-1，找到则输出栈顶对应的数字。最后，将该数压入栈中。<br>3、继续重复2，直到全部序列遍历完毕</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x) tt --;</span><br><span class="line">        <span class="keyword">if</span>(tt) <span class="built_in">cout</span> &lt;&lt; stk[tt] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        stk[++tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——模拟队列（二十四）</title>
      <link href="2020/12/04/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>2020/12/04/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>实现一个队列，队列初始为空，支持四种操作：</p><p>(1) “push x” – 向队尾插入一个数x；</p><p>(2) “pop” – 从队头弹出一个数；</p><p>(3) “empty” – 判断队列是否为空；</p><p>(4) “query” – 查询队头元素。</p><p>现在要对队列进行M个操作，其中的每个操作3和操作4都要输出相应的结果。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数M，表示操作次数。</p><p>接下来M行，每行包含一个操作命令，操作命令为”push x”，”pop”，”empty”，”query”中的一种。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>对于每个”empty”和”query”操作都要输出一个查询结果，每个结果占一行。</p><p>其中，”empty”操作的查询结果为“YES”或“NO”，”query”操作的查询结果为一个整数，表示队头元素的值。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤M≤100000 ,<br>1≤x≤109,<br>所有操作保证合法。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>10<br>push 6<br>empty<br>query<br>pop<br>empty<br>push 3<br>push 4<br>pop<br>query<br>push 6</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>NO<br>6<br>YES<br>4</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>队列和栈的最大区别在于，队列是先进先出，因此，队列需要维护队头和队尾。在代码中，使用hh和tt代表队头和队尾，从队头入，从队尾出。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N],hh,tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            q[ ++ tt] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;pop&quot;</span>) hh ++ ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;empty&quot;</span>) <span class="built_in">cout</span> &lt;&lt; (hh &lt;= tt ? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; q[hh] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——模拟栈（二十三）</title>
      <link href="2020/12/04/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E6%A0%88%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>2020/12/04/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E6%A0%88%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>实现一个栈，栈初始为空，支持四种操作：</p><p>(1) “push x” – 向栈顶插入一个数x；</p><p>(2) “pop” – 从栈顶弹出一个数；</p><p>(3) “empty” – 判断栈是否为空；</p><p>(4) “query” – 查询栈顶元素。</p><p>现在要对栈进行M个操作，其中的每个操作3和操作4都要输出相应的结果。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数M，表示操作次数。</p><p>接下来M行，每行包含一个操作命令，操作命令为”push x”，”pop”，”empty”，”query”中的一种。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>对于每个”empty”和”query”操作都要输出一个查询结果，每个结果占一行。</p><p>其中，”empty”操作的查询结果为“YES”或“NO”，”query”操作的查询结果为一个整数，表示栈顶元素的值。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤M≤100000 ,<br>1≤x≤109<br>所有操作保证合法。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>10<br>push 5<br>query<br>push 6<br>pop<br>query<br>pop<br>empty<br>push 4<br>query<br>empty</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>5<br>5<br>YES<br>4<br>NO</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>栈是一种先进后出的数据结构，根据其特性这里仍然采用数组的方式来模拟栈的实现，具体请看代码注释。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> stk[N], tt;<span class="comment">//stk为模拟栈的数组，tt为栈的最上方的元素编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> op;<span class="comment">//定义操作符</span></span><br><span class="line">        <span class="keyword">int</span> x;<span class="comment">//定义值</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            stk[ ++ tt] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;pop&quot;</span>) tt -- ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;empty&quot;</span>) <span class="built_in">cout</span> &lt;&lt; (tt ? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; stk[tt] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——双链表（二十二）</title>
      <link href="2020/12/03/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E9%93%BE%E8%A1%A8%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>2020/12/03/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E9%93%BE%E8%A1%A8%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>实现一个双链表，双链表初始为空，支持5种操作：</p><p>(1) 在最左侧插入一个数；</p><p>(2) 在最右侧插入一个数；</p><p>(3) 将第k个插入的数删除；</p><p>(4) 在第k个插入的数左侧插入一个数；</p><p>(5) 在第k个插入的数右侧插入一个数</p><p>现在要对该链表进行M次操作，进行完所有操作后，从左到右输出整个链表。</p><p>注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数M，表示操作次数。</p><p>接下来M行，每行包含一个操作命令，操作命令可能为以下几种：</p><p>(1) “L x”，表示在链表的最左端插入数x。</p><p>(2) “R x”，表示在链表的最右端插入数x。</p><p>(3) “D k”，表示将第k个插入的数删除。</p><p>(4) “IL k x”，表示在第k个插入的数左侧插入一个数。</p><p>(5) “IR k x”，表示在第k个插入的数右侧插入一个数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，将整个链表从左到右输出。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤M≤100000<br>所有操作保证合法。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>10<br>R 7<br>D 1<br>L 3<br>IL 2 10<br>D 3<br>IL 2 7<br>L 8<br>R 9<br>IL 4 7<br>IR 2 2</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>8 7 7 3 2 9</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p><img src="/2020/12/03/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E9%93%BE%E8%A1%A8%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/1.jpg" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> e[N],l[N],r[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//0表示左端点，1表示右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>,l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在下标k右方插入x，不过这里注意的是，如果想在某个点的左边插入可以通过l[k]的方式在右边插入，使用一种转化的思想求解。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第k个点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;L&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add(<span class="number">0</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;R&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add(l[<span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">            remove(k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;IL&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            add(l[k + <span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            add(k + <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) <span class="built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——单链表（二十一）</title>
      <link href="2020/12/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>2020/12/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>实现一个单链表，链表初始为空，支持三种操作：</p><p>(1) 向链表头插入一个数；</p><p>(2) 删除第k个插入的数后面的数；</p><p>(3) 在第k个插入的数后插入一个数</p><p>现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。</p><p>注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数M，表示操作次数。</p><p>接下来M行，每行包含一个操作命令，操作命令可能为以下几种：</p><p>(1) “H x”，表示向链表头插入一个数x。</p><p>(2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。</p><p>(3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，将整个链表从头到尾输出。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤M≤100000<br>所有操作保证合法。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>10<br>H 9<br>I 1 1<br>D 1<br>D 0<br>H 6<br>I 3 6<br>I 4 5<br>I 4 5<br>I 3 4<br>D 6</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>6 4 6 5</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p><img src="/2020/12/01/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/1.jpg" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="keyword">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到头结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到下标是k的点后面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add_to_head(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (!k) head = ne[head];</span><br><span class="line">            <span class="keyword">else</span> remove(k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            add(k - <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) <span class="built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——区间合并（二十）</title>
      <link href="2020/11/30/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/"/>
      <url>2020/11/30/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定 n 个区间 [li,ri]，要求合并所有有交集的区间。<br>注意如果在端点处相交，也算有交集。<br>输出合并完成后的区间个数。<br>例如：[1,3]和[2,6]可以合并为一个区间[1,6]。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n。<br>接下来n行，每行包含两个整数 l 和 r。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，包含一个整数，表示合并区间完成后的区间个数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤100000 ,<br>−10^9≤li≤ri≤10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>5<br>1 2<br>2 4<br>5 6<br>7 8<br>7 9</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>3</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p><img src="/2020/11/30/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/1.jpg" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    sort(segs.begin(), segs.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.push_back(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = max(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.push_back(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; segs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        segs.push_back(&#123;l, r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    merge(segs);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; segs.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/805/">原题链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——离散化[区间和]（十九）</title>
      <link href="2020/11/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%A6%BB%E6%95%A3%E5%8C%96-%E5%8C%BA%E9%97%B4%E5%92%8C-%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
      <url>2020/11/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%A6%BB%E6%95%A3%E5%8C%96-%E5%8C%BA%E9%97%B4%E5%92%8C-%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是0。<br>现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。<br>接下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含两个整数n和m。<br>接下来 n 行，每行包含两个整数x和c。<br>再接下里 m 行，每行包含两个整数l和r。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共m行，每行输出一个询问中所求的区间内数字和。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>−10^9≤x≤10^9,<br>1≤n,m≤10^5,<br>−10^9≤l≤r≤10^9,<br>−10000≤c≤10000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3 3<br>1 2<br>3 6<br>7 5<br>1 3<br>4 6<br>7 8</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>8<br>0<br>5</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>此题若数据范围小，可以用前缀和的思路去做，构造一个数组，然后对数组进行预处理，最后根据题目要求求解即可。但是，此题数据范围过大，前缀和所需的数组无法正常实现，因此需要采用离散化的算法+前缀和的思路来求解。<br>离散化的意思就是将无限空间中的有限个体映射到有限空间中去，用于提高算法的时空效率。</p><p>求解思路请看下图。<br><img src="/2020/11/29/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%A6%BB%E6%95%A3%E5%8C%96-%E5%8C%BA%E9%97%B4%E5%92%8C-%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/1.jpg" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;<span class="comment">//n和m的范围都是10^5，然后一共是n个x，然后2m个下标，因此最多坐标用了2m+n个，因此开3x10^5+10即可。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; alls;</span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; add, query;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!i || a[i] != a[i - <span class="number">1</span>])</span><br><span class="line">            a[j ++ ] = a[i];</span><br><span class="line">    <span class="comment">// a[0] ~ a[j - 1] 所有a中不重复的数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.begin() + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.push_back(&#123;x, c&#125;);</span><br><span class="line"></span><br><span class="line">        alls.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.push_back(&#123;l, r&#125;);</span><br><span class="line"></span><br><span class="line">        alls.push_back(l);</span><br><span class="line">        alls.push_back(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    sort(alls.begin(), alls.end());</span><br><span class="line">    alls.erase(unique(alls), alls.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = find(item.first);</span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= alls.size(); i ++ ) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理询问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = find(item.first), r = find(item.second);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整数保序离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——位运算[二进制中1的个数]（十八）</title>
      <link href="2020/11/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BD%8D%E8%BF%90%E7%AE%97-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0-%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/"/>
      <url>2020/11/28/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BD%8D%E8%BF%90%E7%AE%97-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0-%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个长度为n的数列，请你求出数列中每个数的二进制表示中1的个数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n。<br>第二行包含n个整数，表示整个数列。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，包含n个整数，其中的第 i 个数表示数列中的第 i 个数的二进制表示中1的个数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤100000,<br>0≤数列中元素的值≤10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>5<br>1 2 3 4 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>1 1 2 1 2</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>首先，求解此题需要知道一个知识点：lowbit操作，即返回x的最后一位的1。<br>lowbit操作：res = x &amp; -x = x &amp; (~x + 1)</p><p>本题中，需要针对每个数字求其中二进制表示的1的个数，那么我们只需要将每个数的二进制表示中的1依次去掉，并进行累加，分别求每一个数的1的个数即可。在运算的过程中，会用到之前提到的知识点，具体请看代码实现。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x) x -= lowbit(x),res++;<span class="comment">//每次减去x的最后一位1</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——双指针算法[判断子序列]（十七）</title>
      <link href="2020/11/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97-%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>2020/11/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97-%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个长度为 n 的整数序列 a1,a2,…,an 以及一个长度为 m 的整数序列 b1,b2,…,bm。<br>请你判断 a 序列是否为 b 序列的子序列。<br>子序列指序列的一部分项按原有次序排列而得的序列，例如序列 {a1,a3,a5} 是序列 {a1,a2,a3,a4,a5} 的一个子序列。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含两个整数 n,m。<br>第二行包含 n 个整数，表示 a1,a2,…,an。<br>第三行包含 m 个整数，表示 b1,b2,…,bm。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>如果 a 序列是 b 序列的子序列，输出一行 Yes。<br>否则，输出 No。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤m≤10^5,<br>−10^9≤ai, bi≤10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3 5<br>1 3 5<br>1 2 3 4 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>Yes</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>这道题是一个典型的双指针算法题。<br>设置两个指针i和j，分别指向a序列和b序列的开头，然后通过i指针遍历a序列，并对每个i对应的元素对b序列中的元素进行匹配，<strong>这里需要注意的是，j指针的方向是单调的。</strong>当对a序列遍历完毕后，若b中均存在与之匹配的元素，则a为b的子序列，否则不是。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span>  (a[i] == b[j]) i++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == n) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针算法 </tag>
            
            <tag> 判断子序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——双指针算法[数组元素的目标和]（十六）</title>
      <link href="2020/11/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C-%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>2020/11/27/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C-%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定两个升序排序的有序数组A和B，以及一个目标值x。数组下标从0开始。<br>请你求出满足A[i] + B[j] = x的数对(i, j)。<br>数据保证有唯一解。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含三个整数n，m，x，分别表示A的长度，B的长度以及目标值x。<br>第二行包含n个整数，表示数组A。<br>第三行包含m个整数，表示数组B。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，包含两个整数 i 和 j。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>数组长度不超过100000。<br>同一数组内元素各不相同。<br>1≤数组元素≤10^9</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>4 5 6<br>1 2 4 7<br>3 4 6 8 9</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>1 1</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>双指针算法，都是可以从暴力的朴素解引申进行思考。<br>设置指针i和j，i从A序列的起始位置开始，j从B序列的末尾位置开始，然后遍历i，在每次遍历i的过程中，对j进行判断，判断条件就是是否满足题中给的公式，即x = Axi+Bxj，若遍历完毕均不满足，则说明不存在。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, x;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; a[i]+b[j] &gt; x) j--;</span><br><span class="line">        <span class="keyword">if</span> (a[i]+b[j] == x)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i,j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/802/">原题链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针算法 </tag>
            
            <tag> 数组元素目标和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——双指针算法[最长连续不重复子序列]（十五）</title>
      <link href="2020/11/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97-%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>2020/11/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97-%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n。<br>第二行包含n个整数（均在0~100000范围内），表示整数序列。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤100000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>5<br>1 2 2 3 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>3</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>双指针算法是经常会在面试笔试中考的算法，是目前必须要准备好的算法之一。<br><img src="/2020/11/25/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97-%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/1.jpg" alt><br>在本题中，由于求解的是最长连续不重复子序列，因此，指针i和指针j的作用就是利用i和j移动，求出在i和j之间最大的不重复元素之间的距离，对i进行从0到n的迭代，j根据i进行迭代，求max_length。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>; i&lt; n; i++)&#123;</span><br><span class="line">        s[a[i]]++;</span><br><span class="line">        <span class="keyword">while</span>(s[a[i]] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            s[a[j]] -- ;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res,i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/801/">原题链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针算法 </tag>
            
            <tag> 最长连续不重复子序列算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——差分矩阵（十四）</title>
      <link href="2020/11/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%B7%AE%E5%88%86%E7%9F%A9%E9%98%B5%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>2020/11/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%B7%AE%E5%88%86%E7%9F%A9%E9%98%B5%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1, y1, x2, y2, c，其中(x1, y1)和(x2, y2)表示一个子矩阵的左上角坐标和右下角坐标。<br>每个操作都要将选中的子矩阵中的每个元素的值加上c。<br>请你将进行完所有操作后的矩阵输出。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n,m,q。<br>接下来n行，每行包含m个整数，表示整数矩阵。<br>接下来q行，每行包含5个整数x1, y1, x2, y2, c，表示一个操作。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n,m≤1000 ,<br>1≤q≤100000,<br>1≤x1≤x2≤n,<br>1≤y1≤y2≤m,<br>−1000≤c≤1000,<br>−1000≤矩阵内元素的值≤1000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3 4 3<br>1 2 2 1<br>3 2 2 1<br>1 1 1 1<br>1 1 2 2 1<br>1 3 2 3 2<br>3 1 3 4 1</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>2 3 4 1<br>4 3 4 1<br>2 2 2 2</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p><img src="/2020/11/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%B7%AE%E5%88%86%E7%9F%A9%E9%98%B5%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/1.jpg" alt><br>我们将题目中输入的矩阵看做a矩阵，那么只需要构造一个类似b矩阵的差分矩阵，那么此题的答案的时间复杂度即为O(1)。<br><img src="/2020/11/24/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%B7%AE%E5%88%86%E7%9F%A9%E9%98%B5%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/2.jpg" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> a[N][N], b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>] -= c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">            insert(i,j,i,j,a[i][j]);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1,x2,y2,c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        insert(x1,y1,x2,y2,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">            b[i][j] += b[i<span class="number">-1</span>][j] + b[i][j<span class="number">-1</span>] - b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span> ;j&lt;=m; j++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/800/">原题链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维差分算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——差分（十三）</title>
      <link href="2020/11/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%B7%AE%E5%88%86%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>2020/11/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%B7%AE%E5%88%86%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>输入一个长度为n的整数序列。<br>接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。<br>请你输出进行完所有操作后的序列。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含两个整数n和m。<br>第二行包含n个整数，表示整数序列。<br>接下来m行，每行包含三个整数l，r，c，表示一个操作。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，包含n个整数，表示最终序列。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n,m≤100000 ,<br>1≤l≤r≤n,<br>−1000≤c≤1000,<br>−1000≤整数序列中元素的值≤1000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>6 3<br>1 2 2 1 2 1<br>1 3 1<br>3 5 1<br>1 6 1</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>3 4 5 3 4 2</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p><img src="/2020/11/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%B7%AE%E5%88%86%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/1.jpg" alt><br>根据题，假设a序列为题中所给的长度为n的序列，利用上述知识，有如下思考：<br><img src="/2020/11/23/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%B7%AE%E5%88%86%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/2.jpg" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l]+=c;</span><br><span class="line">    b[r+<span class="number">1</span>] -=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) insert(i, i, a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);</span><br><span class="line">        insert(l, r, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] += b[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/799/">原题链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差分算法 </tag>
            
            <tag> Hulu面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——二维前缀和（十二）</title>
      <link href="2020/11/22/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>2020/11/22/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。<br>对于每个询问输出子矩阵中所有数的和。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含三个整数n，m，q。<br>接下来n行，每行包含m个整数，表示整数矩阵。<br>接下来q行，每行包含四个整数x1, y1, x2, y2，表示一组询问。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共q行，每行输出一个询问的结果。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n,m≤1000 ,<br>1≤q≤200000,<br>1≤x1≤x2≤n,<br>1≤y1≤y2≤m,<br>−1000≤矩阵内元素的值≤1000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>3 4 3<br>1 7 2 4<br>3 6 2 8<br>2 1 2 3<br>1 1 2 2<br>2 1 3 4<br>1 3 3 4</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>17<br>27<br>21</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>通过一个图和两个公式来说明。<br><img src="/2020/11/22/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/1.png" alt><br>S[i, j] = S[i - 1, j] + S[i, j - 1] - S[i - 1, j - 1] + a[i, j]<br>S{(x1,y1),(x2,y2)} = S[x2, y2] - S[X1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N][N],s[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="comment">//初始化前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">    <span class="comment">//询问</span></span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2] - s[x2][y1 - <span class="number">1</span>] - s[x1 - <span class="number">1</span>][y2] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——前缀和算法（十一）</title>
      <link href="2020/11/22/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%89%8D%E7%BC%80%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>2020/11/22/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%89%8D%E7%BC%80%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>输入一个长度为n的整数序列。<br>接下来再输入m个询问，每个询问输入一对l, r。<br>对于每个询问，输出原序列中从第l个数到第r个数的和。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含两个整数n和m。<br>第二行包含n个整数，表示整数数列。<br>接下来m行，每行包含两个整数l和r，表示一个询问的区间范围。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共m行，每行输出一个询问的结果。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤l≤r≤n,<br>1≤n,m≤100000,<br>−1000≤数列中元素的值≤1000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>5 3<br>2 1 3 6 4<br>1 2<br>1 3<br>2 4</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>3<br>6<br>10</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>这里与数学中的数列类似，同时设置S[0]=0。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]- s[l<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——高精度系列[高精度除法]（十）</title>
      <link href="2020/11/21/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%B3%BB%E5%88%97-%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95-%EF%BC%88%E5%8D%81%EF%BC%89/"/>
      <url>2020/11/21/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%B3%BB%E5%88%97-%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95-%EF%BC%88%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定两个非负整数A，B，请你计算 A / B的商和余数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>共两行，第一行包含整数A，第二行包含整数B。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共两行，第一行输出所求的商，第二行输出所求余数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤A的长度≤100000 ,<br>1≤B≤10000<br>B 一定不为0</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>7<br>2</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>3<br>1</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>通过一个例子来对除法进行解释。<br><img src="/2020/11/21/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%B3%BB%E5%88%97-%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95-%EF%BC%88%E5%8D%81%EF%BC%89/1.png" alt><br>首先，C1到C4是结果位，由于第一位的1小于11，因此C1置为0；然后用12除以11，则余1，那么将余数x10+第三位的数字3=13继续除11，依次类推得到C1-C4，同时得到最终的余数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = A.size() - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        r = r*<span class="number">10</span>+A[i];</span><br><span class="line">        C.push_back(r/b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reverse(C.begin(),C.end());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>;i--) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">auto</span> C = div(A, b, r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.size() - <span class="number">1</span>; i&gt;=<span class="number">0</span>; i --) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//cout &lt;&lt;endl; 等价于: cout&lt;&lt; &#x27;\n&#x27; &lt;&lt; flush;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度整数除法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——高精度系列[高精度乘法]（九）</title>
      <link href="2020/11/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%B3%BB%E5%88%97-%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95-%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <url>2020/11/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%B3%BB%E5%88%97-%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95-%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定两个正整数A和B，请你计算A * B的值。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>共两行，第一行包含整数A，第二行包含整数B。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，包含A * B的值。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤A的长度≤100000 ,<br>0≤B≤10000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>2<br>3</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>6</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>假设A和b相乘，A为高精度数。A的每一位和b相乘，求出每次相乘的结果数以及进位数，然后依次放入结果数列中即可，举个例子：<br><img src="/2020/11/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%B3%BB%E5%88%97-%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95-%EF%BC%88%E4%B9%9D%EF%BC%89/1.jpg" alt><br>C1到C4代表每个位上的结果，t1到t3为进位数。<br>C1 = (3 x 11) % 10 = 3<br>t1 = (3 x 11) / 10 = 3<br>C2 = (2 x 11 + t1) % 10 = 5<br>t2 = (2 x 11) / 10 = 2<br>C3 = (1 x 11 + t2) % 10 = 3<br>t3 = (1 x 11) / 10 = 1<br>C4 = (0 x 11 + t3) = 1<br>故，最终答案为C4C3C2C1=1353。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size()) t+=A[i]*b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);<span class="comment">//把个位取出</span></span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b; <span class="comment">//a=&quot;123456&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> C = mul(A,b); <span class="comment">//auto自动类型推导</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=C.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度整数乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——高精度系列[高精度减法]（八）</title>
      <link href="2020/11/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%B3%BB%E5%88%97-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95-%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <url>2020/11/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%B3%BB%E5%88%97-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95-%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定两个正整数，计算它们的差，计算结果可能为负数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>共两行，每行包含一个整数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，包含所求的差。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤整数长度≤10^5</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>32<br>11</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>21</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>根据减法规则，对应位置的数字相减，那么可以得出以下两种情况，公式如下：<br><img src="/2020/11/20/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%B3%BB%E5%88%97-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95-%EF%BC%88%E5%85%AB%EF%BC%89/1.jpg" alt><br>我们需要注意针对t的运用。t代表每次对应位置相减的结果，同时t还需要保留上一位是否进位的信息，则需要提前将其置1。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() != B.size()) <span class="keyword">return</span> A.size() &gt; B.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.size() <span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,t = <span class="number">0</span>; i &lt; A.size(); i++)&#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.size()) t-=B[i];</span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A,B;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) B.push_back(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cmp(A, B))&#123;</span><br><span class="line">        <span class="keyword">auto</span> C = sub(A,B);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = C.size() - <span class="number">1</span>; i&gt;= <span class="number">0</span>; i-- ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> C =sub(B,A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = C.size() - <span class="number">1</span>; i&gt;= <span class="number">0</span>; i-- ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/794/">原题链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度整数减法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——高精度系列[高精度加法]（七）</title>
      <link href="2020/11/18/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%B3%BB%E5%88%97-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95-%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>2020/11/18/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%B3%BB%E5%88%97-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95-%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定两个正整数，计算它们的和。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>共两行，每行包含一个整数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，包含所求的和。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤整数长度≤100000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>12<br>23</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>35</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>高精度的算法一般是指，其计算范围超过了计算机的存储类型，因此需要构造一个算法来实现高精度的数的基本运算。对于高精度加法，我们可以通过以下思路求解：<br>首先，将高精度数字序列化，存入数组内，这里为了进位方便，我们将从个位数字开始加入数组中。<br>然后，设置一个临时变量，然后按位相加，并根据相加后的大小判断是否需要进位，将最终的结果存入结果数组中<br>最后，将结果数组依次打印出来即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">if</span>(A.size() &lt; B.size()) <span class="keyword">return</span> add(B,A);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.size();i++)&#123;</span><br><span class="line">        t+=A[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;B.size()) t+=B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) C.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A,B;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b; <span class="comment">//a=&quot;123456&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// A = [6,5,4,3,2,1]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.push_back(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> C = add(A,B); <span class="comment">//auto自动类型推导</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=C.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度整数加法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——浮点数二分查找[数的三次方根]（六）</title>
      <link href="2020/11/18/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9-%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>2020/11/18/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9-%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个浮点数n，求它的三次方根。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>共一行，包含一个浮点数n。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共一行，包含一个浮点数，表示问题的解。<br>注意，结果保留6位小数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>−10000≤n≤10000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>1000.00</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>10.000000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>首先，浮点数的二分和整数二分很类似，核心也是针对区间的判断以及求分界点。<br>思考如下：<br>1、定义mid = (l+r)/2，区间范围是[l,r]。<br>2、思考mid^3和x的大小关系，若mid^3大，则说明x^(1/3)的值在左边，即区间更新应该是[l,mid]；若mid^3小，则说明x^(1/3)的值在右边，即区间更新应该是[mid,r]。<br>3、重复以上步骤，直到求出答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-10000</span>, r = <span class="number">10000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1e-8</span>)&#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid *mid &gt;= x) r= mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, l);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/793/">原题链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 | 浮点数二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——整数二分查找[数的范围]（五）</title>
      <link href="2020/11/17/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4-%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>2020/11/17/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4-%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。<br>对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。<br>如果数组中不存在该元素，则返回“-1 -1”。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n和q，表示数组长度和询问个数。<br>第二行包含n个整数（均在1~10000范围内），表示完整数组。<br>接下来q行，每行包含一个整数k，表示一个询问元素。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。<br>如果数组中不存在该元素，则返回“-1 -1”。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤100000<br>1≤q≤10000<br>1≤k≤10000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>6 3<br>1 2 2 3 3 4<br>3<br>4<br>5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>3 4<br>5 5<br>-1 -1</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>本题采用整数二分查找的思想求解。<br>首先，二分查找可以根据某个具体的性质，将某个区间切分为两部分，一部分满足性质，另一部分不满足性质，那么二分查找是可以找到其满足性质的边界点，这是二分查找的核心本质。因此，二分查找，就是求根据某个性质而产生的边界点。<br>那么，我们可以有如下思考，这里给出一张图，根据图来进行说明。<br><img src="/2020/11/17/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4-%EF%BC%88%E4%BA%94%EF%BC%89/1.jpg" alt="二分查找示意图"><br>L和R代表序列的左右边界，黄色区间和红色区间是按照是否满足某个性质而产生的两段，若求黄色和红色的分界点，且设置黄色区间不满足分界性质，红色区间满足分界性质，思考如下：</p><ul><li>当求黄色部分的分界点时：<ul><li>假设mid=（L+R+1）/2，check函数为判断某个点是否满足黄色区间的性质，返回true或false。（ <em>这里mid的定义（L+R+1）/2中的+1是避免出现死循环，具体可以思考当l=r-1时，若不加上1，就会出现死循环</em> ）</li><li>若check（mid）为true，则说明，mid这个点满足条件，因此，分界点一定在其右边，因此接下来需要二分的区间应该是[mid,r]，将l=mid；若check（mid）为false，则说明，mid这个点不满足条件，因此分界点一定在其左边，因此接下来需要二分的区间应该是[l,mid-1],r=mid-1。</li></ul></li><li>当求红色部分的分界点时：<ul><li>假设mid=（L+R）/2, check函数为判断某个点是否满足红色区间的性质，返回true或false。</li><li>若check(mid)为true，则说明，mid这个点满足这个性质，因此分界点应该在mid点的左边即二分的区间应该是[l,mid],r=mid;若check(mid)为false，则说明，mid这个点不满足这个性质，因此分界点应该在mid点的右边，即二分的区间应该是[mid+1,r]，l=mid+1。</li></ul></li></ul><p>回到题中，我们可以进行如下思考:<br><strong>因为题目中求某个数的范围，因此，边界有两个，一个是大于等于x，一个是小于等于x，对每个性质分别使用二分查找的方法求出分界点即可。</strong></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//求左边界</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &gt;= x) r= mid;</span><br><span class="line">            <span class="keyword">else</span> l =mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (q[l] != x) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;-1 -1&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//求右边界</span></span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid]&lt;=x)l=mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 | 整数二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>妈妈的凉调莲白做法</title>
      <link href="2020/11/16/%E5%A6%88%E5%A6%88%E7%9A%84%E5%87%89%E8%B0%83%E8%8E%B2%E7%99%BD%E5%81%9A%E6%B3%95/"/>
      <url>2020/11/16/%E5%A6%88%E5%A6%88%E7%9A%84%E5%87%89%E8%B0%83%E8%8E%B2%E7%99%BD%E5%81%9A%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="食材准备"><a href="#食材准备" class="headerlink" title="食材准备"></a>食材准备</h1><p>1、优质莲菜若干<br>2、生姜一个<br>3、调味料：盐、白醋、味精</p><h1 id="工序"><a href="#工序" class="headerlink" title="工序"></a>工序</h1><p>1、将莲菜洗净，削皮，切薄片，泡入水中淘洗一到两次<br>2、焯水，锅略微冒气泡时将莲菜放入<br>3、当锅中水煮沸时将莲菜捞出<br>4、捞出的莲菜放入凉水中冷却，保证莲菜口感的爽脆<br>5、把莲菜捞出放置到空盆中<br>6、将适量生姜切末，放置到莲菜上，然后放入适量食盐、味精、白醋<br>7、热锅凉油，放花椒，油热时，浇到莲菜上<br>8、搅拌均匀即可</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1、莲菜选用两边封口的莲菜节为佳，以免影响莲菜的口感和色相<br>2、莲菜焯水时，不宜时间过长，否则会影响莲菜的口感<br>3、一定是热锅凉油，放花椒，防止花椒焦化<br>4、菜吃不完放冰箱冷藏，需要时用干净的筷子夹适量到盘中享用即可</p><h1 id="成果图"><a href="#成果图" class="headerlink" title="成果图"></a>成果图</h1><p><a href="https://imgchr.com/i/DVgPaj"><img src="https://s3.ax1x.com/2020/11/17/DVgPaj.jpg" alt="凉调莲白.jpg"></a></p>]]></content>
      
      
      <categories>
          
          <category> 美食 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凉菜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——归并排序[求逆序对的数量]（四）</title>
      <link href="2020/11/16/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F-%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>2020/11/16/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F-%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="【每日算法】基础算法——归并排序-求逆序对的数量-（四）"><a href="#【每日算法】基础算法——归并排序-求逆序对的数量-（四）" class="headerlink" title="【每日算法】基础算法——归并排序[求逆序对的数量]（四）"></a>【每日算法】基础算法——归并排序[求逆序对的数量]（四）</h1><h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。<br><em>逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。</em></p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含整数n，表示数列的长度。<br>第二行包含 n 个整数，表示整个数列。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示逆序对的个数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤100000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>6<br>2 3 4 5 6 1</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>5</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>整个题根据归并排序算法+分治的思想来求解。</p><p>我们将整个序列均分成前后两个部分。将所有的逆序对分成以下三种情况，分别是：</p><ul><li>逆序对中的两个数在前一个区间</li><li>逆序对中的两个数在后一个区间</li><li>逆序对中的两个数一个数在前一个区间，一个数在后一个区间。</li></ul><p>当然，这里需要说明一个问题，那就是前两种情况其实在递归中转化为了第三种情况，比如有个逆序对在前一个区间里，当进行递归之后，这两个数字最终会被切割成两个区间的数字，变为第三种情况，基于此，题目的代码只需要编写对第三种的情况就可，这种结合很巧妙。同时，merge_sort函数的返回定义为逆序对的数量，因此，左右两边是个子问题，所以两个函数递归完就可以求出左右两个区间内部的逆序对数了。由于归并排序的过程中对序列进行了排序，因此前一个区间中的i代表的数若大于后一个区间j代表的数，那么此时针对j代表的数的逆序对的数量为mid-i+1。</p><h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a><strong>需要注意的点</strong></h2><p>由于数据范围是10万，逆序对的数量最多为 10^5x(10^5 -1)/2，大概是 5x10^9 ，这个数值大于int的最大值，因此在代码层面，需要用long long类型来进行求解。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N],tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//递归结束的标志</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>; <span class="comment">//去中间的位置</span></span><br><span class="line">    LL res = merge_sort(l, mid) + merge_sort(mid+<span class="number">1</span>, r); <span class="comment">// 进行递归，将一个大问题编程两个子问题求解，同时返回值是前后两个区间内部的逆序对的数量。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//归并过程</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++]; <span class="comment">// 当q[i]小于q[j]，则不作处理</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[k++] = q[j++];</span><br><span class="line">            res += mid-i+<span class="number">1</span>; <span class="comment">// 当q[i]大于q[j],则说明i后的全部数字大于q[j]，因此针对q[j]来说，逆序对数量为mid-i+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//扫尾</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) tmp[k++] = q[i++]; <span class="comment">// 此时的情况说明上面的while是后面的区间遍历完成，前面的区间仍然没有遍历完，因此需要对前面的区间进行扫尾工作。</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) tmp[k++] = q[j++]; <span class="comment">// 反之亦然</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=l, j=<span class="number">0</span>; i&lt;=r; i++,j++) q[i]=tmp[j]; <span class="comment">// 将临时数组的排列后的有序数组存入q中，保证递归循环后的q的前后两个区间内部有序。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; q[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; merge_sort(<span class="number">0</span>,n<span class="number">-1</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 | 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录在使用hexo中的各种坑（持续更新~）</title>
      <link href="2020/11/15/%E8%AE%B0%E5%BD%95%E5%9C%A8%E4%BD%BF%E7%94%A8hexo%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%9D%91%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0-%EF%BC%89/"/>
      <url>2020/11/15/%E8%AE%B0%E5%BD%95%E5%9C%A8%E4%BD%BF%E7%94%A8hexo%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%9D%91%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0-%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="有关“err-YAMLException-can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key”错误的原因"><a href="#有关“err-YAMLException-can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key”错误的原因" class="headerlink" title="有关“err: YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key”错误的原因"></a>有关“err: YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key”错误的原因</h2><p>1、在创建新的文章时，使用命令中，有关文章题目的字符串中不能有特殊字符，比如[]，不然会报错！因此，只能使用中文的【】。<br>2、在每一个.md配置文件中，key和value对必须中间有空格，不能是k:v，而必须是k: v，否侧会出现配置项解析错误的问题。</p><h2 id="有关使用hexo的草稿，未经允许，部署时自动部署草稿的错误原因"><a href="#有关使用hexo的草稿，未经允许，部署时自动部署草稿的错误原因" class="headerlink" title="有关使用hexo的草稿，未经允许，部署时自动部署草稿的错误原因"></a>有关使用hexo的草稿，未经允许，部署时自动部署草稿的错误原因</h2><p>由于自己之前在测试草稿的过程中，把hexo的配置文件中render_drafts的参数设置为了true，导致部署时自动渲染了草稿文件，因此这个参数设置为false之后就好了。</p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数仓系列之二】离线数仓</title>
      <link href="2020/11/15/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%91%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93/"/>
      <url>2020/11/15/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%91%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、一个离线数仓的架构介绍"><a href="#一、一个离线数仓的架构介绍" class="headerlink" title="一、一个离线数仓的架构介绍"></a>一、一个离线数仓的架构介绍</h2><p>通过之前的系列文章的介绍，数仓是面向主题、集成、相对稳定的、反映历史变化的数据集合，通常用于支持管理决策。因此，离线数仓需要实现对数据的汇总、对数据的处理与分析两大部分的工作。这里，通过一个通用的离线数仓的架构，来进一步介绍，离线数仓是如何实现上述的两个大功能模块的。<br>首先，将架构图奉上。<br><img src="/2020/11/15/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%91%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93/1.png" alt><br>在一般情况下，业务数据和日志数据是一个公司最重要也是最活跃的两种数据类型。在上述架构图中将数据划分为业务和埋点日志两个部分，均有专门的服务器对其进行管理。业务数据通过业务服务器保存至关系型数据库中，埋点日志数据保存在文件中。</p><blockquote><p>Apache Flume是一个分布式的、可靠的、可用的，从多种不同的源收集、聚集、移动大量日志数据到集中数据存储的系统,说白了就是一个监控器，它的作用是监控日志文件，当日志文件中有新内容产生后，会通过框架，读取新增内容，并通过其内部的处理逻辑，按照既定的规则写入目标系统中。<br>Apache Kafka是一个消息系统，将上游涌入的数据通过消息队列技术存储至数据管道中，直到下游对其消费完毕，该框架起到了对数据进行削峰的作用。</p></blockquote><p>因此，在架构中，日志文件产生后，Flume会立即监控到，并针对其中的内容进行读取，将数据传输给Kafka。同时监控Kafka的Flume监控到Kafka存在数据后，将会立即读取Kafka的数据并将其数据写入至HDFS中。这里使用Kafka的目的就是为了对数据起到削峰的作用，确保上下游能够协调一致，避免数据洪峰时，下游消费不及时导致数据丢失等情况的发生，至于其中某个框架启动失败会导致什么结果等问题，在接下来会有讨论，这里不展开细讲。</p><blockquote><p>Apache Sqoop是一款用于hadoop和关系型数据库之间数据导入导出的工具。可以通过Sqoop把数据从数据库（比如MySQL, Oracle）导入到HDFS中；也可以把数据从HDFS中导出到关系型数据库中。</p></blockquote><p>在架构中，每天将业务数据通过Sqoop框架定时导入至HDFS中。<br>两类数据均存储至HDFS中后，Hive将会开始进行数据处理工作，这里就涉及到之前提出的数仓分层的概念，我们来复习一下。</p><div class="table-container"><table><thead><tr><th>层级名称</th><th>解释</th><th>要求</th></tr></thead><tbody><tr><td>ODS（Operation Data Store）</td><td>原始数据层</td><td>存放原始数据，要求对数据不做任何处理，保持数据原貌。</td></tr><tr><td>DWD（Data Warehouse Detail）</td><td>明细数据层</td><td>对ODS层做数据清洗（去除空值、脏数据等），维度退化、脱敏等。粒度是一行信息代表一次行为，例如一次下单。</td></tr><tr><td>DWS（Data Warehouse Service）</td><td>服务数据层</td><td>以DWD为基础，按天进行轻度汇总。粒度是一行信息代表一天的行为，比如一天内下单的次数。</td></tr><tr><td>DWT（Data Warehouse Topic）</td><td>数据主题层</td><td>以DWS为基础，按主题进行汇总。粒度是一行信息代表累积的行为，例如用户层注册那天开始至今一共下了多少单。</td></tr><tr><td>ADS（Application Data Store）</td><td>数据应用层</td><td>为各种统计报表提供数据。</td></tr></tbody></table></div><p>最后，Sqoop会将ADS层的分析结果数据再导入业务数据库中，并通过SuperSet框架进行可视化展示。<br>以上就是一个基本的离线数仓框架，但这些还不够。</p><p>我们可以发现，除了上面说的这些之外，在架构图的下方，有很多其他的框架对离线数仓的功能进行了补充和完善，其中涉及到即席查询、集群监控、定时调度、权限管理、元数据管理、质量监控等各个方面的内容，在后续会逐个进行讲解，这里将一个离线数仓的架构进行一个引入，在后续的文章中会进行详细的分析。</p><h2 id="二、有关数仓的两个问题"><a href="#二、有关数仓的两个问题" class="headerlink" title="二、有关数仓的两个问题"></a>二、有关数仓的两个问题</h2><p>1、数仓为什么要分层？<br>（1）<strong>把复杂的问题简单化</strong>。在当下，数据呈现的特点是无规律，体量大。因此，为了能够更好地管理以及利用数据创造价值，应根据当下业务需求，将复杂的任务分解成多层完成，每一层仅处理简单的任务，也方便在数据出问题时定位问题。<br>（2）<strong>减少重复开发</strong>。规范的数据分层，能够通过中间层的数据，减少极大地重复计算，增加一次计算结果的复用性。<br>（3）<strong>隔离原始数据</strong>。不论是数据异常还是数据的敏感性，都使得真实地数据与统计的数据解耦。</p><p>2、数据集市是什么？<br>数据集市，英文是Data Market。它是一种微型的数据仓库，它通常具有更少的数据， 更少的主题区域，以及更少的历史数据，是一种部门级别的数据仓库，一般只为某个局部范围内的管理人员服务。</p><h2 id="三、数仓理论"><a href="#三、数仓理论" class="headerlink" title="三、数仓理论"></a>三、数仓理论</h2><p>1、范式理论<br>1.1 范式的概念<br>（1）定义：范式就是设计一张数据表的结构应符合的标准级别、规范与要求。<br>（2）优点：降低数据的冗余性；缺点：获取数据时，需要通过join拼接最后的数据。<br>（3）分类：第一范式、第二范式、第三范式、巴斯-科德范式、第四范式、第五范式</p><p>1.2 函数依赖<br>函数依赖有三种依赖关系，分别是完全函数依赖、部分函数依赖以及传递函数依赖。</p><ul><li>完全函数依赖：通过AB能得出C，但AB单独不能得出C，从完全依赖于AB。</li><li>部分函数依赖：通过AB能得出C，通过A也能得出C或者通过B也能得出C，C部分依赖于AB。</li><li>传递函数依赖：通过A得到B，通过B得到C，但是C得不出A，那么C传递依赖于A。</li></ul><p>1.3 三范式区分<br>(1)第一范式：属性不可分割。<br><img src="/2020/11/15/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%91%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93/1.jpg" alt><br>(2)第二范式：不能存在部分函数依赖。<br><img src="/2020/11/15/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%91%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93/2.jpg" alt><br>(3)第三范式：不能存在传递函数依赖。<br><img src="/2020/11/15/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%91%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93/3.jpg" alt></p><p>2、关系建模与维度建模<br>（1）关系建模：<a href="https://fredericniu.cn/2020/11/13/OLTP%E5%92%8COLAP%E7%9A%84%E5%8C%BA%E5%88%AB/">点我跳转~</a><br>（2）维度建模<br>维度建模有三种模型：星型模型、雪花模型和星座模型。<br><img src="/2020/11/15/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%91%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93/4.jpg" alt><img src="/2020/11/15/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%91%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93/5.jpg" alt></p><p>3、<strong>维度表和事实表【重要】</strong><br>（1）维度表</p><ul><li>定义：一般是对事实的描述性信息，每一张维度表对应现实世界中的一个对象或者概念。例如：用户、商品、日期、地区等。</li><li>维度表的特征：维度表范围很宽（具有多个属性、列很多）;跟事实表相比，行数相对较小，通常&lt;10w条;内容相对固定:编码表。</li><li>例子<br><img src="/2020/11/15/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%91%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93/6.jpg" alt="时间维度表"><br>（2）事实表</li><li>定义：事实表中的每行数据代表一个业务事件，例如：下单、支付、退款、评价等。“事实”这个术语表示的是业务事件的度量值（可以统计的次数、个数、金额等）。每个事实表的行包括：具有可加性的数值型的度量值、与维度表相连接的外键、通常具有两个和两个以上的外键、外键之间表示维度表之间多对多的关系。</li><li>一个例子：张三在2020年11月11日于京东购买了一台价值1万元的苹果MacBook pro 15.2寸笔记本电脑。维度表：时间、用户、商品、商家。事实表：1万元、1台。</li><li>特征：非常大、内容相对较窄，列数少，主要是外键id和度量值、经常发生变化。每天新增很多数据。</li><li>类型：事务型事实表、周期型快照事实表、累积型快照事实表<br><img src="/2020/11/15/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%91%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93/7.jpg" alt="事务型事实表和周期型快照事实表"><br><img src="/2020/11/15/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%91%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93/8.jpg" alt="累积型快照事实表"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 离线数仓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——归并排序（三）</title>
      <link href="2020/11/15/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>2020/11/15/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="【每日算法】基础算法——归并排序（三）"><a href="#【每日算法】基础算法——归并排序（三）" class="headerlink" title="【每日算法】基础算法——归并排序（三）"></a>【每日算法】基础算法——归并排序（三）</h1><h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定你一个长度为n的整数数列。<br>请你使用归并排序对这个数列按照从小到大进行排序。<br>并将排好序的数列按顺序输出。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>输入共两行，第一行包含整数 n。<br>第二行包含 n 个整数（所有整数均在1~10^9范围内），表示整个数列。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出共一行，包含 n 个整数，表示排好序的数列。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤100000</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>5<br>3 1 2 4 5</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>1 2 3 4 5</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>归并排序核心思想还是分治，这点要清楚，但是这里的分治和快排的分治还是有不同的。首先，确定分界点[mid=（l+r）/2]，把数组分成前后两个部分。<br>然后进行递归排序左边和右边两个部分的序列。<br>最后将两个部分进行归并。</p><h2 id="对归并算法的归并部分的进一步说明"><a href="#对归并算法的归并部分的进一步说明" class="headerlink" title="对归并算法的归并部分的进一步说明"></a><strong>对归并算法的归并部分的进一步说明</strong></h2><p>归并排序的归并操作是这个算法的难点也是它的核心。<br>这里可以用双指针算法来进行。假设我们已经有了两个有序的序列S1和S2，且指针i和j分别指向两个序列的开头，同时另外开辟一个新的数组R存储最终结果，我们将要对S1和S2进行归并，使其变成一个有序的序列。<br>首先，比较i和j代表的最小值的大小，较小的数则是目前整体序列的最小值，放入R中。<br>然后，假设i指向了较小的指针，那么i指针向后移动，继续将i和j代表的数字进行比较，并将较小的数放入R中，重复上述操作。<br>最后，直到某一个序列遍历完毕，那么将剩下的序列接入到R的后面，完成整个序列的排序操作即可。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h2><p>O(n) = nlogn</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N],tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    merge_sort(q, l, mid), merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>,i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = l,j = <span class="number">0</span>; i &lt;= r; i++, j++) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    merge_sort(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是<a href="https://www.acwing.com/problem/content/789/">原题链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 | 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——快速排序[第k个数]（二）</title>
      <link href="2020/11/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%5B%E7%AC%ACk%E4%B8%AA%E6%95%B0%5D%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2020/11/14/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%5B%E7%AC%ACk%E4%B8%AA%E6%95%B0%5D%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="【每日算法】基础算法——快速排序-第k个数-（二）"><a href="#【每日算法】基础算法——快速排序-第k个数-（二）" class="headerlink" title="【每日算法】基础算法——快速排序[第k个数]（二）"></a>【每日算法】基础算法——快速排序[第k个数]（二）</h1><h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a><strong>题目内容</strong></h2><p>给定一个长度为n的整数数列，以及一个整数k，求出数列从小到大排序后的第k小的数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h2><p>第一行包含两个整数 n 和 k。<br>第二行包含 n 个整数（所有整数均在1~10^9范围内），表示整数数列。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h2><p>输出一个整数，表示数列的第k小数。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h2><p>1≤n≤100000,<br>1≤k≤n</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h2><p>5 3<br>2 4 1 5 3</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><strong>输出样例</strong></h2><p>3</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><p>基于前一讲的快排思路，若将整个数列划分为两个区间后，假设前一个区间的数个数为S1，后一个区间的数的个数为S2，那么和k比较，能够确定第k小的数属于其中哪个区间。所以，只需要递归对应区间中的数即可。不过这里需要注意的是，如果确定在第二个区间的话，那么全局第k小的数在第二个区间对应的是第k-S1的数。然后根据之前的步骤进行递归求出最终的结果。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span> q[l];</span><br><span class="line">    <span class="keyword">int</span> x = q[l],i=l<span class="number">-1</span>,j=r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q[++i]&lt;x);</span><br><span class="line">        <span class="keyword">while</span>(q[--j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sl=j-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;=sl) <span class="keyword">return</span> quick_sort(l,j,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quick_sort(j+<span class="number">1</span>,r,k-sl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; q[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; quick_sort(<span class="number">0</span>,n<span class="number">-1</span>,k) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是<a href="https://www.acwing.com/problem/content/788/">原题链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 | 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法】基础算法——快速排序（一）</title>
      <link href="2020/11/13/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2020/11/13/%E3%80%90%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="【每日算法】基础算法——快速排序（一）"><a href="#【每日算法】基础算法——快速排序（一）" class="headerlink" title="【每日算法】基础算法——快速排序（一）"></a>【每日算法】基础算法——快速排序（一）</h1><p><strong>题目内容</strong><br>给定你一个长度为n的整数数列。<br>请你使用快速排序对这个数列按照从小到大进行排序。<br>并将排好序的数列按顺序输出。<br><strong>输入格式</strong><br>输入共两行，第一行包含整数 n。<br>第二行包含 n 个整数（所有整数均在1~109范围内），表示整个数列。<br><strong>输出格式</strong><br>输出共一行，包含 n 个整数，表示排好序的数列。<br><strong>数据范围</strong><br>1≤n≤100000<br><strong>输入样例：</strong><br>5<br>3 1 2 4 5<br><strong>输出样例：</strong><br>1 2 3 4 5</p><p><strong>题解</strong><br>快速排序的算法的核心思想是分治，主要的思路有一下几步：<br>1、确定分界点，有几种取法，可取左边界/右边界/中间/随机，假设分界点为x，数组为l-&gt;r。<br>2、<strong>调整区间，由于x的出现，将数组划分成了前后两个区间，做操作，使得前一个区间的数小于等于x，后一个区间的数大于等于x。（这里是重点！）</strong><br>3、递归处理左右两个区间进行排序<br>4、归并排序</p><p><strong>对于第二步的实现思路的进一步阐述</strong></p><ul><li>不优美的做法：额外开辟两个数组a、b，然后扫瞄整个区间，如果当前的数小于等于x，插入a中，否则插入到b中，最后把a放入q中，然后把b放入q中。</li><li>优美的做法：在数组的首尾各定义一个指针，分别为i，j。然后i往右边遍历，直到发现某个数大于x，则让i暂时停下，开始让j往左边遍历，直到j发现某个数小于x，然后交换两个数之后，重复上述做法，直到指针i、j相遇。这样做，保证了任何时候，i左边的数一定小于x，j右边的数一定大于x，因此当i、j相遇或少量穿过后，第二步要求的内容就实现了。</li></ul><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h2><p>O(n) = nlogn</p><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quick_sort(q, l, j);</span><br><span class="line">    quick_sort(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    quick_sort(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里是<a href="https://www.acwing.com/problem/content/787/">原题链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 | 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数仓系列之一】什么是数仓</title>
      <link href="2020/11/13/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E4%BB%93/"/>
      <url>2020/11/13/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E4%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="【数仓系列之一】什么是数仓"><a href="#【数仓系列之一】什么是数仓" class="headerlink" title="【数仓系列之一】什么是数仓"></a>【数仓系列之一】什么是数仓</h1><h2 id="一、数仓是什么"><a href="#一、数仓是什么" class="headerlink" title="一、数仓是什么"></a>一、数仓是什么</h2><p><strong>数仓，全称就是数据仓库，是一个面向主题，集成的，相对稳定的，反映历史变化的数据集合，通常用于支持管理决策。</strong>这里的<strong>主题指的是为了分析数据而创造产生的各种有助于决策的数据模型</strong>。<br>随着互联网的发展，数据源头越来越丰富且分散的特点。除了企业中的<strong>业务库</strong>之外，针对<strong>APP的埋点、Web的日志，IOT设备等非结构化的数据</strong>都在近几年呈指数上升。因此，针对此类有着挖掘价值的数据进行分析是目前企业必须去做的事情，同样也是数据仓库越来越重要，越来越得到发展的原因。<br>不过需要注意的是，数据仓库和实时数据库在如今是两个不一样的概念，实时数据库比如MySQL、Oracle、SQLite等，这些数据库的存在是为了满足低延时的业务需求，通常速度快，但能够承载的数据量有限。而数据仓库不需要满足业务上的低延时，反而更加注重对数据的分析和挖掘 ，因此数据仓库要求其数据量要大，数据维度要多。<br>数据仓库，它不是数据的最终目的地，而是为数据最终的目的地做好准备，这些准备包括对数据的：清洗、转义、分类、重组、合并、拆分、统计等工作。</p><h2 id="二、数据仓库的发展"><a href="#二、数据仓库的发展" class="headerlink" title="二、数据仓库的发展"></a>二、数据仓库的发展</h2><p>从1990年 Inmon 提出数据仓库概念到今天，数据架构经历了最初的传统数仓架构——离线数仓架构、Lambda 架构、Kappa 架构以及 Flink 的火热带出的流批一体架构，数据架构技术不断演进，本质都是在往流批一体的方向发展，让用户能以最自然、最小的成本完成实时计算。</p><h3 id="2-1-传统数仓架构"><a href="#2-1-传统数仓架构" class="headerlink" title="2.1 传统数仓架构"></a>2.1 传统数仓架构</h3><p>早期，传统的数据库充当数据仓库的角色，通过离线ETL定期加载离线数据，然后通过一定的分析模型对数据进行计算并产生结果的模式，大致的数仓架构如下：<br><img src="/2020/11/13/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E4%BB%93/传统数仓架构.png" alt="传统数仓架构"></p><h3 id="2-2-离线数仓架构"><a href="#2-2-离线数仓架构" class="headerlink" title="2.2 离线数仓架构"></a>2.2 离线数仓架构</h3><p>随着大数据技术的发展，传统的数仓难以承受海量数据，因此业界开始采用大数据技术来承载存储和计算任务，计算以及存储都采用了基于大数据的框架。<br><img src="/2020/11/13/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E4%BB%93/离线数仓架构.png" alt="离线数仓架构"><br>从图中，我们可以看到，离线的数仓的架构使用了集合采集、同步、消息队列等技术，采用Flume监控日志文件的更新，采用Kafka对消息进行缓冲，使得后续框架能够慢慢消费数据，采用Sqoop对保存在诸如MySQL等数据库中的数据进行同步，使其存储至HDFS中。之后，采用Hive对数据进行处理。<br>这里，将数据处理分成了五层，每层的处理分别如下：</p><div class="table-container"><table><thead><tr><th>层级名称</th><th>解释</th><th>要求</th></tr></thead><tbody><tr><td>ODS（Operation Data Store）</td><td>原始数据层</td><td>存放原始数据，要求对数据不做任何处理，保持数据原貌。</td></tr><tr><td>DWD（Data Warehouse Detail）</td><td>明细数据层</td><td>对ODS层做数据清洗（去除空值、脏数据等），维度退化、脱敏等。粒度是一行信息代表一次行为，例如一次下单。</td></tr><tr><td>DWS（Data Warehouse Service）</td><td>服务数据层</td><td>以DWD为基础，按天进行轻度汇总。粒度是一行信息代表一天的行为，比如一天内下单的次数。</td></tr><tr><td>DWT（Data Warehouse Topic）</td><td>数据主题层</td><td>以DWS为基础，按主题进行汇总。粒度是一行信息代表累积的行为，例如用户层注册那天开始至今一共下了多少单。</td></tr><tr><td>ADS（Application Data Store）</td><td>数据应用层</td><td>为各种统计报表提供数据。                                         </td></tr></tbody></table></div><p>最后将处理好的分析数据同步至MySQL用于BI报表的展示。</p><h3 id="2-3-Lambda架构"><a href="#2-3-Lambda架构" class="headerlink" title="2.3 Lambda架构"></a>2.3 Lambda架构</h3><p>Lambda架构是由Storm的作者Nathan Marz提出的一个实时大数据处理框架。Marz在Twitter工作期间开发了著名的实时大数据处理框架Storm，Lambda架构是其根据多年进行分布式大数据系统的经验总结提炼而成。<br>Lambda架构的目标是设计出一个能满足实时大数据系统关键特性的架构，包括有：高容错、低延时和可扩展等。Lambda架构整合离线计算和实时计算，融合不可变性（Immunability），读写分离和复杂性隔离等一系列架构原则，可集成Hadoop，Kafka，Storm，Spark，Hbase等各类大数据组件。<br><img src="/2020/11/13/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E4%BB%93/Lambda架构.png" alt="Lambda架构"><br>诚然，这个架构在一定程度上满足了当下业界对实时性的部分要求，且Lambda架构经历多年的发展，其优点是稳定，对于实时计算部分的计算成本可控，批量处理可以用晚上的时间来整体批量计算，这样把实时计算和离线计算高峰分开，这种架构支撑了数据行业的早期发展，但是它也有一些致命缺点，并在大数据3.0时代越来越不适应数据分析业务的需求，原因有几个，第一是实时和批量计算结果不一致会引起数据口径的问题，第二是批量计算在一个单位的计算窗口时间内无法完成，第三是开发和维护两个计算队列成本过高，且逻辑复杂，第四是由于计算会产生大量中间结果表，对服务器的存储压力构成一定的威胁。</p><h3 id="2-4-Kappa架构"><a href="#2-4-Kappa架构" class="headerlink" title="2.4 Kappa架构"></a>2.4 Kappa架构</h3><p>2014 年 Jay Kreps 在一次研讨会上指出了一些 Lambda 架构间的差异，大数据世界自此迎来了另一个备选架构，它的代码量更少，特别适用于那些使用多层 Lambda 架构显得有些奢侈的企业场景。Kappa 架构不能被简单视作 Lambda 架构的替代品，相反，它是在离线层对满足业务需求不是必须项时的一个备选项,该架构适合实时处理不同事件。<br><img src="/2020/11/13/%E3%80%90%E6%95%B0%E4%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E4%BB%93/Kappa架构.png" alt="Kappa架构"><br>此架构解决了Lambda架构中的弊病，其在数据需要重新处理或数据变更时，通过Kafka框架保留历史数据的机制，将历史是数据重新处理来完成有关操作。这种方式有点在于将离线批处理层从架构中去除，能够更加高效地进行计算。缺点在于缺少了离线层，可能导致数据处理或数据库更新时发生错误，因此需要添加异常管理来调节矛盾，恢复数据，另外，流式重新处理历史数据的吞吐能力低于离线批处理，这也是这个架构的缺点之一。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OLTP和OLAP的区别</title>
      <link href="2020/11/13/OLTP%E5%92%8COLAP%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>2020/11/13/OLTP%E5%92%8COLAP%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>如今的数据处理大致可以分成两大类，分别是：</p><blockquote><p>1、联机事务处理 <strong>OLTP</strong> <em>On-Line Transaction Processing</em><br>2、联机分析处理 <strong>OLAP</strong> <em>On-Line Analytical Processing</em></p></blockquote><p>OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。<br>二者的主要区别对比如下表所示。</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>对比属性</strong></th><th><strong>OLTP</strong></th><th><strong>OLAP</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>读特性</strong></td><td>每次只查询返回少量记录</td><td>对大量记录进行汇总</td></tr><tr><td style="text-align:center"><strong>写特性</strong></td><td>随机、低延时写入用户输入</td><td>批量导入</td></tr><tr><td style="text-align:center"><strong>使用场景</strong></td><td>用户，JavaEE项目</td><td>数据分析师，为决策提供支持</td></tr><tr><td style="text-align:center"><strong>数据表征</strong></td><td>最新数据动态</td><td>随时间变化的历史状态</td></tr><tr><td style="text-align:center"><strong>数据规模</strong></td><td>GB</td><td>TB到PB</td></tr></tbody></table></div><p>不同的数据处理是用于不同的业务场景来使用，传统的关系型数据库在设计表结构时，就会遵循数据范式要求，将大表拆分为小表进行处理。然而在数据仓库中，对数据表的设计遵循将小表合并成大表的原则，采用批处理的方式进行。</p><p>这篇文章仅为了普及下这方面的知识，搞清楚两者的区别是核心。</p><p><img src="/2020/11/13/OLTP%E5%92%8COLAP%E7%9A%84%E5%8C%BA%E5%88%AB/blog_footer.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库区别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【科普】聊一聊大数据的那些事儿</title>
      <link href="2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
      <url>2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="科普-聊一聊大数据的那些事儿"><a href="#科普-聊一聊大数据的那些事儿" class="headerlink" title="[科普]聊一聊大数据的那些事儿"></a>[科普]聊一聊大数据的那些事儿</h1><p><em>最近一直没更新，不是因为懒，而是要学的东西太多了，时间全用来学大数据的技术栈了，见谅。</em><br>言归正传，这篇科普文章就给大家讲讲大数据的技术栈和生态圈，让大数据不再神秘！</p><h2 id="何谓大数据？"><a href="#何谓大数据？" class="headerlink" title="何谓大数据？"></a>何谓<strong>大数据</strong>？</h2><p>大数据的Wiki英文引文中的解释如下：</p><blockquote><p>The tools, processes and procedures allowing an organization to create, manipulate, and manage very large data sets and storage facilities.<br>允许组织去创建，操纵和管理巨量数据集和存储设施的工具，过程和程序。 </p></blockquote><p>因此，从广义上来说，大数据是一个抽象的概念，它包含了巨量数据本身以及处理它所需要的工具、过程以及程序。从狭义上说，大数据就是各种来源结构化和非结构化的数据集合，通常这种数据集合造成传统软件在可接受的时间内进行数据处理的能力。<br>随着时间的推移，数据的单位增长随着软硬件的不断进步，而呈现出指数倍的增长，在气象学、基因组学、神经网络体学、复杂的物理模拟、生物及环境研究、金融、电商等各个领域，数据的体量已经大到传统的软件程序对其进行分析处理的时间无法承受，也许可能计算一次大气模拟需要一个月之久才能得到结果，但得到的结果的时候已经失去了其本身计算的意义。<br>截止2012年，全世界每天产生2.5EB(1EB=1000PB=1000000TB=1000000000GB)的数据，采用传统的软件处理数据已经是穷途末路，大数据技术的产生是大势所趋。</p><h2 id="大数据的特点"><a href="#大数据的特点" class="headerlink" title="大数据的特点"></a>大数据的特点</h2><p><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/1.jpg" alt="大数据的特点"><br>大数据的特点可以使用5个V来介绍，分别是Velocity、Value、Veracity、Variety、Volume。</p><ul><li><strong>Velocity(速度)</strong>：大数据的产生速度是非常迅速的，图中也介绍了这个特性中的几个要点，分别是批量化产生、近乎实时的要求、处理速度快、以及支持流式处理操作。可以想象，如果一个公司的搜索引擎不能近乎实时且精准地返回用户想要查询的结果，那么这家公司一定会被市场淘汰掉。</li><li><strong>Value(价值)</strong>：数据的增加并不代表数据的价值增加，在一般的情况下，数据价值的密度较低，这是一个沙里淘金的过程。如何采用合适的算法模型来对数据进行分析、挖掘，寻找数据中的价值是未来相当长的一段时间内学界、业界需要共同努力的事情。</li><li><strong>Veracity(真实性)</strong>：这里指的是数据的可信度。一般而言，大数据需要确保获得的数据具有真实性的意义，否则一切都是无意义的徒劳。</li><li><strong>Variety(种类)</strong>：大数据的种类和来源是多样化的，其中包括结构化、半结构化和非结构化的数据，具体表现有文本数据、音视频数据、图片、地理位置数据等等。多类型的数据对目标企业或机构的数据的处理能力就提出了更高的要求。</li><li><strong>Volume(体量)</strong>：毋庸置疑，大数据的数据体量是非常庞大的，通常意义上来说，一次计算的体量至少都应该是GB级别，大多数都是TB级别，有的甚至在PB、EB。</li></ul><h2 id="大数据的技术栈"><a href="#大数据的技术栈" class="headerlink" title="大数据的技术栈"></a>大数据的技术栈</h2><p>从业务流的角度进行分析，大数据的技术栈的功能主要针对数据提供：采集、清洗、存储、查询、计算、可视化等功能。针对这些功能，各个技术机构针对自己的业务需求，开发了可用的框架，目前这些技术框架有很多，我们可以看下面这张图，来宏观感受一下。<br><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/big-data-landscape-2016.png" alt="big-data-landscape-2016"><br>不要被吓到，这里的所有技术并不会要求你全部搞定，一般的大数据从业人员也只需要会每隔小部分中最重要的一个或几个技术就够了。在众多的技术中，最让人熟悉的莫过于Hadoop技术生态圈里的内容了，因此我首先来介绍一下有关Hadoop的技术生态圈，让大家了解Hadoop的各种技术之间是怎么进行协同工作的。<br><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/Hadoop-Ecosystem-2-01.jpg" alt="Hadoop-Ecosystem-2-01"><br>上图是一个Hadoop的技术生态圈，里面包括了Hadoop全部的技术栈，各个技术都充当了整个大数据处理流程中的某个特定角色，下面我来挨着解释一下。<br>1、<strong>HDFS</strong><br>HDFS，全称为Hadoop Distributed File System，叫做Hadoop分布式文件系统。它是Hadoop生态系统中最重要的组件。 HDFS是Hadoop的主要存储系统。 Hadoop分布式文件系统（HDFS）是基于Java的文件系统，可为大数据提供可伸缩、容错、可靠且经济高效的数据存储。 HDFS是在商用硬件上运行的分布式文件系统。它支持通过类似shell的命令的直接交互。HDFS其内部有两个最重要的组件，分别是NameNode和DataNode。<br>NameNode，不存储实际的数据而是对文件系统内的元数据进行管理，比如数据块信息、数据分布的存放节点与位置、DataNode节点的数据存放细节等，在同一个集群中，此组件要求只能有一个处于工作状态。<br>DataNode，负责在HDFS中存储实际数据。DataNode根据客户端的请求执行读取和写入操作。DataNode的副本块由文件系统上的2个文件组成。第一个文件用于数据，第二个文件用于记录块的元数据。在启动时，每个DataNode连接到其相应的NameNode并进行握手。命名空间ID和DataNode的软件版本的验证通过握手进行。发现不匹配时，DataNode自动关闭。DataNode根据NameNode的指令执行诸如块副本创建，删除和复制之类的操作。</p><p>2、<strong>Mapreduce</strong><br>Hadoop MapReduce是提供数据处理的核心Hadoop生态系统组件。MapReduce是一个大数据计算框架，用于处理Hadoop分布式文件系统中存储的大量结构化和非结构化数据的计算应用程序。MapReduce程序本质上是并行的，因此对于使用集群中的多台计算机执行大规模数据分析非常有用。因此，它提高了集群并行处理的速度和可靠性。<br><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/16033334978481.jpg" alt><br>在MapReduce中，有两个阶段，分别是Map阶段和Reduce阶段。每个阶段都有键值对作为输入和输出。Map函数获取一组数据并将其转换为另一组数据，其中个元素分解为元组(键值对)。Reduce函数将Map的输出作为输入，并根据键组合这些数据元组，并相应地修改键的值。<br>该框架拥有运行处理PB级数据的能力，以及快速、高容错性等特点，是Hadoop生态圈中很重要的技术框架。</p><p>3、<strong>YARN</strong><br>Hadoop Yarn(Yet Another Resource Negotiator)，是提供资源管理的Hadoop生态系统组件。Yarn也是Hadoop生态系统中最重要的组件之一。 YARN被称为Hadoop的操作系统，因为它负责管理和监视工作负载。它允许多个数据处理引擎（例如实时流和批处理）处理存储在单个平台上的数据。<br><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/16033339756310.jpg" alt><br>Yarn具有灵活性的特点，除了可以用于批处理计算框架，比如MapReduce外，还可以用于其他模式的数据处理，比如交互式和流式处理模式。由于这个优势，其他的计算框架也可以在Yarn的资源调度下，与MapReduce程序一起运行，提高了Hadoop集群的服务效率。另外，Yarn还具有高共享性的特点，在多个工作负载之间提供稳定、可靠、安全的共享操作服务，所以在对于数据处理的过程中，可以使用其他的编程模型，比如图形处理模型或迭代模型等。</p><p>4、<strong>ZooKeeper</strong><br>Apache Zookeeper是Hadoop生态系统的重要组件，提供了分布式应用程序的协调服务，它是一个为分布式应用提供一致性服务的软件，包括阿配置维护、域名服务、分布式同步、组服务等。<br>Zookeeper的特性有以下几个方面：</p><pre><code>* **顺序一致性**，从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到Zookeeper中去。* **原子性**，所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，即整个集群要么都成功应用了某个事务，要么都没有应用。* **单一视图**，无论客户端连接的是哪个 Zookeeper 服务器，其看到的服务端数据模型都是一致的。* **可靠性**，一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会一直被保留，除非有另一个事务对其进行了变更。* **实时性**，Zookeeper 保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。</code></pre><p><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/16033347392741.jpg" alt><br>这个技术的出现，在总体上解决了我们所说的拜占庭将军问题，也就是分布式系统中最大的难题，即协调一致的问题。当然，顺便提一句，在分布式系统领域，有一篇很重要的论文，名字叫做<a href="https://lamport.azurewebsites.net/pubs/paxos-simple.pdf">《Paxos Made Simple》</a>，有兴趣各位可以读一下。<br>5、<strong>Hive</strong><br>Apache Hive是一个开源数据仓库系统，是一个数据分析框架，其用于查询和分析存储在Hadoop文件中的大型数据集。Hive具有三个主要功能：数据汇总，查询和分析。Hive使用称为HiveQL（HQL）的语言，与SQL相似。 HiveQL自动将类似SQL的查询转换为MapReduce作业，该作业将在Hadoop上执行。简而言之，Hive就是在Hadoop上架了一层SQL接口，可以将SQL翻译成MapReduce去Hadoop上执行，这样就使得数据开发和分析人员很方便的使用SQL来完成海量数据的统计和分析。<br><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/16033357884445.jpg" alt><br>6、<strong>Pig(目前用的很少了)</strong><br>Apache Pig是用于分析和查询HDFS中存储的巨大数据集的高级语言平台。Pig作为Hadoop生态系统的组成部分，使用PigLatin语言。它与SQL非常相似。它加载数据，应用所需的过滤器并以所需格式转储数据。为了执行程序，Pig需要Java运行时环境。</p><p>7、<strong>HBase</strong><br>Apache HBase是Hadoop生态系统组件，它是一个分布式数据库，旨在将结构化数据存储在可能具有数十亿行和数百万列的表中。 HBase是基于HDFS构建的可扩展，分布式和NoSQL数据库。 HBase，提供对HDFS中读取或写入数据的实时访问。<br><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/16033363537603.jpg" alt><br>有两个HBase组件，即HBase Master和RegionServer。HBaseMaster，它不是实际数据存储的一部分，而是协商所有RegionServer之间的负载平衡，同时其维护和监视Hadoop集群。具体来说，它执行管理（用于创建，更新和删除表的界面。）、控制故障转移、处理DDL操作。RegionServer是工作节点，负责处理来自客户端的读取，写入，更新和删除请求，进程在Hadoop群集中的每个节点上运行，一般与HDFS DateNode节点保持一致，保证计算向数据移动的特性。<br>8、<strong>HCatalog</strong><br>Apache HCatalog是Hadoop的表和存储的管理层。它支持Hadoop生态系统中可用的不同组件，例如MapReduce，Hive等，以轻松地从集群读取和写入数据。HCatalog是Hive的关键组件，使用户能够以任何格式和结构存储其数据。在默认情况下，HCatalog支持RCFile，CSV，JSON，sequenceFile和ORC文件格式。<br>9、<strong>Avro</strong><br>Acro是Hadoop生态系统的一部分，是最流行的数据序列化系统。Avro是一个开源项目，为Hadoop提供数据序列化和数据交换服务。这些服务可以一起使用，也可以独立使用。大数据可以使用Avro交换以不同语言编写的程序。使用序列化服务程序可以将数据序列化为文件或消息。它将数据定义和数据存储在一个消息或文件中，使程序可以轻松地动态了解存储在Avro文件或消息中的信息。Avro模式–依靠模式进行序列化/反序列化。Avro需要用于数据写入/读取的架构。当Avro数据存储在文件中时，其架构也随之存储，因此以后任何程序都可以处理文件。动态类型化–指不生成代码的序列化和反序列化。它补充了代码生成功能，该功能可在Avro中用于静态类型的语言，作为可选优化。<br>10、<strong>Thrift</strong><br>Apache Thrift是一个轻量级、跨语言的远程服务调用框架，最初是由FaceBook开发，后面进入了Apache开源项目。它通过自身的IDL中间语言, 并借助代码生成引擎生成各种主流语言的RPC服务端/客户端模板代码。在Hadoop的技术生态中，很多技术均用到了此框架的技术。<br><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/16033542390516.jpg" alt></p><p>11、<strong>Drill</strong><br>Apache Drill是一个低延迟的分布式海量数据（涵盖结构化、半结构化以及嵌套数据）交互式查询引擎，使用ANSI SQL兼容语法，支持本地文件、HDFS、HBase、MongoDB等后端存储，支持Parquet、JSON、CSV、TSV、PSV等数据格式。本质上Apache Drill是一个分布式的mpp（大规模并行处理）查询层。Drill的目的在于支持更广泛的数据源，数据格式，以及查询语言。受Google的Dremel启发，Drill满足上千节点的PB级别数据的交互式商业智能分析场景。</p><p>12、<strong>Mahout</strong><br>Apache Mahout提供了一些经典的机器学习的算法，皆在帮助开发人员更加方便快捷地创建智能应用程序。通过ApacheMahout库，Mahout可以有效地扩展到云中。Mahout包括许多实现，包括聚类、分类、推荐引擎、频繁子项挖掘。Apache Mahout的主要目标是建立可伸缩的机器学习算法。这种可伸缩性是针对大规模的数据集而言的。通过Apache Mahout的算法库，Mahout可以有效地使用Hadoop集群的能力进行机器学习的计算与分析。</p><p>13、<strong>Sqoop</strong><br>Apache Sqoop是一款用于hadoop和关系型数据库之间数据导入导出的工具。你可以通过Sqoop把数据从数据库（比如mysql,oracle）导入到HDFS中；也可以把数据从HDFS中导出到关系型数据库中。Sqoop通过Hadoop的MapReduce导入导出，因此提供了很高的并行性能以及良好的容错性。<br><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/16033547834909.jpg" alt></p><p>14、<strong>Flume</strong><br>Apache Flume是一个分布式的、可靠的、可用的，从多种不同的源收集、聚集、移动大量日志数据到集中数据存储的系统。Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力 。Flume提供了从console（控制台）、RPC（Thrift-RPC）、text（文件）、tail（UNIX tail）、syslog（syslog日志系统），支持TCP和UDP等2种模式，exec（命令执行）等数据源上收集数据的能力。它使用一个简单的可扩展数据模型，该模型可用于在线分析应用程序。<br><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/16033549486336.jpg" alt></p><p>15、<strong>Ambari</strong><br>Apache Ambari的功能就是创建、管理、监视Hadoop的集群，这里的Hadoop是广义，指的是 Hadoop 整个生态圈（例如 Hive、Hbase、Sqoop、Zookeeper等）。用一句话来说，Ambari 就是为了让 Hadoop 以及相关的大数据软件更容易使用的一个工具。随着Ambari为操作控制提供一致，安全的平台，Hadoop管理变得更加简单。<br><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/16033551523884.jpg" alt></p><p>16、<strong>Oozie</strong><br>Apache Oozie是用于管理Hadoop作业的工作流调度程序系统。 Oozie将多个作业依次组合为一个逻辑工作单元。 Oozie框架与作为架构中心的Apache Yarn完全集成，并支持Apache MapReduce、Hive、Sqoop等Hadoop技术中需要调度的作业。<br><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/16033552650350.jpg" alt></p><p>以上是Hadoop技术生态圈的讲解，但这里还没有完，因为在目前业界使用最广泛的大数据技术中，还有几个技术不得不提一下。</p><p>17、<strong>Spark</strong><br>Apache Spark是一个基于Scala语言编写的分布式计算框架，最初是由加州大学伯克利分销AMPLab实验室开发，相对于MapReduce计算框架，它减少了内存与磁盘的IO操作，从而提高了计算时间。Spark采用了基于内存的运算，将中间数据结果存储在内存中，方便下次计算调用。该框架的计算速度根据官网的介绍，基于内存的计算中比MapReduce快100倍，基于磁盘的计算中比MapReduce快10倍。Spark内部有五个重要组成部分，分别是Spark Core、Spark SQL、Spark Streaming、MLlib和GraphX。在存在递归迭代运算的场景下，Spark非常适合。<br><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/16033567519649.jpg" alt></p><p>18、<strong>Elastic Search</strong><br>Elastic Search是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。Elasticsearch用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。它的核心算法是倒排索引算法。<br><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/16033569739650.jpg" alt></p><p>19、<strong>Kafka</strong><br>Apache Kafka是一种分布式的，基于发布 / 订阅的消息系统，采用Java和Scala编写。该平台为处理即时数据提供了统一、高吞吐、低延迟的服务。目前越来越多的开源分布式处理系统如Cloudera、Apache Storm、Spark都支持与Kafka集成。Kafka是一个消息系统，原本开发自LinkedIn，用作 LinkedIn 的活动流（Activity Stream）和运营数据处理管道（Pipeline）的基础。现在它已被多家不同类型的公司 作为多种类型的数据管道和消息系统使用。它能够以时间复杂度为 O(1) 的方式提供消息持久化能力，即使对 TB 级以上数据也能保证常数时间复杂度的访问性能。它拥有高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒 100K 条以上消息的传输。它支持 Kafka Server 间的消息分区，及分布式消费，同时保证每个 Partition 内的消息顺序传输。它同时支持离线数据处理和实时数据处理。最后它还支持在线水平扩展。<br><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/16033572499331.jpg" alt></p><p>20、<strong>Flink</strong><br>Apache Flink是一个框架和分布式处理引擎，用于在无边界和有边界数据流上进行有状态的计算。Flink能在所有常见集群环境中运行，并能以内存速度和任意规模进行计算。Apache Flink 是一个分布式系统，它需要计算资源来执行应用程序。Flink 集成了所有常见的集群资源管理器，例如 Hadoop YARN、 Apache Mesos 和 Kubernetes，但同时也可以作为独立集群运行。Flink被设计为能够很好地工作在上述每个资源管理器中，这是通过资源管理器特定(resource-manager-specific)的部署模式实现的。Flink 可以采用与当前资源管理器相适应的方式进行交互。部署 Flink 应用程序时，Flink 会根据应用程序配置的并行性自动标识所需的资源，并从资源管理器请求这些资源。在发生故障的情况下，Flink 通过请求新资源来替换发生故障的容器。提交或控制应用程序的所有通信都是通过 REST 调用进行的，这可以简化 Flink 与各种环境中的集成。Flink旨在任意规模上运行有状态流式应用。因此，应用程序被并行化为可能数千个任务，这些任务分布在集群中并发执行。所以应用程序能够充分利用无尽的 CPU、内存、磁盘和网络 IO。而且 Flink 很容易维护非常大的应用程序状态。其异步和增量的检查点算法对处理延迟产生最小的影响，同时保证精确一次状态的一致性。<br><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/16033578170831.jpg" alt></p><p>以上就是大数据应用比较广泛的技术架构的介绍。</p><p>最后我想说的是，技术会一直更新演变下去，但核心的思想总是不会改变的，在学习技术的过程中，需要的是对思想的理解与运用，而不是就一个技术而学一个技术。同时，没有任何一个技术是完美无缺的，只有适合与不适合的区别。在实际的业务场景下，根据公司的实际情况，选择合适的大数据技术架构完成需求业务才是重中之重。</p><p><img src="/2020/11/13/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/1626376-20200922165136805-82723816.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科普 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
